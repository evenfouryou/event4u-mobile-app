================================================================================
FILE: server/siae-routes.ts
================================================================================
// SIAE Module API Routes
import { Router, Request, Response, NextFunction } from "express";
import { escapeXml, formatSiaeDateCompact, formatSiaeTimeCompact, formatSiaeTimeHHMM, formatSiaeDate, formatSiaeDateTime, toCentesimi, normalizeSiaeTipoTitolo, normalizeSiaeCodiceOrdine, generateSiaeFileName, generateSiaeAttachmentName, SIAE_SYSTEM_CODE_DEFAULT, SIAE_CANCELLED_STATUSES, isCancelledStatus, validateC1Report, type C1ValidationResult, generateC1LogXml, type C1LogParams, type SiaeEventForLog, type SiaeTicketForLog, generateRCAXml, type RCAParams, type RCAResult, mapToSiaeTipoGenere, parseSiaeResponseFile, type SiaeResponseParseResult, resolveSystemCode, resolveSystemCodeForSmime, validateSiaeReportPrerequisites, validateSystemCodeConsistency, type SiaePrerequisiteData, type SiaePrerequisiteValidation, validatePreTransmission, autoCorrectSiaeXml, generateC1Xml, type C1XmlParams, type C1EventContext, type C1SectorData, type C1TicketData, type C1SubscriptionData, validateSiaeSystemCode } from './siae-utils';
import { siaeStorage } from "./siae-storage";
import { storage } from "./storage";
import { db } from "./db";
import { events, siaeCashiers, siaeTickets, siaeTransactions, siaeSubscriptions, siaeCashierAllocations, siaeOtpAttempts, siaeNameChanges, siaeResales, publicCartItems, publicCheckoutSessions, publicCustomerSessions, tableBookings, guestListEntries, siaeTransmissions, companies, siaeEmissionChannels, siaeSystemConfig, userFeatures, siaeTicketedEvents, users, siaeEventSectors, floorPlanSeats, siaeSeats, floorPlanZones, siaeAuditLogs, siaeCustomers, venueFloorPlans, siaeNumberedSeats } from "@shared/schema";
import { eq, and, or, sql, desc, isNull, SQL, gte, lte, count, inArray } from "drizzle-orm";
import { z } from "zod";
import bcrypt from "bcryptjs";
import { requestFiscalSeal, isCardReadyForSeals, isBridgeConnected, getCachedBridgeStatus, requestXmlSignature, getCachedEfffData } from "./bridge-relay";
import { sendPrintJobToAgent, getConnectedAgents } from "./print-relay";
import { generateTicketHtml } from "./template-routes";
import { sendOTP as sendMSG91OTP, verifyOTP as verifyMSG91OTP, resendOTP as resendMSG91OTP, isMSG91Configured } from "./msg91-service";
import { getUncachableStripeClient } from "./stripeClient";
import { ticketTemplates, ticketTemplateElements } from "@shared/schema";
import {
  insertSiaeEventGenreSchema,
  insertSiaeSectorCodeSchema,
  insertSiaeTicketTypeSchema,
  insertSiaeServiceCodeSchema,
  insertSiaeCancellationReasonSchema,
  insertSiaeActivationCardSchema,
  insertSiaeEmissionChannelSchema,
  insertSiaeSystemConfigSchema,
  insertSiaeCustomerSchema,
  insertSiaeOtpAttemptSchema,
  insertSiaeTicketedEventSchema,
  insertSiaeEventSectorSchema,
  insertSiaeSeatSchema,
  insertSiaeFiscalSealSchema,
  insertSiaeTicketSchema,
  insertSiaeTransactionSchema,
  insertSiaeNameChangeSchema,
  insertSiaeResaleSchema,
  insertSiaeLogSchema,
  insertSiaeTransmissionSchema,
  insertSiaeBoxOfficeSessionSchema,
  insertSiaeSubscriptionSchema,
  insertSiaeSubscriptionTypeSchema,
  siaeSubscriptionTypes,
  insertSiaeAuditLogSchema,
  insertSiaeNumberedSeatSchema,
  insertSiaeSmartCardSessionSchema,
  insertSiaeSmartCardSealLogSchema,
} from "@shared/schema";

// Helper to create validated partial schemas for PATCH operations
// Uses .strict() to reject unknown fields and .refine() to reject empty payloads
function makePatchSchema<T extends z.AnyZodObject>(schema: T) {
  return schema.partial().strict().refine(
    (obj: Record<string, unknown>) => Object.keys(obj).length > 0,
    { message: "Payload vuoto non permesso" }
  );
}

// Create validated partial schemas for PATCH - omitting immutable fields where needed
const patchEventGenreSchema = makePatchSchema(insertSiaeEventGenreSchema.omit({ code: true }));
const patchSectorCodeSchema = makePatchSchema(insertSiaeSectorCodeSchema.omit({ code: true }));
const patchTicketTypeSchema = makePatchSchema(insertSiaeTicketTypeSchema.omit({ code: true }));
const patchServiceCodeSchema = makePatchSchema(insertSiaeServiceCodeSchema.omit({ code: true }));
const patchCancellationReasonSchema = makePatchSchema(insertSiaeCancellationReasonSchema.omit({ code: true }));
const patchActivationCardSchema = makePatchSchema(insertSiaeActivationCardSchema.omit({ cardCode: true }));
const patchEmissionChannelSchema = makePatchSchema(insertSiaeEmissionChannelSchema.omit({ companyId: true }));
const patchSystemConfigSchema = makePatchSchema(insertSiaeSystemConfigSchema.omit({ companyId: true }));
const patchCustomerSchema = makePatchSchema(insertSiaeCustomerSchema.omit({ uniqueCode: true }) as z.AnyZodObject);
const patchTicketedEventSchema = makePatchSchema(insertSiaeTicketedEventSchema.omit({ companyId: true }));
const patchEventSectorSchema = makePatchSchema(insertSiaeEventSectorSchema.omit({ ticketedEventId: true }));
const patchSeatSchema = makePatchSchema(insertSiaeSeatSchema.omit({ sectorId: true }));
const patchFiscalSealSchema = makePatchSchema(insertSiaeFiscalSealSchema.omit({ sealCode: true, cardId: true }));
const patchTicketSchema = makePatchSchema(insertSiaeTicketSchema.omit({ ticketedEventId: true, sectorId: true, fiscalSealId: true }));
const patchTransactionSchema = makePatchSchema(insertSiaeTransactionSchema.omit({ customerId: true, ticketedEventId: true }));
const patchNameChangeSchema = makePatchSchema(insertSiaeNameChangeSchema.omit({ originalTicketId: true, requestedById: true }));
const patchResaleSchema = makePatchSchema(insertSiaeResaleSchema.omit({ originalTicketId: true, sellerId: true }));
const patchTransmissionSchema = makePatchSchema(insertSiaeTransmissionSchema.omit({ companyId: true }));
const patchBoxOfficeSessionSchema = makePatchSchema(insertSiaeBoxOfficeSessionSchema.omit({ emissionChannelId: true, userId: true }));
const patchSubscriptionSchema = makePatchSchema(insertSiaeSubscriptionSchema.omit({ customerId: true }));
const patchSubscriptionTypeSchema = makePatchSchema(insertSiaeSubscriptionTypeSchema.omit({ companyId: true, ticketedEventId: true }) as z.AnyZodObject);
const patchNumberedSeatSchema = makePatchSchema(insertSiaeNumberedSeatSchema.omit({ sectorId: true }));

const router = Router();

// SIAE Test Environment Configuration
const SIAE_TEST_EMAIL = process.env.SIAE_TEST_EMAIL || 'servertest2@batest.siae.it';
const SIAE_TEST_MODE = process.env.SIAE_TEST_MODE === 'true';

// Get SIAE destination email based on mode
function getSiaeDestinationEmail(overrideEmail?: string): string {
  if (overrideEmail) return overrideEmail;
  return SIAE_TEST_MODE ? SIAE_TEST_EMAIL : SIAE_TEST_EMAIL; // In production, this would use the real SIAE email
}

console.log('[SIAE Routes] Router initialized, registering routes...');
console.log(`[SIAE Routes] Test mode: ${SIAE_TEST_MODE}, Test email: ${SIAE_TEST_EMAIL}`);

/**
 * Valida e normalizza il Codice Fiscale italiano (16 caratteri)
 * Implementa l'algoritmo di checksum ufficiale dell'Agenzia delle Entrate
 * @returns { valid: boolean, normalized: string, error?: string }
 */
function validateCodiceFiscale(cf: string | null | undefined): { valid: boolean; normalized: string; error?: string } {
  if (!cf || cf.trim() === '') {
    return { valid: false, normalized: '', error: 'Codice Fiscale obbligatorio' };
  }
  
  const normalized = cf.toUpperCase().replace(/\s/g, '');
  
  // Lunghezza: 16 caratteri per persone fisiche, 11 per persone giuridiche (P.IVA format)
  if (normalized.length === 11 && /^\d{11}$/.test(normalized)) {
    // È una Partita IVA, non un CF - valida come P.IVA
    return validatePartitaIva(normalized);
  }
  
  if (normalized.length !== 16) {
    return { valid: false, normalized, error: 'Codice Fiscale deve essere di 16 caratteri' };
  }
  
  // Pattern: 6 lettere + 2 numeri + 1 lettera + 2 numeri + 1 lettera + 3 alfanum + 1 lettera
  const cfPattern = /^[A-Z]{6}\d{2}[A-Z]\d{2}[A-Z]\d{3}[A-Z]$/;
  if (!cfPattern.test(normalized)) {
    return { valid: false, normalized, error: 'Formato Codice Fiscale non valido' };
  }
  
  // Tabelle per il calcolo del carattere di controllo
  const oddMap: Record<string, number> = {
    '0': 1, '1': 0, '2': 5, '3': 7, '4': 9, '5': 13, '6': 15, '7': 17, '8': 19, '9': 21,
    'A': 1, 'B': 0, 'C': 5, 'D': 7, 'E': 9, 'F': 13, 'G': 15, 'H': 17, 'I': 19, 'J': 21,
    'K': 2, 'L': 4, 'M': 18, 'N': 20, 'O': 11, 'P': 3, 'Q': 6, 'R': 8, 'S': 12, 'T': 14,
    'U': 16, 'V': 10, 'W': 22, 'X': 25, 'Y': 24, 'Z': 23
  };
  
  const evenMap: Record<string, number> = {
    '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
    'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7, 'I': 8, 'J': 9,
    'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15, 'Q': 16, 'R': 17, 'S': 18, 'T': 19,
    'U': 20, 'V': 21, 'W': 22, 'X': 23, 'Y': 24, 'Z': 25
  };
  
  const controlChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  
  // Calcola checksum
  let sum = 0;
  for (let i = 0; i < 15; i++) {
    const char = normalized[i];
    if (i % 2 === 0) {
      // Posizione dispari (1-based), usa oddMap
      sum += oddMap[char] ?? 0;
    } else {
      // Posizione pari (1-based), usa evenMap
      sum += evenMap[char] ?? 0;
    }
  }
  
  const expectedControl = controlChars[sum % 26];
  const actualControl = normalized[15];
  
  if (expectedControl !== actualControl) {
    return { valid: false, normalized, error: 'Carattere di controllo Codice Fiscale non valido' };
  }
  
  return { valid: true, normalized };
}

/**
 * Valida e normalizza la Partita IVA italiana (11 cifre)
 * Implementa l'algoritmo di checksum Luhn modificato
 * @returns { valid: boolean, normalized: string, error?: string }
 */
function validatePartitaIva(piva: string | null | undefined): { valid: boolean; normalized: string; error?: string } {
  if (!piva || piva.trim() === '') {
    return { valid: false, normalized: '', error: 'Partita IVA obbligatoria' };
  }
  
  const normalized = piva.replace(/\s/g, '').replace(/[^0-9]/g, '');
  
  if (normalized.length !== 11) {
    return { valid: false, normalized, error: 'Partita IVA deve essere di 11 cifre' };
  }
  
  // Tutte le cifre devono essere numeri
  if (!/^\d{11}$/.test(normalized)) {
    return { valid: false, normalized, error: 'Partita IVA deve contenere solo cifre' };
  }
  
  // Algoritmo di controllo Partita IVA italiana
  const digits = normalized.split('').map(d => parseInt(d, 10));
  
  let sumOdd = 0;
  let sumEven = 0;
  
  for (let i = 0; i < 10; i++) {
    if (i % 2 === 0) {
      // Posizione dispari (1-based)
      sumOdd += digits[i];
    } else {
      // Posizione pari (1-based) - raddoppia e sottrai 9 se > 9
      const doubled = digits[i] * 2;
      sumEven += doubled > 9 ? doubled - 9 : doubled;
    }
  }
  
  const total = sumOdd + sumEven;
  const expectedControl = (10 - (total % 10)) % 10;
  const actualControl = digits[10];
  
  if (expectedControl !== actualControl) {
    return { valid: false, normalized, error: 'Cifra di controllo Partita IVA non valida' };
  }
  
  return { valid: true, normalized };
}

/**
 * Valida Codice Fiscale o Partita IVA (accetta entrambi i formati)
 * Utile per campi che possono contenere l'uno o l'altro
 */
function validateFiscalId(id: string | null | undefined): { valid: boolean; normalized: string; type: 'cf' | 'piva' | null; error?: string } {
  if (!id || id.trim() === '') {
    return { valid: false, normalized: '', type: null, error: 'Codice Fiscale o Partita IVA obbligatorio' };
  }
  
  const cleaned = id.toUpperCase().replace(/\s/g, '');
  
  // Prova prima come Partita IVA (11 cifre)
  if (/^\d{11}$/.test(cleaned)) {
    const pivaResult = validatePartitaIva(cleaned);
    return { ...pivaResult, type: pivaResult.valid ? 'piva' : null };
  }
  
  // Altrimenti prova come Codice Fiscale (16 caratteri)
  const cfResult = validateCodiceFiscale(cleaned);
  return { ...cfResult, type: cfResult.valid ? 'cf' : null };
}

import { createHash } from 'crypto';

interface TransmissionStats {
  totalIva: number;
  totalEsenti: number;
  totalImpostaIntrattenimento: number;
  ticketsChanged: number;
  ticketsResold: number;
  // FIX 2026-01-18: Aggiunti campi autoritativi per resend e validazione
  totalGross: number;        // Totale lordo (solo biglietti NON annullati)
  cancelledCount: number;    // Conteggio biglietti annullati (tutti gli stati SIAE)
  activeTicketCount: number; // Conteggio biglietti attivi (non annullati)
}

export async function calculateTransmissionStats(
  filteredTickets: any[],
  companyId: string,
  eventId?: string,
  tipoTassazione?: string,
  entertainmentIncidence?: number
): Promise<TransmissionStats> {
  let totalIva = 0;
  let totalEsenti = 0;
  let totalImpostaIntrattenimento = 0;
  let ticketsChanged = 0;
  let ticketsResold = 0;
  // FIX 2026-01-18: Campi separati per metriche resend
  let totalGross = 0;        // Totale lordo solo biglietti attivi
  let cancelledCount = 0;    // Biglietti annullati o sostituiti
  let activeTicketCount = 0; // Biglietti attivi
  
  for (const ticket of filteredTickets) {
    const vatAmount = parseFloat(ticket.vatAmount || '0');
    const grossAmount = parseFloat(ticket.grossAmount || '0');
    const ticketStatus = ticket.status || '';
    
    // ORIGINALE: totalIva/totalEsenti/totalImpostaIntrattenimento su TUTTI i biglietti
    // Questo mantiene compatibilità con le trasmissioni iniziali
    totalIva += vatAmount;
    
    if (vatAmount === 0) {
      totalEsenti += grossAmount;
    }
    
    if (tipoTassazione === 'I' && entertainmentIncidence) {
      totalImpostaIntrattenimento += grossAmount * (entertainmentIncidence / 100);
    }
    
    // FIX 2026-01-18: Calcolo metriche separate per resend
    // Un biglietto è "cancellato" se: isCancelledStatus OPPURE ha replacedByTicketId
    const isCancelled = isCancelledStatus(ticketStatus) || !!ticket.replacedByTicketId;
    
    if (isCancelled) {
      cancelledCount++;
    } else {
      // Solo biglietti attivi contribuiscono a totalGross
      totalGross += grossAmount;
      activeTicketCount++;
    }
    
    // Conteggio cambio nominativo (sottocategoria degli annullati)
    if (ticketStatus === 'annullato_cambio_nominativo' || ticket.replacedByTicketId) {
      ticketsChanged++;
    }
  }
  
  if (eventId) {
    try {
      const resales = await siaeStorage.getSiaeResalesByEvent(eventId);
      ticketsResold = resales.length;
    } catch (err) {
      console.warn(`[SIAE] Could not fetch resales for event ${eventId}:`, err);
    }
  }
  
  return {
    totalIva,
    totalEsenti,
    totalImpostaIntrattenimento,
    ticketsChanged,
    ticketsResold,
    totalGross,
    cancelledCount,
    activeTicketCount,
  };
}

export function calculateFileHash(xmlContent: string): string {
  return createHash('sha256').update(xmlContent).digest('hex');
}

// Middleware to check if user is authenticated
function requireAuth(req: Request, res: Response, next: NextFunction) {
  if (!req.isAuthenticated || !req.isAuthenticated()) {
    return res.status(401).json({ message: "Non autorizzato" });
  }
  next();
}

// Middleware to check if user is super admin
function requireSuperAdmin(req: Request, res: Response, next: NextFunction) {
  if (!req.user || (req.user as any).role !== 'super_admin') {
    return res.status(403).json({ message: "Accesso riservato ai Super Admin" });
  }
  next();
}

// Middleware to check if user is gestore or super admin
function requireGestore(req: Request, res: Response, next: NextFunction) {
  const user = req.user as any;
  if (!user || (user.role !== 'super_admin' && user.role !== 'gestore')) {
    return res.status(403).json({ message: "Accesso riservato ai Gestori" });
  }
  next();
}

// Middleware to check if user is organizer or higher
function requireOrganizer(req: Request, res: Response, next: NextFunction) {
  const user = req.user as any;
  if (!user || !['super_admin', 'gestore', 'organizer'].includes(user.role)) {
    return res.status(403).json({ message: "Accesso riservato agli Organizzatori" });
  }
  next();
}

// Middleware to check if user is organizer OR cashier (for operations like cancel-range)
function requireOrganizerOrCashier(req: Request, res: Response, next: NextFunction) {
  const user = req.user as any;
  if (!user || !['super_admin', 'gestore', 'organizer', 'cassiere'].includes(user.role)) {
    return res.status(403).json({ message: "Accesso riservato agli Organizzatori o Cassieri" });
  }
  next();
}

// ==================== DEBUG ENDPOINT - Test Email SIAE ====================
// Endpoint pubblico per testare l'invio email SMTP (solo in development)
// NOTA: Usa codice sistema test P0004010 per evitare errori SIAE 0600
router.get("/api/siae/debug/test-smtp", async (req: Request, res: Response) => {
  try {
    const { emailTransporter, sendSiaeTransmissionEmail } = await import('./email-service');
    
    // FIX 2026-01-16: Usa codice sistema test valido invece di EVENT4U1
    // P0004010 è un codice test valido (P + 7 cifre)
    const DEBUG_TEST_SYSTEM_CODE = 'P0004010';
    
    // Test 1: Verifica connessione SMTP
    const smtpStatus = await new Promise<{connected: boolean; error?: string}>((resolve) => {
      emailTransporter.verify((error, success) => {
        if (error) {
          resolve({ connected: false, error: error.message });
        } else {
          resolve({ connected: true });
        }
      });
    });
    
    // Get destination email from query or use default
    const testDestination = (req.query.to as string) || process.env.SIAE_TEST_EMAIL || 'servertest2@batest.siae.it';
    
    // Test 2: Invia email di test
    let emailSent = false;
    let emailError: string | null = null;
    
    try {
      const now = new Date();
      const dataRiepilogo = now.getFullYear().toString() + String(now.getMonth() + 1).padStart(2, '0') + String(now.getDate()).padStart(2, '0');
      const oraGenerazione = String(now.getHours()).padStart(2, '0') + String(now.getMinutes()).padStart(2, '0') + String(now.getSeconds()).padStart(2, '0');
      // NOTA: Nessun DOCTYPE - i Web Service SIAE non risolvono DTD esterni (XXE protection)
      // FIX 2026-01-16: Usa codice sistema test P0004010 invece di EVENT4U1
      const testXml = `<?xml version="1.0" encoding="UTF-8"?>
<RiepilogoControlloAccessi Sostituzione="N">
  <Titolare>
    <DenominazioneTitolareCA>DEBUG TEST COMPANY</DenominazioneTitolareCA>
    <CFTitolareCA>DBGTST00A00A000A</CFTitolareCA>
    <CodiceSistemaCA>${DEBUG_TEST_SYSTEM_CODE}</CodiceSistemaCA>
    <DataRiepilogo>${dataRiepilogo}</DataRiepilogo>
    <DataGenerazioneRiepilogo>${dataRiepilogo}</DataGenerazioneRiepilogo>
    <OraGenerazioneRiepilogo>${oraGenerazione}</OraGenerazioneRiepilogo>
    <ProgressivoRiepilogo>1</ProgressivoRiepilogo>
  </Titolare>
  <Evento>
    <CFOrganizzatore>DBGTST00A00A000A</CFOrganizzatore>
    <DenominazioneOrganizzatore>DEBUG TEST COMPANY</DenominazioneOrganizzatore>
    <TipologiaOrganizzatore>G</TipologiaOrganizzatore>
    <SpettacoloIntrattenimento>N</SpettacoloIntrattenimento>
    <IncidenzaIntrattenimento>100</IncidenzaIntrattenimento>
    <DenominazioneLocale>DEBUG Locale Test</DenominazioneLocale>
    <CodiceLocale>0000000000000</CodiceLocale>
    <DataEvento>${dataRiepilogo}</DataEvento>
    <OraEvento>2000</OraEvento>
    <TipoGenere>DI</TipoGenere>
    <TitoloEvento>Debug Test Event</TitoloEvento>
    <Autore></Autore>
    <Esecutore></Esecutore>
    <NazionalitaFilm></NazionalitaFilm>
    <NumOpereRappresentate>1</NumOpereRappresentate>
    <SistemaEmissione CFTitolare="DBGTST00A00A000A" CodiceSistema="${DEBUG_TEST_SYSTEM_CODE}">
      <Titoli>
        <CodiceOrdinePosto>A0</CodiceOrdinePosto>
        <Capienza>100</Capienza>
        <TotaleTipoTitolo>
          <TipoTitolo>IN</TipoTitolo>
          <TotaleTitoliLTA>0</TotaleTitoliLTA>
          <TotaleTitoliNoAccessoTradiz>0</TotaleTitoliNoAccessoTradiz>
          <TotaleTitoliNoAccessoDigitali>0</TotaleTitoliNoAccessoDigitali>
          <TotaleTitoliLTAAccessoTradiz>0</TotaleTitoliLTAAccessoTradiz>
          <TotaleTitoliLTAAccessoDigitali>0</TotaleTitoliLTAAccessoDigitali>
          <TotaleCorrispettiviLordi>0</TotaleCorrispettiviLordi>
          <TotaleDirittiPrevendita>0</TotaleDirittiPrevendita>
          <TotaleIVACorrispettivi>0</TotaleIVACorrispettivi>
          <TotaleIVADirittiPrevendita>0</TotaleIVADirittiPrevendita>
        </TotaleTipoTitolo>
        <TotaleTitoliAnnullati>
          <TipoTitolo>IN</TipoTitolo>
          <TotaleTitoliAnnull>0</TotaleTitoliAnnull>
          <TotaleCorrispettiviLordiAnnull>0</TotaleCorrispettiviLordiAnnull>
          <TotaleDirittiPrevenditaAnnull>0</TotaleDirittiPrevenditaAnnull>
          <TotaleIVACorrispettiviAnnull>0</TotaleIVACorrispettiviAnnull>
          <TotaleIVADirittiPrevenditaAnnull>0</TotaleIVADirittiPrevenditaAnnull>
        </TotaleTitoliAnnullati>
      </Titoli>
    </SistemaEmissione>
  </Evento>
</RiepilogoControlloAccessi>`;

      const emailResult = await sendSiaeTransmissionEmail({
        to: testDestination,
        companyName: 'DEBUG TEST',
        transmissionType: 'daily',
        periodDate: new Date(),
        ticketsCount: 0,
        totalAmount: '0.00',
        xmlContent: testXml,
        transmissionId: `DEBUG-${Date.now()}`,
        systemCode: DEBUG_TEST_SYSTEM_CODE, // FIX 2026-01-16: Usa codice test valido
        signWithSmime: true,
        requireSignature: true,
      });
      
      if (!emailResult.success) {
        throw new Error(emailResult.error || 'Invio email fallito - Firma S/MIME richiesta');
      }
      
      emailSent = true;
      console.log(`[SIAE-DEBUG] Test email sent successfully to: ${testDestination}`);
    } catch (err: any) {
      emailError = err.message;
      console.error('[SIAE-DEBUG] Email send failed:', err);
    }
    
    res.json({
      timestamp: new Date().toISOString(),
      environment: {
        SIAE_TEST_MODE: process.env.SIAE_TEST_MODE,
        SIAE_TEST_EMAIL: process.env.SIAE_TEST_EMAIL,
        SMTP_HOST: process.env.SMTP_HOST,
        SMTP_PORT: process.env.SMTP_PORT,
        SMTP_USER: process.env.SMTP_USER ? '***configured***' : 'NOT SET',
        SMTP_PASS: process.env.SMTP_PASS ? '***configured***' : 'NOT SET',
        SMTP_FROM: process.env.SMTP_FROM,
      },
      smtp: smtpStatus,
      emailTest: {
        destination: testDestination,
        sent: emailSent,
        error: emailError,
      },
      instructions: emailSent 
        ? `Email inviata a ${testDestination}. Controlla la casella email per verificare la ricezione.`
        : `Invio fallito: ${emailError}`,
    });
  } catch (error: any) {
    console.error('[SIAE-DEBUG] Debug endpoint error:', error);
    res.status(500).json({ 
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined 
    });
  }
});

// ==================== DEBUG ENDPOINT - Validate Fiscal Code / P.IVA ====================
router.get("/api/siae/debug/validate-fiscal", async (req: Request, res: Response) => {
  try {
    const { cf, piva, id } = req.query;
    const results: any = { timestamp: new Date().toISOString() };
    
    if (cf) {
      results.codiceFiscale = {
        input: cf,
        ...validateCodiceFiscale(cf as string)
      };
    }
    
    if (piva) {
      results.partitaIva = {
        input: piva,
        ...validatePartitaIva(piva as string)
      };
    }
    
    if (id) {
      results.fiscalId = {
        input: id,
        ...validateFiscalId(id as string)
      };
    }
    
    if (!cf && !piva && !id) {
      // Test con valori di esempio (codici fiscali reali per test)
      results.examples = {
        codiceFiscaleValido: {
          input: 'RSSMRA80A01H501U',
          ...validateCodiceFiscale('RSSMRA80A01H501U')
        },
        codiceFiscaleNonValido: {
          input: 'RSSMRA80A01H501X',
          ...validateCodiceFiscale('RSSMRA80A01H501X')
        },
        partitaIvaValida: {
          input: '12345678903',
          ...validatePartitaIva('12345678903')
        },
        partitaIvaNonValida: {
          input: '12345678901',
          ...validatePartitaIva('12345678901')
        }
      };
      results.usage = {
        message: "Usa i parametri query per testare i tuoi codici",
        examples: [
          "/api/siae/debug/validate-fiscal?cf=RSSMRA85M01H501U",
          "/api/siae/debug/validate-fiscal?piva=12345678903",
          "/api/siae/debug/validate-fiscal?id=RSSMRA85M01H501U"
        ]
      };
    }
    
    res.json(results);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== Email Audit Trail Endpoints ====================

router.get("/api/siae/companies/:companyId/email-audit", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const limit = parseInt(req.query.limit as string) || 100;
    const audits = await siaeStorage.getSiaeEmailAuditByCompany(req.params.companyId, limit);
    res.json(audits);
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to get email audit:', error);
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/transmissions/:transmissionId/email-audit", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const audits = await siaeStorage.getSiaeEmailAuditByTransmission(req.params.transmissionId);
    res.json(audits);
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to get email audit for transmission:', error);
    res.status(500).json({ message: error.message });
  }
});

// ==================== DEBUG ENDPOINT - Signature Audit Log ====================
router.get("/api/siae/debug/signature-audit", async (req: Request, res: Response) => {
  try {
    const { getSignatureAuditLog, SignatureErrorCode } = await import('./bridge-relay');
    
    const auditLog = getSignatureAuditLog();
    
    res.json({
      timestamp: new Date().toISOString(),
      totalEntries: auditLog.length,
      entries: auditLog,
      errorCodes: Object.values(SignatureErrorCode),
      description: "Log delle ultime 100 operazioni di firma digitale (XML e S/MIME)"
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== DEBUG ENDPOINT - DTD Validation ====================
router.post("/api/siae/debug/validate-xml", async (req: Request, res: Response) => {
  try {
    const { xml, reportType } = req.body;
    
    if (!xml) {
      return res.status(400).json({ error: "XML content is required" });
    }
    
    const type = reportType || 'giornaliero';
    if (!['giornaliero', 'mensile', 'rca'].includes(type)) {
      return res.status(400).json({ error: "reportType deve essere 'giornaliero', 'mensile' o 'rca'" });
    }
    
    const { validateSiaeXml } = await import('./siae-utils');
    const result = validateSiaeXml(xml, type as 'giornaliero' | 'mensile' | 'rca');
    
    res.json({
      timestamp: new Date().toISOString(),
      reportType: type,
      xmlLength: xml.length,
      ...result,
      description: "Validazione sintattica XML conforme DTD SIAE"
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== DEBUG ENDPOINT - Parse Log SIAE ====================
router.post("/api/siae/debug/parse-log", async (req: Request, res: Response) => {
  try {
    const { xml } = req.body;
    
    if (!xml) {
      return res.status(400).json({ error: "XML content is required" });
    }
    
    const { parseSiaeLogXml, analyzeSiaeLog } = await import('./siae-utils');
    const parseResult = parseSiaeLogXml(xml);
    const stats = analyzeSiaeLog(parseResult);
    
    res.json({
      timestamp: new Date().toISOString(),
      parseResult,
      stats,
      description: "Parser Log.xsi SIAE conforme a Log_v0040_20190627.dtd"
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== Parse SIAE Response File ====================
/**
 * Parsa un file di risposta SIAE (.txt) per estrarre codice errore, descrizione, protocollo
 * Usato per aggiornare automaticamente lo stato delle trasmissioni
 */
router.post("/api/siae/parse-response", requireAuth, async (req: Request, res: Response) => {
  try {
    const { content, transmissionId } = req.body;
    
    if (!content) {
      return res.status(400).json({ error: "Content del file di risposta richiesto" });
    }
    
    const result = parseSiaeResponseFile(content);
    
    // Se fornito un transmissionId, aggiorna la trasmissione con i dati estratti
    if (transmissionId && result.code) {
      try {
        const transmission = await siaeStorage.getSiaeTransmission(transmissionId);
        if (transmission) {
          await siaeStorage.updateSiaeTransmission(transmissionId, {
            status: result.success ? 'confirmed' : 'error',
            errorMessage: result.success ? null : `Errore ${result.code}: ${result.description}`,
            receiptProtocol: result.protocolNumber || null,
            receiptContent: content.substring(0, 2000),
          });
        }
      } catch (updateError: any) {
        console.error('[SIAE-ROUTES] Failed to update transmission:', updateError);
      }
    }
    
    res.json({
      timestamp: new Date().toISOString(),
      parsed: result,
      description: "Parsing file risposta SIAE completato"
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== SMART CARD EFFF Data Endpoint ====================
router.get("/api/siae/card/efff", requireAuth, async (req: Request, res: Response) => {
  try {
    const { requestCardEfffData, getCachedEfffData, isTestCardFromCache } = await import('./bridge-relay');
    const { isTestSmartCard, getSiaeEnvironment } = await import('./siae-utils');
    
    // Prima prova dalla cache
    const cached = getCachedEfffData();
    const forceRefresh = req.query.refresh === 'true';
    
    if (cached && !forceRefresh) {
      const isTest = isTestSmartCard(cached.systemId);
      const environment = getSiaeEnvironment(cached.systemId);
      
      return res.json({
        source: 'cache',
        data: cached,
        isTestCard: isTest,
        environment,
        siaeEmailTarget: isTest ? 'servertest2@batest.siae.it' : 'server@ba.siae.it'
      });
    }
    
    // Richiedi dalla Smart Card
    const efffData = await requestCardEfffData();
    const isTest = isTestSmartCard(efffData.systemId);
    const environment = getSiaeEnvironment(efffData.systemId);
    
    res.json({
      source: 'smartcard',
      data: efffData,
      isTestCard: isTest,
      environment,
      siaeEmailTarget: efffData.siaeEmail || (isTest ? 'servertest2@batest.siae.it' : 'server@ba.siae.it')
    });
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to read EFFF from card:', error);
    res.status(500).json({ 
      error: error.message,
      code: error.message.split(':')[0] || 'EFFF_ERROR'
    });
  }
});

// ==================== SIAE Environment Detection Endpoint ====================
router.get("/api/siae/environment", requireAuth, async (req: Request, res: Response) => {
  try {
    const { getCachedEfffData, isBridgeConnected, isCardReadyForSeals } = await import('./bridge-relay');
    const { isTestSmartCard, getSiaeEnvironment, getSiaeEmailForEnvironment } = await import('./siae-utils');
    
    const bridgeConnected = isBridgeConnected();
    const cardReady = isCardReadyForSeals();
    const cached = getCachedEfffData();
    
    let environment: 'test' | 'production' | 'unknown' = 'unknown';
    let siaeEmail: string | null = null;
    let systemId: string | null = null;
    
    if (cached?.systemId) {
      systemId = cached.systemId;
      environment = getSiaeEnvironment(systemId);
      siaeEmail = cached.siaeEmail || getSiaeEmailForEnvironment(systemId);
    } else if (process.env.SIAE_TEST_MODE === 'true') {
      environment = 'test';
      siaeEmail = 'servertest2@batest.siae.it';
    }
    
    res.json({
      environment,
      isTestMode: environment === 'test',
      bridgeConnected,
      cardReady: cardReady.ready,
      cardError: cardReady.error,
      systemId,
      siaeEmail,
      description: environment === 'test' 
        ? 'Ambiente di TEST - Smart Card con prefisso P nel systemId'
        : environment === 'production'
          ? 'Ambiente di PRODUZIONE - Smart Card ufficiale'
          : 'Ambiente non determinato - inserire Smart Card'
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== TAB.1-5 Reference Tables (Super Admin) ====================

// Event Genres (TAB.1)
router.get("/api/siae/event-genres", async (req: Request, res: Response) => {
  try {
    const genres = await siaeStorage.getSiaeEventGenres();
    res.json(genres);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/event-genres", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeEventGenreSchema.parse(req.body);
    const genre = await siaeStorage.createSiaeEventGenre(data);
    res.status(201).json(genre);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/event-genres/:code", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = patchEventGenreSchema.parse(req.body);
    const genre = await siaeStorage.updateSiaeEventGenre(req.params.code, data);
    if (!genre) {
      return res.status(404).json({ message: "Genere evento non trovato" });
    }
    res.json(genre);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// Imposta IVA standard su tutti i generi (normativa italiana)
router.post("/api/siae/event-genres/set-standard-vat", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    // Aliquote IVA standard secondo normativa italiana:
    // - Spettacolo (S): 10%
    // - Intrattenimento (I): 22%
    const genres = await siaeStorage.getSiaeEventGenres();
    let updated = 0;
    
    for (const genre of genres) {
      const standardVat = genre.taxType === 'S' ? 10 : 22;
      // Aggiorna solo se vatRate è null/undefined o diverso dallo standard
      if (genre.vatRate === null || genre.vatRate === undefined || Number(genre.vatRate) !== standardVat) {
        await siaeStorage.updateSiaeEventGenre(genre.code, { vatRate: String(standardVat) });
        updated++;
      }
    }
    
    res.json({ 
      message: `Aggiornati ${updated} generi con aliquote IVA standard`,
      updated,
      total: genres.length
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Sector Codes (TAB.2)
router.get("/api/siae/sector-codes", async (req: Request, res: Response) => {
  try {
    const sectors = await siaeStorage.getSiaeSectorCodes();
    res.json(sectors);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/sector-codes", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeSectorCodeSchema.parse(req.body);
    const sector = await siaeStorage.createSiaeSectorCode(data);
    res.status(201).json(sector);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/sector-codes/:code", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = patchSectorCodeSchema.parse(req.body);
    const sector = await siaeStorage.updateSiaeSectorCode(req.params.code, data);
    if (!sector) {
      return res.status(404).json({ message: "Codice settore non trovato" });
    }
    res.json(sector);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// Ticket Types (TAB.3)
router.get("/api/siae/ticket-types", async (req: Request, res: Response) => {
  try {
    const types = await siaeStorage.getSiaeTicketTypes();
    res.json(types);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/ticket-types", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeTicketTypeSchema.parse(req.body);
    const ticketType = await siaeStorage.createSiaeTicketType(data);
    res.status(201).json(ticketType);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/ticket-types/:code", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = patchTicketTypeSchema.parse(req.body);
    const ticketType = await siaeStorage.updateSiaeTicketType(req.params.code, data);
    if (!ticketType) {
      return res.status(404).json({ message: "Tipo biglietto non trovato" });
    }
    res.json(ticketType);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// Service Codes (TAB.4)
router.get("/api/siae/service-codes", async (req: Request, res: Response) => {
  try {
    const services = await siaeStorage.getSiaeServiceCodes();
    res.json(services);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/service-codes", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeServiceCodeSchema.parse(req.body);
    const service = await siaeStorage.createSiaeServiceCode(data);
    res.status(201).json(service);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/service-codes/:code", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = patchServiceCodeSchema.parse(req.body);
    const service = await siaeStorage.updateSiaeServiceCode(req.params.code, data);
    if (!service) {
      return res.status(404).json({ message: "Codice servizio non trovato" });
    }
    res.json(service);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// Cancellation Reasons (TAB.5)
router.get("/api/siae/cancellation-reasons", async (req: Request, res: Response) => {
  try {
    const reasons = await siaeStorage.getSiaeCancellationReasons();
    res.json(reasons);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/cancellation-reasons", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeCancellationReasonSchema.parse(req.body);
    const reason = await siaeStorage.createSiaeCancellationReason(data);
    res.status(201).json(reason);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/cancellation-reasons/:code", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = patchCancellationReasonSchema.parse(req.body);
    const reason = await siaeStorage.updateSiaeCancellationReason(req.params.code, data);
    if (!reason) {
      return res.status(404).json({ message: "Causale annullamento non trovata" });
    }
    res.json(reason);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// ==================== Export CSV Tabelle Codificate SIAE ====================

// Helper function to convert data to CSV format
function toCSV(data: any[], columns: { key: string; header: string }[]): string {
  const headers = columns.map(c => c.header).join(';');
  const rows = data.map(item => 
    columns.map(c => {
      const value = item[c.key];
      if (value === null || value === undefined) return '';
      const strValue = String(value);
      if (strValue.includes(';') || strValue.includes('"') || strValue.includes('\n')) {
        return `"${strValue.replace(/"/g, '""')}"`;
      }
      return strValue;
    }).join(';')
  );
  return [headers, ...rows].join('\n');
}

// Export Event Genres (TAB.1) as CSV
router.get("/api/siae/event-genres/export/csv", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const genres = await siaeStorage.getSiaeEventGenres();
    const csv = toCSV(genres, [
      { key: 'code', header: 'Codice' },
      { key: 'name', header: 'Nome' },
      { key: 'description', header: 'Descrizione' },
      { key: 'taxType', header: 'Tipo Imposta' },
      { key: 'vatRate', header: 'Aliquota IVA %' },
    ]);
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', 'attachment; filename="siae_generi_evento.csv"');
    res.send('\uFEFF' + csv);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Export Sector Codes (TAB.2) as CSV
router.get("/api/siae/sector-codes/export/csv", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const sectors = await siaeStorage.getSiaeSectorCodes();
    const csv = toCSV(sectors, [
      { key: 'code', header: 'Codice' },
      { key: 'name', header: 'Nome' },
      { key: 'description', header: 'Descrizione' },
    ]);
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', 'attachment; filename="siae_codici_settore.csv"');
    res.send('\uFEFF' + csv);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Export Ticket Types (TAB.3) as CSV
router.get("/api/siae/ticket-types/export/csv", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const types = await siaeStorage.getSiaeTicketTypes();
    const csv = toCSV(types, [
      { key: 'code', header: 'Codice' },
      { key: 'name', header: 'Nome' },
      { key: 'category', header: 'Categoria' },
      { key: 'description', header: 'Descrizione' },
    ]);
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', 'attachment; filename="siae_tipi_biglietto.csv"');
    res.send('\uFEFF' + csv);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Export Service Codes (TAB.4) as CSV
router.get("/api/siae/service-codes/export/csv", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const services = await siaeStorage.getSiaeServiceCodes();
    const csv = toCSV(services, [
      { key: 'code', header: 'Codice' },
      { key: 'name', header: 'Nome' },
      { key: 'description', header: 'Descrizione' },
    ]);
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', 'attachment; filename="siae_codici_servizio.csv"');
    res.send('\uFEFF' + csv);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Export Cancellation Reasons (TAB.5) as CSV
router.get("/api/siae/cancellation-reasons/export/csv", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const reasons = await siaeStorage.getSiaeCancellationReasons();
    const csv = toCSV(reasons, [
      { key: 'code', header: 'Codice' },
      { key: 'name', header: 'Nome' },
      { key: 'description', header: 'Descrizione' },
      { key: 'refundRequired', header: 'Rimborso Richiesto' },
    ]);
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', 'attachment; filename="siae_causali_annullamento.csv"');
    res.send('\uFEFF' + csv);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Export all reference tables as a single ZIP (optional future enhancement)
// For now, each table has its own export endpoint

// ==================== Activation Cards (Super Admin) ====================

router.get("/api/siae/activation-cards", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const cards = await siaeStorage.getSiaeActivationCards();
    res.json(cards);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/companies/:companyId/activation-cards", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const cards = await siaeStorage.getSiaeActivationCardsByCompany(req.params.companyId);
    res.json(cards);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/activation-cards/:id", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const card = await siaeStorage.getSiaeActivationCard(req.params.id);
    if (!card) {
      return res.status(404).json({ message: "Carta di attivazione non trovata" });
    }
    res.json(card);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/activation-cards", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeActivationCardSchema.parse(req.body);
    const card = await siaeStorage.createSiaeActivationCard(data);
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: card.companyId || user.companyId,
      userId: user.id,
      action: 'activation_card_created',
      entityType: 'activation_card',
      entityId: card.id,
      description: `Carta di attivazione creata: ${card.cardCode}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.status(201).json(card);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/activation-cards/:id", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const data = patchActivationCardSchema.parse(req.body);
    const card = await siaeStorage.updateSiaeActivationCard(req.params.id, data);
    if (!card) {
      return res.status(404).json({ message: "Carta di attivazione non trovata" });
    }
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: card.companyId || user.companyId,
      userId: user.id,
      action: 'activation_card_updated',
      entityType: 'activation_card',
      entityId: card.id,
      description: `Carta di attivazione aggiornata: ${card.cardCode}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json(card);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// Get usage statistics for activation card (which organizers used it)
router.get("/api/siae/activation-cards/:id/usage", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const card = await siaeStorage.getSiaeActivationCard(req.params.id);
    if (!card) {
      return res.status(404).json({ message: "Carta di attivazione non trovata" });
    }
    const stats = await siaeStorage.getActivationCardUsageStats(req.params.id);
    res.json({ card, ...stats });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Get activation card by serial (matching physical card) - always returns 200 with structured response
router.get("/api/siae/activation-cards/by-serial/:serial", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    console.log(`[ACTIVATION-CARDS] Looking up card by serial: ${req.params.serial}`);
    const card = await siaeStorage.getActivationCardBySerial(req.params.serial);
    console.log(`[ACTIVATION-CARDS] Card found:`, card ? card.id : 'null');
    if (!card) {
      // Return structured response even when card not found
      return res.json({ 
        card: null, 
        totalSeals: 0, 
        totalTickets: 0, 
        organizers: [],
        notFound: true
      });
    }
    console.log(`[ACTIVATION-CARDS] Getting usage stats for card: ${card.id}`);
    const stats = await siaeStorage.getActivationCardUsageStats(card.id);
    console.log(`[ACTIVATION-CARDS] Stats:`, stats);
    res.json({ card, ...stats, notFound: false });
  } catch (error: any) {
    console.error(`[ACTIVATION-CARDS] Error:`, error);
    res.status(500).json({ message: error.message });
  }
});

// ==================== Emission Channels (Gestore) ====================

router.get("/api/siae/companies/:companyId/emission-channels", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const channels = await siaeStorage.getSiaeEmissionChannelsByCompany(req.params.companyId);
    res.json(channels);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/emission-channels/:id", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const channel = await siaeStorage.getSiaeEmissionChannel(req.params.id);
    if (!channel) {
      return res.status(404).json({ message: "Canale di emissione non trovato" });
    }
    res.json(channel);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/emission-channels", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeEmissionChannelSchema.parse(req.body);
    const channel = await siaeStorage.createSiaeEmissionChannel(data);
    res.status(201).json(channel);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/emission-channels/:id", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const data = patchEmissionChannelSchema.parse(req.body);
    const channel = await siaeStorage.updateSiaeEmissionChannel(req.params.id, data);
    if (!channel) {
      return res.status(404).json({ message: "Canale di emissione non trovato" });
    }
    res.json(channel);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// ==================== System Configuration (Globale - Gestore) ====================

// Nuove route globali per configurazione unica
router.get("/api/siae/config", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const config = await siaeStorage.getGlobalSiaeSystemConfig();
    res.json(config || null);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.put("/api/siae/config", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeSystemConfigSchema.parse(req.body);
    const config = await siaeStorage.upsertGlobalSiaeSystemConfig(data);
    res.json(config);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// SIAE Environment Configuration endpoint
router.get("/api/siae/environment", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    res.json({
      testMode: SIAE_TEST_MODE,
      testEmail: SIAE_TEST_EMAIL,
      destinationEmail: getSiaeDestinationEmail(),
      environment: SIAE_TEST_MODE ? 'test' : 'production',
      environmentLabel: SIAE_TEST_MODE ? 'Ambiente di Test SIAE' : 'Ambiente di Produzione SIAE',
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Route legacy per compatibilità (reindirizza alla config globale)
router.get("/api/siae/companies/:companyId/config", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const config = await siaeStorage.getGlobalSiaeSystemConfig();
    res.json(config || null);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.put("/api/siae/companies/:companyId/config", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeSystemConfigSchema.parse(req.body);
    const config = await siaeStorage.upsertGlobalSiaeSystemConfig(data);
    res.json(config);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// ==================== Customers (Public - for registration) ====================

// Endpoint per ottenere i clienti filtrati per evento e company del gestore
router.get("/api/siae/customers", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { eventId } = req.query;
    
    // Super admin può vedere tutti i clienti
    if (user.role === 'super_admin') {
      const customers = await siaeStorage.getSiaeCustomers();
      return res.json(customers);
    }
    
    // Gestore deve avere una companyId
    if (!user.companyId) {
      return res.status(403).json({ message: "Nessuna azienda associata" });
    }
    
    // Se viene fornito un eventId, restituisci solo i clienti che hanno acquistato biglietti per quell'evento
    if (eventId && typeof eventId === 'string') {
      // Verifica che l'evento appartenga alla company del gestore
      const [ticketedEvent] = await db
        .select()
        .from(siaeTicketedEvents)
        .where(and(
          eq(siaeTicketedEvents.id, eventId),
          eq(siaeTicketedEvents.companyId, user.companyId)
        ));
      
      if (!ticketedEvent) {
        return res.status(403).json({ message: "Evento non trovato o non autorizzato" });
      }
      
      // Ottieni i clienti che hanno acquistato biglietti per questo evento
      const customersWithTickets = await db
        .selectDistinct({
          id: siaeCustomers.id,
          uniqueCode: siaeCustomers.uniqueCode,
          firstName: siaeCustomers.firstName,
          lastName: siaeCustomers.lastName,
          email: siaeCustomers.email,
          phone: siaeCustomers.phone,
          phoneVerified: siaeCustomers.phoneVerified,
          emailVerified: siaeCustomers.emailVerified,
          isActive: siaeCustomers.isActive,
          blockedUntil: siaeCustomers.blockedUntil,
          blockReason: siaeCustomers.blockReason,
          birthDate: siaeCustomers.birthDate,
          birthPlace: siaeCustomers.birthPlace,
          registrationCompleted: siaeCustomers.registrationCompleted,
          createdAt: siaeCustomers.createdAt,
          updatedAt: siaeCustomers.updatedAt,
        })
        .from(siaeCustomers)
        .innerJoin(siaeTickets, eq(siaeTickets.customerId, siaeCustomers.id))
        .where(eq(siaeTickets.ticketedEventId, eventId))
        .orderBy(desc(siaeCustomers.createdAt));
      
      return res.json(customersWithTickets);
    }
    
    // Senza eventId, restituisci tutti i clienti che hanno acquistato biglietti per eventi della company
    const customersForCompany = await db
      .selectDistinct({
        id: siaeCustomers.id,
        uniqueCode: siaeCustomers.uniqueCode,
        firstName: siaeCustomers.firstName,
        lastName: siaeCustomers.lastName,
        email: siaeCustomers.email,
        phone: siaeCustomers.phone,
        phoneVerified: siaeCustomers.phoneVerified,
        emailVerified: siaeCustomers.emailVerified,
        isActive: siaeCustomers.isActive,
        blockedUntil: siaeCustomers.blockedUntil,
        blockReason: siaeCustomers.blockReason,
        birthDate: siaeCustomers.birthDate,
        birthPlace: siaeCustomers.birthPlace,
        registrationCompleted: siaeCustomers.registrationCompleted,
        createdAt: siaeCustomers.createdAt,
        updatedAt: siaeCustomers.updatedAt,
      })
      .from(siaeCustomers)
      .innerJoin(siaeTickets, eq(siaeTickets.customerId, siaeCustomers.id))
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
      .where(eq(siaeTicketedEvents.companyId, user.companyId))
      .orderBy(desc(siaeCustomers.createdAt));
    
    res.json(customersForCompany);
  } catch (error: any) {
    console.error("[SIAE] Error fetching customers:", error);
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/customers/:id", requireAuth, async (req: Request, res: Response) => {
  try {
    const customer = await siaeStorage.getSiaeCustomer(req.params.id);
    if (!customer) {
      return res.status(404).json({ message: "Cliente non trovato" });
    }
    res.json(customer);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/customers", async (req: Request, res: Response) => {
  try {
    // Check if customer registration is enabled (separate from venue registration)
    const customerRegSetting = await storage.getSystemSetting('customer_registration_enabled');
    if (customerRegSetting && customerRegSetting.value === 'false') {
      return res.status(403).json({ message: "Registrazione clienti temporaneamente disabilitata" });
    }
    
    const data = insertSiaeCustomerSchema.parse(req.body);
    const customer = await siaeStorage.createSiaeCustomer(data);
    
    await siaeStorage.createAuditLog({
      companyId: '', // siaeCustomers doesn't have companyId
      userId: undefined,
      action: 'customer_created',
      entityType: 'customer',
      entityId: customer.id,
      description: `Cliente registrato: ${customer.firstName} ${customer.lastName}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.status(201).json(customer);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/customers/:id", requireAuth, async (req: Request, res: Response) => {
  try {
    const data = patchCustomerSchema.parse(req.body);
    const customer = await siaeStorage.updateSiaeCustomer(req.params.id, data);
    if (!customer) {
      return res.status(404).json({ message: "Cliente non trovato" });
    }
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: user.companyId, // siaeCustomers doesn't have companyId
      userId: user.id,
      action: 'customer_updated',
      entityType: 'customer',
      entityId: customer.id,
      description: `Cliente aggiornato: ${customer.firstName} ${customer.lastName}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json(customer);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// Verifica manuale cliente (admin bypass OTP)
router.post("/api/siae/customers/:id/verify-manual", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const customer = await siaeStorage.getSiaeCustomer(req.params.id);
    if (!customer) {
      return res.status(404).json({ message: "Cliente non trovato" });
    }
    
    // Aggiorna il cliente come verificato
    const updated = await siaeStorage.updateSiaeCustomer(req.params.id, {
      phoneVerified: true,
      isActive: true,
    });
    
    // Pulisci tutti gli OTP pendenti per questo telefono
    if (customer.phone) {
      await siaeStorage.markSiaeOtpVerifiedByPhone(customer.phone);
    }
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: user.companyId, // siaeCustomers doesn't have companyId
      userId: user.id,
      action: 'customer_verified_manual',
      entityType: 'customer',
      entityId: customer.id,
      description: `Cliente verificato manualmente: ${customer.firstName} ${customer.lastName}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json({ 
      message: "Cliente verificato manualmente con successo",
      customer: updated 
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Elimina cliente
router.delete("/api/siae/customers/:id", requireAuth, requireGestore, async (req: Request, res: Response) => {
  console.log("[SIAE] Delete customer request:", req.params.id, "force:", req.query.force);
  try {
    const customer = await siaeStorage.getSiaeCustomer(req.params.id);
    if (!customer) {
      console.log("[SIAE] Customer not found:", req.params.id);
      return res.status(404).json({ message: "Cliente non trovato" });
    }
    
    const forceDelete = req.query.force === 'true';
    console.log("[SIAE] Force delete:", forceDelete);
    
    // Verifica se ci sono record collegati
    const [hasTickets] = await db.select({ count: sql<number>`count(*)` })
      .from(siaeTickets)
      .where(eq(siaeTickets.customerId, req.params.id));
    
    const [hasTransactions] = await db.select({ count: sql<number>`count(*)` })
      .from(siaeTransactions)
      .where(eq(siaeTransactions.customerId, req.params.id));
    
    const [hasSubscriptions] = await db.select({ count: sql<number>`count(*)` })
      .from(siaeSubscriptions)
      .where(eq(siaeSubscriptions.customerId, req.params.id));
    
    const ticketCount = Number(hasTickets?.count) || 0;
    const transactionCount = Number(hasTransactions?.count) || 0;
    const subscriptionCount = Number(hasSubscriptions?.count) || 0;
    
    if ((ticketCount > 0 || transactionCount > 0 || subscriptionCount > 0) && !forceDelete) {
      return res.status(409).json({ 
        message: `Questo cliente ha ${ticketCount} biglietti, ${transactionCount} transazioni e ${subscriptionCount} abbonamenti. Usa l'opzione "Elimina comunque" per procedere.`,
        canForceDelete: true,
        details: { ticketCount, transactionCount, subscriptionCount }
      });
    }
    
    // Se force delete, prima rimuovi tutti i record associati
    if (forceDelete) {
      console.log("[SIAE] Force delete: cleaning up all associated records");
      
      // Anonimizza i biglietti (non li eliminiamo per integrità fiscale)
      await db.update(siaeTickets)
        .set({ customerId: null })
        .where(eq(siaeTickets.customerId, req.params.id));
      
      // Elimina le transazioni (customerId è notNull)
      await db.delete(siaeTransactions)
        .where(eq(siaeTransactions.customerId, req.params.id));
      
      // Elimina abbonamenti (customerId è notNull)
      await db.delete(siaeSubscriptions)
        .where(eq(siaeSubscriptions.customerId, req.params.id));
      
      // Elimina tentativi OTP
      await db.delete(siaeOtpAttempts)
        .where(eq(siaeOtpAttempts.customerId, req.params.id));
      
      // Elimina resales dove è seller (sellerId è notNull)
      await db.delete(siaeResales)
        .where(eq(siaeResales.sellerId, req.params.id));
      // Anonimizza resales dove è buyer (buyerId è nullable)
      await db.update(siaeResales)
        .set({ buyerId: null })
        .where(eq(siaeResales.buyerId, req.params.id));
      
      // Elimina cart items
      await db.delete(publicCartItems)
        .where(eq(publicCartItems.customerId, req.params.id));
      
      // Elimina checkout sessions
      await db.delete(publicCheckoutSessions)
        .where(eq(publicCheckoutSessions.customerId, req.params.id));
      
      // Elimina customer sessions
      await db.delete(publicCustomerSessions)
        .where(eq(publicCustomerSessions.customerId, req.params.id));
      
      // Anonimizza table bookings
      await db.update(tableBookings)
        .set({ customerId: null })
        .where(eq(tableBookings.customerId, req.params.id));
      
      // Anonimizza guest list entries
      await db.update(guestListEntries)
        .set({ customerId: null })
        .where(eq(guestListEntries.customerId, req.params.id));
      
      console.log("[SIAE] Force delete: all associated records cleaned up");
    }
    
    console.log("[SIAE] Proceeding with delete for customer:", customer.id);
    const deleted = await siaeStorage.deleteSiaeCustomer(req.params.id);
    console.log("[SIAE] Delete result:", deleted);
    if (!deleted) {
      return res.status(500).json({ message: "Errore durante l'eliminazione" });
    }
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: user.companyId, // siaeCustomers doesn't have companyId
      userId: user.id,
      action: 'customer_deleted',
      entityType: 'customer',
      entityId: req.params.id,
      description: `Cliente eliminato: ${customer.firstName} ${customer.lastName}${forceDelete ? ' (forzato)' : ''}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    console.log("[SIAE] Customer deleted successfully:", req.params.id);
    res.json({ message: "Cliente eliminato con successo" });
  } catch (error: any) {
    console.error("[SIAE] Delete customer error:", error);
    // Gestisci errori di vincolo FK
    if (error.code === '23503') { // PostgreSQL foreign key violation
      return res.status(409).json({ 
        message: "Impossibile eliminare il cliente: ha record associati nel sistema.",
        canForceDelete: true
      });
    }
    res.status(500).json({ message: error.message });
  }
});

// ==================== OTP Verification (Public) ====================

// OTP request validation schema
const otpSendSchema = z.object({
  phone: z.string().min(8).max(20).regex(/^\+?[0-9]+$/, "Formato telefono non valido"),
  purpose: z.enum(['registration', 'login', 'verification']).default('registration'),
});

const otpVerifySchema = z.object({
  phone: z.string().min(8).max(20),
  otpCode: z.string().length(6).regex(/^[0-9]+$/, "OTP deve essere 6 cifre"),
});

// Simple in-memory rate limiter for OTP requests
const otpRateLimiter = new Map<string, { count: number; resetAt: number }>();
const OTP_RATE_LIMIT = 3; // max requests per window
const OTP_RATE_WINDOW = 60 * 1000; // 1 minute window

function checkOtpRateLimit(phone: string): boolean {
  const now = Date.now();
  const entry = otpRateLimiter.get(phone);
  
  if (!entry || now > entry.resetAt) {
    otpRateLimiter.set(phone, { count: 1, resetAt: now + OTP_RATE_WINDOW });
    return true;
  }
  
  if (entry.count >= OTP_RATE_LIMIT) {
    return false;
  }
  
  entry.count++;
  return true;
}

// Generate cryptographically stronger OTP using crypto
function generateSecureOtp(): string {
  const array = new Uint32Array(1);
  crypto.getRandomValues(array);
  return String(100000 + (array[0] % 900000));
}

router.post("/api/siae/otp/send", async (req: Request, res: Response) => {
  try {
    const data = otpSendSchema.parse(req.body);
    
    // Check rate limit
    if (!checkOtpRateLimit(data.phone)) {
      return res.status(429).json({ message: "Troppi tentativi. Riprova tra un minuto." });
    }
    
    // Use MSG91 SMS Flow if configured, otherwise fallback to local OTP generation
    if (isMSG91Configured()) {
      console.log(`[SIAE OTP] Using MSG91 SMS Flow for ${data.phone}`);
      const result = await sendMSG91OTP(data.phone, 10); // 10 minutes expiry
      
      if (!result.success) {
        console.error(`[SIAE OTP] MSG91 failed: ${result.message}`);
        return res.status(500).json({ message: result.message });
      }
      
      // Store OTP code in DB (generated locally, sent via MSG91 SMS)
      await siaeStorage.createSiaeOtpAttempt({
        phone: data.phone,
        otpCode: result.otpCode!, // Store the actual OTP code for local verification
        purpose: data.purpose,
        expiresAt: new Date(Date.now() + 10 * 60 * 1000),
      });
      
      res.json({ message: "OTP inviato con successo", expiresIn: 600, provider: "msg91" });
    } else {
      // Fallback: Generate local OTP (for testing/development)
      const otpCode = generateSecureOtp();
      const expiresAt = new Date(Date.now() + 5 * 60 * 1000);
      
      await siaeStorage.createSiaeOtpAttempt({
        phone: data.phone,
        otpCode,
        purpose: data.purpose,
        expiresAt,
      });
      
      console.log(`[SIAE OTP] Local mode - Phone: ${data.phone}, OTP: ${otpCode}`);
      res.json({ message: "OTP inviato con successo", expiresIn: 300, provider: "local" });
    }
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ message: "Dati non validi", errors: error.errors });
    }
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/otp/verify", async (req: Request, res: Response) => {
  try {
    const data = otpVerifySchema.parse(req.body);
    
    // Local OTP verification (code is stored in DB, sent via MSG91 SMS Flow)
    console.log(`[SIAE OTP] Verifying OTP for ${data.phone}`);
    
    // Fallback: Local OTP verification
    const attempt = await siaeStorage.getSiaeOtpAttempt(data.phone, data.otpCode);
    if (!attempt) {
      return res.status(400).json({ message: "OTP non valido" });
    }
    
    // Explicit check: must be in 'pending' status (not already verified or failed)
    if (attempt.status !== 'pending') {
      return res.status(400).json({ 
        message: attempt.status === 'verified' ? "OTP già utilizzato" : "OTP non valido" 
      });
    }
    
    // Explicit check: must not be expired
    if (!attempt.expiresAt || new Date() > attempt.expiresAt) {
      return res.status(400).json({ message: "OTP scaduto. Richiedi un nuovo codice." });
    }
    
    // All checks passed - mark as verified
    await siaeStorage.markSiaeOtpVerified(attempt.id);
    
    // Check if customer exists with this phone
    let customer = await siaeStorage.getSiaeCustomerByPhone(data.phone);
    
    res.json({ 
      verified: true, 
      customerId: customer?.id,
      isNewCustomer: !customer,
      provider: "local"
    });
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ message: "Dati non validi", errors: error.errors });
    }
    res.status(500).json({ message: error.message });
  }
});

// Resend OTP endpoint
router.post("/api/siae/otp/resend", async (req: Request, res: Response) => {
  try {
    const { phone, retryType = 'text' } = req.body;
    
    if (!phone) {
      return res.status(400).json({ message: "Numero di telefono richiesto" });
    }
    
    // Check rate limit
    if (!checkOtpRateLimit(phone)) {
      return res.status(429).json({ message: "Troppi tentativi. Riprova tra un minuto." });
    }
    
    if (isMSG91Configured()) {
      console.log(`[SIAE OTP] Resending via MSG91 SMS Flow to ${phone}`);
      const result = await resendMSG91OTP(phone, retryType as 'text' | 'voice');
      
      if (!result.success) {
        console.error(`[SIAE OTP] MSG91 resend failed: ${result.message}`);
        return res.status(500).json({ message: result.message });
      }
      
      // Store the new OTP code in DB
      await siaeStorage.createSiaeOtpAttempt({
        phone: phone,
        otpCode: result.otpCode!,
        purpose: "registration",
        expiresAt: new Date(Date.now() + 10 * 60 * 1000),
      });
      
      res.json({ message: "OTP reinviato con successo", provider: "msg91" });
    } else {
      // For local mode, generate a new OTP instead
      return res.status(400).json({ message: "Reinvio disponibile solo con MSG91 configurato" });
    }
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Ticketed Events (Organizer) ====================

// Admin endpoint: Get all ticketed events across all companies (Super Admin only)
router.get("/api/siae/admin/ticketed-events", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const events = await siaeStorage.getAllSiaeTicketedEventsAdmin();
    res.json(events);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Admin endpoint: Get all transactions across all companies with filters (Super Admin only)
router.get("/api/siae/admin/transactions", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const { companyId, eventId, status, paymentMethod, page = '1', limit = '50', dateFrom, dateTo, search } = req.query;
    
    // Build query with filters
    let query = db
      .select({
        transaction: siaeTransactions,
        ticketedEvent: {
          id: siaeTicketedEvents.id,
          eventId: siaeTicketedEvents.eventId,
          companyId: siaeTicketedEvents.companyId,
        },
        event: {
          id: events.id,
          name: events.name,
          startDatetime: events.startDatetime,
        },
        company: {
          id: companies.id,
          name: companies.name,
        },
      })
      .from(siaeTransactions)
      .innerJoin(siaeTicketedEvents, eq(siaeTransactions.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id))
      .innerJoin(companies, eq(siaeTicketedEvents.companyId, companies.id));
    
    // Apply filters
    const conditions: any[] = [];
    if (companyId && typeof companyId === 'string') {
      conditions.push(eq(siaeTicketedEvents.companyId, companyId));
    }
    if (eventId && typeof eventId === 'string') {
      conditions.push(eq(siaeTicketedEvents.eventId, eventId));
    }
    if (status && typeof status === 'string') {
      conditions.push(eq(siaeTransactions.status, status));
    }
    if (paymentMethod && typeof paymentMethod === 'string') {
      conditions.push(eq(siaeTransactions.paymentMethod, paymentMethod));
    }
    if (dateFrom && typeof dateFrom === 'string') {
      conditions.push(gte(siaeTransactions.createdAt, new Date(dateFrom)));
    }
    if (dateTo && typeof dateTo === 'string') {
      conditions.push(lte(siaeTransactions.createdAt, new Date(dateTo)));
    }
    if (search && typeof search === 'string' && search.trim()) {
      const searchTerm = `%${search.trim().toLowerCase()}%`;
      conditions.push(or(
        sql`LOWER(${siaeTransactions.transactionCode}) LIKE ${searchTerm}`,
        sql`LOWER(${siaeTransactions.customerEmail}) LIKE ${searchTerm}`,
        sql`LOWER(${siaeTransactions.customerUniqueCode}) LIKE ${searchTerm}`
      ));
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions)) as any;
    }
    
    // Add ordering and pagination
    const pageNum = parseInt(page as string) || 1;
    const limitNum = Math.min(parseInt(limit as string) || 50, 100);
    const offset = (pageNum - 1) * limitNum;
    
    const results = await query
      .orderBy(desc(siaeTransactions.createdAt))
      .limit(limitNum)
      .offset(offset);
    
    // Get total count for pagination (apply same filters)
    let countQuery = db
      .select({ count: count() })
      .from(siaeTransactions)
      .innerJoin(siaeTicketedEvents, eq(siaeTransactions.ticketedEventId, siaeTicketedEvents.id));
    
    if (conditions.length > 0) {
      countQuery = countQuery.where(and(...conditions)) as any;
    }
    
    const countResult = await countQuery;
    const total = countResult[0]?.count || 0;
    
    // Calculate totals for filtered results
    let totalsQuery = db
      .select({
        totalAmount: sql<string>`COALESCE(SUM(${siaeTransactions.totalAmount}), 0)`,
        ticketsCount: sql<number>`COALESCE(SUM(${siaeTransactions.ticketsCount}), 0)`,
      })
      .from(siaeTransactions)
      .innerJoin(siaeTicketedEvents, eq(siaeTransactions.ticketedEventId, siaeTicketedEvents.id))
      .where(eq(siaeTransactions.status, 'completed'));
    
    if (conditions.length > 0) {
      // Add completed status to existing conditions for totals
      const totalsConditions = [...conditions, eq(siaeTransactions.status, 'completed')];
      totalsQuery = db
        .select({
          totalAmount: sql<string>`COALESCE(SUM(${siaeTransactions.totalAmount}), 0)`,
          ticketsCount: sql<number>`COALESCE(SUM(${siaeTransactions.ticketsCount}), 0)`,
        })
        .from(siaeTransactions)
        .innerJoin(siaeTicketedEvents, eq(siaeTransactions.ticketedEventId, siaeTicketedEvents.id))
        .where(and(...totalsConditions)) as any;
    }
    
    const totalsResult = await totalsQuery;
    
    res.json({
      transactions: results.map(r => ({
        ...r.transaction,
        ticketedEvent: r.ticketedEvent,
        event: r.event,
        company: r.company,
      })),
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum),
      },
      totals: {
        revenue: totalsResult[0]?.totalAmount || '0',
        tickets: totalsResult[0]?.ticketsCount || 0,
      },
    });
  } catch (error: any) {
    console.error('[ADMIN TRANSACTIONS] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

// Get companies and events for transaction filters
router.get("/api/siae/admin/transactions/filters", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    // Get all companies with transactions
    const companiesWithTransactions = await db
      .selectDistinct({
        id: companies.id,
        name: companies.name,
      })
      .from(siaeTransactions)
      .innerJoin(siaeTicketedEvents, eq(siaeTransactions.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(companies, eq(siaeTicketedEvents.companyId, companies.id))
      .orderBy(companies.name);
    
    // Get all events with transactions
    const eventsWithTransactions = await db
      .selectDistinct({
        id: events.id,
        name: events.name,
        companyId: siaeTicketedEvents.companyId,
      })
      .from(siaeTransactions)
      .innerJoin(siaeTicketedEvents, eq(siaeTransactions.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id))
      .orderBy(events.name);
    
    res.json({
      companies: companiesWithTransactions,
      events: eventsWithTransactions,
      statuses: ['completed', 'pending', 'failed', 'refunded'],
      paymentMethods: ['card', 'cash', 'bank_transfer', 'paypal'],
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Get ticketing info by event ID (used by event-hub)
router.get("/api/siae/events/:eventId/ticketing", requireAuth, async (req: Request, res: Response) => {
  try {
    const ticketedEvent = await siaeStorage.getSiaeTicketedEventByEventId(req.params.eventId);
    if (!ticketedEvent) {
      return res.json(null); // No ticketing configured for this event
    }
    // Also get sectors for complete ticketing info
    const sectors = await siaeStorage.getSiaeEventSectors(ticketedEvent.id);
    res.json({ ...ticketedEvent, sectors });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/companies/:companyId/ticketed-events", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const events = await siaeStorage.getSiaeTicketedEventsByCompany(req.params.companyId);
    res.json(events);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Get ticketed events for current user (gestore, cassiere, super_admin)
router.get("/api/siae/ticketed-events", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    
    // Super admin sees all events
    if (user.role === 'super_admin') {
      const events = await siaeStorage.getAllSiaeTicketedEventsAdmin();
      return res.json(events);
    }
    
    // For gestore, organizer, cassiere - return events for their company
    if (!user.companyId) {
      return res.json([]);
    }
    
    const events = await siaeStorage.getSiaeTicketedEventsByCompany(user.companyId);
    res.json(events);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/ticketed-events/:id", requireAuth, async (req: Request, res: Response) => {
  try {
    const event = await siaeStorage.getSiaeTicketedEvent(req.params.id);
    if (!event) {
      return res.status(404).json({ message: "Evento biglietteria non trovato" });
    }
    res.json(event);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== SIAE Event Approval Routes (Super Admin) ====================

// Get all pending approval events (super_admin only)
router.get("/api/siae/admin/pending-approvals", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const pendingEvents = await db
      .select({
        id: siaeTicketedEvents.id,
        eventId: siaeTicketedEvents.eventId,
        companyId: siaeTicketedEvents.companyId,
        genreCode: siaeTicketedEvents.genreCode,
        totalCapacity: siaeTicketedEvents.totalCapacity,
        ticketingStatus: siaeTicketedEvents.ticketingStatus,
        approvalStatus: siaeTicketedEvents.approvalStatus,
        createdAt: siaeTicketedEvents.createdAt,
        eventName: events.name,
        eventDate: events.startDatetime,
        companyName: companies.name,
      })
      .from(siaeTicketedEvents)
      .leftJoin(events, eq(siaeTicketedEvents.eventId, events.id))
      .leftJoin(companies, eq(siaeTicketedEvents.companyId, companies.id))
      .where(or(
        eq(siaeTicketedEvents.approvalStatus, 'pending'),
        isNull(siaeTicketedEvents.approvalStatus)
      ))
      .orderBy(desc(siaeTicketedEvents.createdAt));
    
    res.json(pendingEvents);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Approve a SIAE event (super_admin only)
router.post("/api/siae/admin/approve/:id", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const eventId = req.params.id;
    
    // Check current event state
    const [existing] = await db
      .select()
      .from(siaeTicketedEvents)
      .where(eq(siaeTicketedEvents.id, eventId));
    
    if (!existing) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    if (existing.approvalStatus === 'approved') {
      return res.status(400).json({ message: "Evento già approvato" });
    }
    
    const [updated] = await db
      .update(siaeTicketedEvents)
      .set({
        approvalStatus: 'approved',
        approvedBy: user.id,
        approvedAt: new Date(),
        rejectedReason: null,
        updatedAt: new Date(),
      })
      .where(and(
        eq(siaeTicketedEvents.id, eventId),
        or(
          eq(siaeTicketedEvents.approvalStatus, 'pending'),
          isNull(siaeTicketedEvents.approvalStatus)
        )
      ))
      .returning();
    
    if (!updated) {
      return res.status(400).json({ message: "Impossibile approvare l'evento. Stato non valido." });
    }
    
    res.json({ message: "Evento approvato con successo", event: updated });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Reject a SIAE event (super_admin only)
router.post("/api/siae/admin/reject/:id", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const eventId = req.params.id;
    const { reason } = req.body;
    
    if (!reason || reason.trim() === '') {
      return res.status(400).json({ message: "È richiesta una motivazione per il rifiuto" });
    }
    
    // Check current event state
    const [existing] = await db
      .select()
      .from(siaeTicketedEvents)
      .where(eq(siaeTicketedEvents.id, eventId));
    
    if (!existing) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    if (existing.approvalStatus === 'rejected') {
      return res.status(400).json({ message: "Evento già rifiutato" });
    }
    
    if (existing.approvalStatus === 'approved') {
      return res.status(400).json({ message: "Non è possibile rifiutare un evento già approvato" });
    }
    
    const [updated] = await db
      .update(siaeTicketedEvents)
      .set({
        approvalStatus: 'rejected',
        approvedBy: user.id,
        approvedAt: new Date(),
        rejectedReason: reason.trim(),
        updatedAt: new Date(),
      })
      .where(and(
        eq(siaeTicketedEvents.id, eventId),
        or(
          eq(siaeTicketedEvents.approvalStatus, 'pending'),
          isNull(siaeTicketedEvents.approvalStatus)
        )
      ))
      .returning();
    
    if (!updated) {
      return res.status(400).json({ message: "Impossibile rifiutare l'evento. Stato non valido." });
    }
    
    res.json({ message: "Evento rifiutato", event: updated });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Get user's skipSiaeApproval status
router.get("/api/siae/admin/users/:userId/approval-settings", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const [features] = await db
      .select()
      .from(userFeatures)
      .where(eq(userFeatures.userId, req.params.userId));
    
    res.json({ skipSiaeApproval: features?.skipSiaeApproval || false });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Update user's skipSiaeApproval status
router.patch("/api/siae/admin/users/:userId/approval-settings", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const { skipSiaeApproval } = req.body;
    const userId = req.params.userId;
    
    // Check if user features exist
    const [existing] = await db
      .select()
      .from(userFeatures)
      .where(eq(userFeatures.userId, userId));
    
    if (existing) {
      await db
        .update(userFeatures)
        .set({ skipSiaeApproval: !!skipSiaeApproval, updatedAt: new Date() })
        .where(eq(userFeatures.userId, userId));
    } else {
      await db.insert(userFeatures).values({
        userId,
        skipSiaeApproval: !!skipSiaeApproval,
      });
    }
    
    res.json({ message: "Impostazioni aggiornate", skipSiaeApproval: !!skipSiaeApproval });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/ticketed-events", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeTicketedEventSchema.parse(req.body);
    const user = req.user as any;
    
    // Check if user has skipSiaeApproval flag
    let approvalStatus = 'pending';
    let approvedBy = null;
    let approvedAt = null;
    
    // Super admin events are auto-approved
    if (user.role === 'super_admin') {
      approvalStatus = 'approved';
      approvedBy = user.id;
      approvedAt = new Date();
    } else {
      // Check user features for skipSiaeApproval
      const [features] = await db
        .select()
        .from(userFeatures)
        .where(eq(userFeatures.userId, user.id));
      
      if (features?.skipSiaeApproval) {
        approvalStatus = 'approved';
        approvedBy = user.id;
        approvedAt = new Date();
      }
    }
    
    const event = await siaeStorage.createSiaeTicketedEvent({
      ...data,
      approvalStatus,
      approvedBy,
      approvedAt,
    });
    
    await siaeStorage.createAuditLog({
      companyId: event.companyId || user.companyId,
      userId: user.id,
      action: 'ticketed_event_created',
      entityType: 'ticketed_event',
      entityId: event.id,
      description: `Evento biglietteria creato (eventId: ${event.eventId})`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.status(201).json(event);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/ticketed-events/:id", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    // Strip readonly/computed fields that frontend might send but aren't in the schema
    // Also strip approval-related fields - these can only be changed by super_admin via dedicated routes
    const { 
      id: _id, 
      companyId: _companyId, 
      createdAt: _createdAt, 
      updatedAt: _updatedAt, 
      sectors: _sectors, 
      event: _event,
      approvalStatus: _approvalStatus,
      approvedBy: _approvedBy,
      approvedAt: _approvedAt,
      rejectedReason: _rejectedReason,
      ...patchData 
    } = req.body;
    const data = patchTicketedEventSchema.parse(patchData);
    
    // Check if trying to activate an unapproved event
    if (data.ticketingStatus === 'active') {
      const [existingEvent] = await db
        .select()
        .from(siaeTicketedEvents)
        .where(eq(siaeTicketedEvents.id, req.params.id));
      
      if (existingEvent && existingEvent.approvalStatus !== 'approved') {
        return res.status(400).json({ 
          message: "Non è possibile attivare un evento non ancora approvato. L'evento deve essere prima approvato dall'amministratore." 
        });
      }
    }
    
    const event = await siaeStorage.updateSiaeTicketedEvent(req.params.id, data);
    if (!event) {
      return res.status(404).json({ message: "Evento biglietteria non trovato" });
    }
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: event.companyId || user.companyId,
      userId: user.id,
      action: 'ticketed_event_updated',
      entityType: 'ticketed_event',
      entityId: event.id,
      description: `Evento biglietteria aggiornato (eventId: ${event.eventId})`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json(event);
  } catch (error: any) {
    console.log("[SIAE PATCH] Error:", error.message);
    res.status(400).json({ message: error.message });
  }
});

// Update event public info (image and description)
router.patch("/api/siae/ticketed-events/:id/public-info", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const { description, imageUrl } = req.body;
    
    // Get the ticketed event to find the associated event
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(req.params.id);
    if (!ticketedEvent) {
      return res.status(404).json({ message: "Evento biglietteria non trovato" });
    }
    
    // Update the base event with description and imageUrl
    const [updated] = await db
      .update(events)
      .set({
        description: description ?? null,
        imageUrl: imageUrl ?? null,
        updatedAt: new Date(),
      })
      .where(eq(events.id, ticketedEvent.eventId))
      .returning();
    
    if (!updated) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    res.json({ 
      message: "Informazioni pubbliche aggiornate",
      description: updated.description,
      imageUrl: updated.imageUrl
    });
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// Get event public info
router.get("/api/siae/ticketed-events/:id/public-info", requireAuth, async (req: Request, res: Response) => {
  try {
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(req.params.id);
    if (!ticketedEvent) {
      return res.status(404).json({ message: "Evento biglietteria non trovato" });
    }
    
    const [event] = await db
      .select({ description: events.description, imageUrl: events.imageUrl })
      .from(events)
      .where(eq(events.id, ticketedEvent.eventId));
    
    res.json(event || { description: null, imageUrl: null });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Event Sectors (Organizer) ====================

router.get("/api/siae/ticketed-events/:eventId/sectors", requireAuth, async (req: Request, res: Response) => {
  try {
    const sectors = await siaeStorage.getSiaeEventSectors(req.params.eventId);
    res.json(sectors);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/event-sectors", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeEventSectorSchema.parse(req.body);
    const sector = await siaeStorage.createSiaeEventSector(data);
    res.status(201).json(sector);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/event-sectors/:id", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = patchEventSectorSchema.parse(req.body);
    
    // SIAE rule: block price changes after tickets have been emitted
    if (data.priceIntero !== undefined || data.priceRidotto !== undefined || data.priceOmaggio !== undefined) {
      const [ticketCount] = await db
        .select({ count: sql<number>`count(*)` })
        .from(siaeTickets)
        .where(and(
          eq(siaeTickets.sectorId, req.params.id),
          sql`${siaeTickets.status} != 'cancelled'`
        ));
      
      if (ticketCount && ticketCount.count > 0) {
        return res.status(400).json({ 
          message: "Modifica prezzo non consentita: sono già stati emessi biglietti per questo settore. Crea una nuova tipologia per applicare prezzi diversi.",
          code: "PRICE_LOCKED"
        });
      }
    }
    
    const sector = await siaeStorage.updateSiaeEventSector(req.params.id, data);
    if (!sector) {
      return res.status(404).json({ message: "Settore non trovato" });
    }
    res.json(sector);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.delete("/api/siae/event-sectors/:id", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    // SIAE Compliance: Check if sector has tickets (cannot delete sectors with issued tickets)
    const [ticketCount] = await db
      .select({ count: sql<number>`count(*)` })
      .from(siaeTickets)
      .where(eq(siaeTickets.sectorId, req.params.id));
    
    if (ticketCount && ticketCount.count > 0) {
      return res.status(400).json({ 
        message: "Eliminazione non consentita: sono stati emessi biglietti per questo settore. Per conformità SIAE, i dati dei titoli devono essere conservati.",
        code: "SIAE_RETENTION_REQUIRED"
      });
    }
    
    const deleted = await siaeStorage.deleteSiaeEventSector(req.params.id);
    if (!deleted) {
      return res.status(404).json({ message: "Settore non trovato" });
    }
    res.json({ message: "Settore eliminato con successo" });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Floor Plan Zone Linking (Organizer) ====================

// Schema for linking a sector to a floor plan zone
const linkSectorZoneSchema = z.object({
  floorPlanZoneId: z.string().nullable().optional(), // null to unlink
});

// PATCH /api/siae/sectors/:id/link-zone - Link sector to floor plan zone
router.patch("/api/siae/sectors/:id/link-zone", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = linkSectorZoneSchema.parse(req.body);
    
    // Update the sector's floorPlanZoneId
    const sector = await siaeStorage.updateSiaeEventSector(req.params.id, {
      floorPlanZoneId: data.floorPlanZoneId === undefined ? null : data.floorPlanZoneId
    });
    
    if (!sector) {
      return res.status(404).json({ message: "Settore non trovato" });
    }
    
    res.json(sector);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// GET /api/siae/events/:eventId/floor-plan-data - Get floor plan with zones, sectors, and seats
router.get("/api/siae/events/:eventId/floor-plan-data", requireAuth, async (req: Request, res: Response) => {
  try {
    // Get the ticketed event
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(req.params.eventId);
    if (!ticketedEvent) {
      return res.status(404).json({ message: "Evento biglietteria non trovato" });
    }
    
    // Get the base event to find the location
    const [eventRecord] = await db
      .select({ locationId: events.locationId })
      .from(events)
      .where(eq(events.id, ticketedEvent.eventId));
    
    if (!eventRecord || !eventRecord.locationId) {
      return res.json({ floorPlan: null, zones: [], sectors: [], seats: [] });
    }
    
    // Get the floor plan(s) for this location (prefer default)
    const floorPlans = await db
      .select()
      .from(venueFloorPlans)
      .where(and(
        eq(venueFloorPlans.locationId, eventRecord.locationId),
        eq(venueFloorPlans.isActive, true)
      ))
      .orderBy(venueFloorPlans.isDefault)
      .limit(1);
    
    const floorPlan = floorPlans[0] || null;
    
    // Get zones for this floor plan
    const zones = floorPlan 
      ? await db
          .select()
          .from(floorPlanZones)
          .where(eq(floorPlanZones.floorPlanId, floorPlan.id))
          .orderBy(floorPlanZones.sortOrder)
      : [];
    
    // Get all sectors for this ticketed event with their zone links
    const sectors = await db
      .select()
      .from(siaeEventSectors)
      .where(eq(siaeEventSectors.ticketedEventId, req.params.eventId))
      .orderBy(siaeEventSectors.sortOrder);
    
    // Get all numbered seats for this event
    const seats = await db
      .select()
      .from(siaeNumberedSeats)
      .innerJoin(siaeEventSectors, eq(siaeNumberedSeats.sectorId, siaeEventSectors.id))
      .where(eq(siaeEventSectors.ticketedEventId, req.params.eventId));
    
    // Transform seats to flatten the nested structure and map coordinate field names
    const flattenedSeats = seats.map(row => ({
      id: row.siae_numbered_seats.id,
      sectorId: row.siae_numbered_seats.sectorId,
      rowNumber: row.siae_numbered_seats.rowNumber,
      seatNumber: row.siae_numbered_seats.seatNumber,
      category: row.siae_numbered_seats.category,
      priceMultiplier: row.siae_numbered_seats.priceMultiplier,
      status: row.siae_numbered_seats.status,
      posX: row.siae_numbered_seats.xPosition,
      posY: row.siae_numbered_seats.yPosition,
      notes: row.siae_numbered_seats.notes,
      createdAt: row.siae_numbered_seats.createdAt,
      updatedAt: row.siae_numbered_seats.updatedAt,
    }));
    
    res.json({
      floorPlan,
      zones,
      sectors,
      seats: flattenedSeats
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Seats (Organizer) ====================

router.get("/api/siae/sectors/:sectorId/seats", requireAuth, async (req: Request, res: Response) => {
  try {
    const seats = await siaeStorage.getSiaeSeats(req.params.sectorId);
    res.json(seats);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/seats/bulk", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const { seats } = req.body;
    if (!Array.isArray(seats)) {
      return res.status(400).json({ message: "Array di posti richiesto" });
    }
    const parsedSeats = seats.map(s => insertSiaeSeatSchema.parse(s));
    const createdSeats = await siaeStorage.createSiaeSeats(parsedSeats);
    res.status(201).json(createdSeats);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// Genera posti in griglia automaticamente per un settore
const generateSeatsGridSchema = z.object({
  sectorId: z.string().min(1, "ID settore richiesto"),
  rows: z.number().min(1).max(50), // Max 50 file
  seatsPerRow: z.number().min(1).max(100), // Max 100 posti per fila
  startRow: z.string().default("A"), // Prima fila (A, B, C... o 1, 2, 3...)
  startSeat: z.number().default(1), // Primo numero posto
  // Posizione sulla planimetria (opzionale - coordinate del settore)
  startX: z.number().min(0).max(100).optional(), // X iniziale (percentuale)
  startY: z.number().min(0).max(100).optional(), // Y iniziale (percentuale)
  endX: z.number().min(0).max(100).optional(), // X finale (percentuale)
  endY: z.number().min(0).max(100).optional(), // Y finale (percentuale)
  clearExisting: z.boolean().default(false), // Se true, elimina posti esistenti prima
});

router.post("/api/siae/seats/generate-grid", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = generateSeatsGridSchema.parse(req.body);
    
    // Verifica che il settore esista
    const sector = await siaeStorage.getSiaeEventSector(data.sectorId);
    if (!sector) {
      return res.status(404).json({ message: "Settore non trovato" });
    }
    
    // Se richiesto, elimina posti esistenti
    if (data.clearExisting) {
      await siaeStorage.deleteSiaeSeatsBySector(data.sectorId);
    }
    
    // Genera array di posti
    const seats: any[] = [];
    const isNumericRow = /^\d+$/.test(data.startRow);
    let currentRowNum = isNumericRow ? parseInt(data.startRow) : 0;
    let currentRowChar = isNumericRow ? "" : data.startRow;
    
    // Calcola spacing per posizioni sulla planimetria
    const hasPositions = data.startX !== undefined && data.startY !== undefined && 
                         data.endX !== undefined && data.endY !== undefined;
    const xSpacing = hasPositions ? (data.endX! - data.startX!) / Math.max(data.seatsPerRow - 1, 1) : 0;
    const ySpacing = hasPositions ? (data.endY! - data.startY!) / Math.max(data.rows - 1, 1) : 0;
    
    for (let r = 0; r < data.rows; r++) {
      const rowLabel = isNumericRow 
        ? String(currentRowNum + r)
        : String.fromCharCode(currentRowChar.charCodeAt(0) + r);
      
      for (let s = 0; s < data.seatsPerRow; s++) {
        const seatNumber = String(data.startSeat + s);
        const seatLabel = `${rowLabel}${seatNumber}`;
        
        const seat: any = {
          sectorId: data.sectorId,
          row: rowLabel,
          seatNumber: seatNumber,
          seatLabel: seatLabel,
          status: 'available',
        };
        
        // Aggiungi posizioni se disponibili
        if (hasPositions) {
          seat.posX = String(data.startX! + s * xSpacing);
          seat.posY = String(data.startY! + r * ySpacing);
        }
        
        seats.push(seat);
      }
    }
    
    // Crea posti in batch
    const createdSeats = await siaeStorage.createSiaeSeats(seats);
    
    // Aggiorna capacità settore se isNumbered
    if (sector.isNumbered) {
      await siaeStorage.updateSiaeEventSector(data.sectorId, {
        capacity: createdSeats.length + (data.clearExisting ? 0 : (sector.capacity || 0)),
        availableSeats: createdSeats.length + (data.clearExisting ? 0 : (sector.availableSeats || 0)),
      });
    }
    
    res.status(201).json({
      message: `Creati ${createdSeats.length} posti (${data.rows} file x ${data.seatsPerRow} posti)`,
      seats: createdSeats,
      totalSeats: createdSeats.length,
    });
  } catch (error: any) {
    console.error("[SIAE-ROUTES] Error generating seat grid:", error);
    res.status(400).json({ message: error.message });
  }
});

// Elimina tutti i posti di un settore
router.delete("/api/siae/sectors/:sectorId/seats", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const { sectorId } = req.params;
    
    // Verifica che il settore esista
    const sector = await siaeStorage.getSiaeEventSector(sectorId);
    if (!sector) {
      return res.status(404).json({ message: "Settore non trovato" });
    }
    
    // SIAE Compliance: Check if any tickets exist for this sector (cannot delete seats with ticket history)
    const [ticketCount] = await db
      .select({ count: sql<number>`count(*)` })
      .from(siaeTickets)
      .where(eq(siaeTickets.sectorId, sectorId));
    
    if (ticketCount && ticketCount.count > 0) {
      return res.status(400).json({ 
        message: "Eliminazione non consentita: sono stati emessi biglietti per questo settore. Per conformità SIAE, i dati dei posti devono essere conservati per almeno 60 giorni.",
        code: "SIAE_RETENTION_REQUIRED"
      });
    }
    
    // Verifica che non ci siano biglietti venduti per i posti
    const seats = await siaeStorage.getSiaeSeats(sectorId);
    const soldSeats = seats.filter(s => s.status === 'sold');
    if (soldSeats.length > 0) {
      return res.status(400).json({ 
        message: `Impossibile eliminare: ${soldSeats.length} posti già venduti` 
      });
    }
    
    await siaeStorage.deleteSiaeSeatsBySector(sectorId);
    
    res.json({ message: `Eliminati ${seats.length} posti dal settore` });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// POST /api/siae/sectors/:sectorId/sync-seats - Sincronizza posti da floor plan a settore SIAE
router.post("/api/siae/sectors/:sectorId/sync-seats", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const { sectorId } = req.params;
    const { zoneId } = req.body;
    
    if (!zoneId) {
      return res.status(400).json({ message: "ID zona floor plan richiesto" });
    }
    
    // 1. Verifica che il settore esista e sia numerato
    const [sector] = await db.select().from(siaeEventSectors).where(eq(siaeEventSectors.id, sectorId));
    if (!sector) {
      return res.status(404).json({ message: "Settore non trovato" });
    }
    if (!sector.isNumbered) {
      return res.status(400).json({ message: "Il settore non è numerato. Solo i settori numerati possono sincronizzare i posti." });
    }
    
    // 2. Verifica che la zona esista
    const [zone] = await db.select().from(floorPlanZones).where(eq(floorPlanZones.id, zoneId));
    if (!zone) {
      return res.status(404).json({ message: "Zona floor plan non trovata" });
    }
    
    // 3. SIAE Compliance: Check if any tickets exist for this sector
    const [ticketCount] = await db
      .select({ count: sql<number>`count(*)` })
      .from(siaeTickets)
      .where(eq(siaeTickets.sectorId, sectorId));
    
    if (ticketCount && ticketCount.count > 0) {
      return res.status(400).json({ 
        message: "Sincronizzazione non consentita: sono stati emessi biglietti per questo settore. Per conformità SIAE, i dati dei posti non possono essere modificati.",
        code: "SIAE_TICKETS_EXIST"
      });
    }
    
    // 4. Carica i posti dalla zona del floor plan
    const floorPlanSeatsData = await db.select().from(floorPlanSeats).where(eq(floorPlanSeats.zoneId, zoneId));
    if (floorPlanSeatsData.length === 0) {
      return res.status(400).json({ message: "Nessun posto trovato nella zona selezionata" });
    }
    
    // 5. Elimina posti esistenti del settore
    await db.delete(siaeSeats).where(eq(siaeSeats.sectorId, sectorId));
    
    // 6. Copia i posti dal floor plan al settore SIAE
    const seatsToInsert = floorPlanSeatsData.map(fpSeat => ({
      sectorId,
      floorPlanSeatId: fpSeat.id,
      row: fpSeat.row,
      seatNumber: fpSeat.seatNumber?.toString() || fpSeat.seatLabel,
      seatLabel: fpSeat.seatLabel,
      posX: fpSeat.posX,
      posY: fpSeat.posY,
      status: fpSeat.isBlocked ? 'blocked' : 'available',
      isAccessible: fpSeat.isAccessible || false,
    }));
    
    const inserted = await db.insert(siaeSeats).values(seatsToInsert).returning();
    
    // 7. Aggiorna capacità e posti disponibili del settore
    const availableCount = inserted.filter(s => s.status === 'available').length;
    await db.update(siaeEventSectors)
      .set({ 
        capacity: inserted.length, 
        availableSeats: availableCount 
      })
      .where(eq(siaeEventSectors.id, sectorId));
    
    res.json({ 
      success: true, 
      count: inserted.length,
      availableSeats: availableCount,
      zoneName: zone.name,
      message: `${inserted.length} posti sincronizzati con successo dalla zona "${zone.name}"`
    });
  } catch (error: any) {
    console.error("[SIAE-ROUTES] Error syncing seats from floor plan:", error);
    res.status(500).json({ message: error.message });
  }
});

// GET /api/siae/sectors/:sectorId/available-zones - Ottieni zone disponibili per sincronizzazione
router.get("/api/siae/sectors/:sectorId/available-zones", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const { sectorId } = req.params;
    
    // Ottieni il settore per trovare l'evento
    const [sector] = await db.select().from(siaeEventSectors).where(eq(siaeEventSectors.id, sectorId));
    if (!sector) {
      return res.status(404).json({ message: "Settore non trovato" });
    }
    
    // Ottieni l'evento ticketed e il suo evento base per trovare la location
    const [ticketedEvent] = await db.select().from(siaeTicketedEvents).where(eq(siaeTicketedEvents.id, sector.ticketedEventId));
    if (!ticketedEvent) {
      return res.json({ zones: [] });
    }
    
    // Get the base event to find the locationId
    const [baseEvent] = await db.select().from(events).where(eq(events.id, ticketedEvent.eventId));
    if (!baseEvent || !baseEvent.locationId) {
      return res.json({ zones: [] });
    }
    
    // Import venueFloorPlans
    const { venueFloorPlans } = await import("@shared/schema");
    
    // Ottieni i floor plan della location (using event.locationId)
    const floorPlans = await db.select().from(venueFloorPlans).where(eq(venueFloorPlans.locationId, baseEvent.locationId));
    if (floorPlans.length === 0) {
      return res.json({ zones: [] });
    }
    
    // Ottieni tutte le zone con posti dei floor plan
    const zones = await db
      .select({
        id: floorPlanZones.id,
        name: floorPlanZones.name,
        zoneType: floorPlanZones.zoneType,
        floorPlanId: floorPlanZones.floorPlanId,
        capacity: floorPlanZones.capacity,
      })
      .from(floorPlanZones)
      .where(inArray(floorPlanZones.floorPlanId, floorPlans.map(fp => fp.id)));
    
    // Per ogni zona, conta i posti
    const zonesWithSeats = await Promise.all(zones.map(async (zone) => {
      const [seatCount] = await db
        .select({ count: sql<number>`count(*)` })
        .from(floorPlanSeats)
        .where(eq(floorPlanSeats.zoneId, zone.id));
      
      return {
        ...zone,
        seatsCount: seatCount?.count || 0,
      };
    }));
    
    // Filtra solo le zone che hanno posti
    const zonesWithSeatsFiltered = zonesWithSeats.filter(z => z.seatsCount > 0);
    
    res.json({ zones: zonesWithSeatsFiltered });
  } catch (error: any) {
    console.error("[SIAE-ROUTES] Error fetching available zones:", error);
    res.status(500).json({ message: error.message });
  }
});

// ==================== Tickets (Organizer / Box Office) ====================

// Schema minimo per emissione manuale - sigillo generato server-side
// .strict() rifiuta qualsiasi campo non definito nello schema (inclusi tentativi di iniezione sigillo)
const manualTicketEmissionSchema = z.object({
  ticketedEventId: z.string().min(1, "ID evento richiesto"),
  sectorId: z.string().min(1, "ID settore richiesto"),
  ticketTypeCode: z.string().min(1, "Tipo biglietto richiesto"),
  sectorCode: z.string().max(2, "Codice settore max 2 caratteri").optional(),
  customerId: z.string().nullable().optional(),
  participantFirstName: z.string().nullable().optional(),
  participantLastName: z.string().nullable().optional(),
  emissionDate: z.string().optional(),
  emissionDateStr: z.string().optional(),
  emissionTimeStr: z.string().optional(),
}).strict();

router.get("/api/siae/ticketed-events/:eventId/tickets", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const tickets = await siaeStorage.getSiaeTicketsByEvent(req.params.eventId);
    res.json(tickets);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/tickets/:id", requireAuth, async (req: Request, res: Response) => {
  try {
    const ticket = await siaeStorage.getSiaeTicket(req.params.id);
    if (!ticket) {
      return res.status(404).json({ message: "Biglietto non trovato" });
    }
    res.json(ticket);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/tickets", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    // Verifica connessione bridge e stato carta SIAE
    if (!isBridgeConnected()) {
      return res.status(503).json({ 
        message: "Lettore SIAE non connesso. Avviare l'app desktop Event Four You.",
        code: "SEAL_BRIDGE_OFFLINE"
      });
    }
    
    const cardStatus = isCardReadyForSeals();
    if (!cardStatus.ready) {
      return res.status(503).json({ 
        message: cardStatus.error || "Carta SIAE non pronta",
        code: "SEAL_CARD_NOT_READY"
      });
    }
    
    // Parse dati richiesta con schema minimo (NO campi sigillo dal client)
    const data = manualTicketEmissionSchema.parse(req.body);
    
    // Ottieni settore per calcolare il prezzo
    const sector = await siaeStorage.getSiaeEventSector(data.sectorId);
    if (!sector) {
      return res.status(400).json({ message: "Settore non trovato" });
    }
    
    // Ottieni evento per il canale di emissione
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(data.ticketedEventId);
    if (!ticketedEvent) {
      return res.status(400).json({ message: "Evento non trovato" });
    }
    
    // CONTROLLO OBBLIGATORIO: Codice Fiscale Emittente configurato
    const systemConfig = await siaeStorage.getSiaeSystemConfig(ticketedEvent.companyId);
    const company = await storage.getCompany(ticketedEvent.companyId);
    const taxId = systemConfig?.taxId || company?.fiscalCode || company?.taxId;
    
    if (!taxId) {
      return res.status(400).json({ 
        message: "Codice Fiscale Emittente non configurato. Vai su Impostazioni SIAE > Dati Aziendali per configurarlo.",
        code: "TAX_ID_REQUIRED"
      });
    }
    
    // Calcola prezzo in centesimi
    const grossAmount = data.ticketTypeCode === "INT" ? sector.priceIntero : 
                       data.ticketTypeCode === "RID" ? (sector.priceRidotto || sector.priceIntero) : "0";
    const priceInCents = Math.round(parseFloat(grossAmount) * 100);
    
    // RICHIESTA SIGILLO FISCALE SERVER-SIDE (OBBLIGATORIO PER SIAE)
    // Questo è il cuore del sistema: senza sigillo, niente biglietto
    let sealData;
    try {
      console.log(`[SIAE-ROUTES] Requesting fiscal seal for manual emission, price: ${priceInCents} cents`);
      sealData = await requestFiscalSeal(priceInCents);
      console.log(`[SIAE-ROUTES] Seal received: ${sealData.sealCode}, counter: ${sealData.counter}`);
    } catch (sealError: any) {
      console.error(`[SIAE-ROUTES] Failed to get fiscal seal:`, sealError.message);
      return res.status(503).json({
        message: `Impossibile generare sigillo fiscale: ${sealError.message.replace(/^[A-Z_]+:\s*/, '')}`,
        code: sealError.message.split(':')[0] || 'SEAL_ERROR'
      });
    }
    
    const now = new Date();
    const emissionDateStr = data.emissionDateStr || now.toISOString().slice(0, 10).replace(/-/g, '');
    const emissionTimeStr = data.emissionTimeStr || now.toTimeString().slice(0, 5).replace(':', '');
    
    // Crea biglietto con sigillo REALE generato server-side
    // I campi sigillo sono SEMPRE generati dal server - mai accettati dal client
    // Calcola progressivo sequenziale dell'evento (non il contatore della carta)
    const eventProgressiveNumber = (ticketedEvent.ticketsSold || 0) + 1;
    
    // Ensure sectorCode is max 2 chars (SIAE TAB.2 requirement)
    const sectorCode = (data.sectorCode || sector.sectorCode || 'XX').slice(0, 2);
    
    const ticketData = {
      ticketedEventId: data.ticketedEventId,
      sectorId: data.sectorId,
      ticketTypeCode: data.ticketTypeCode,
      sectorCode,
      customerId: data.customerId || null,
      participantFirstName: data.participantFirstName || null,
      participantLastName: data.participantLastName || null,
      emissionDate: data.emissionDate ? new Date(data.emissionDate) : now,
      emissionDateStr,
      emissionTimeStr,
      grossAmount: grossAmount,
      // SIGILLO GENERATO SERVER-SIDE - OBBLIGATORIO SIAE
      fiscalSealCode: sealData.sealCode,
      fiscalSealCounter: sealData.counter, // Contatore carta SIAE
      progressiveNumber: eventProgressiveNumber, // Progressivo sequenziale dell'evento
      cardCode: sealData.serialNumber,
      emissionChannelCode: "BOX", // Box Office per emissione manuale
    };
    
    const ticket = await siaeStorage.createSiaeTicket(ticketData as any);
    res.status(201).json(ticket);
  } catch (error: any) {
    console.error(`[SIAE-ROUTES] Ticket creation error:`, error.message);
    res.status(400).json({ message: error.message });
  }
});

router.post("/api/siae/tickets/:id/cancel", requireAuth, async (req: Request, res: Response) => {
  try {
    const { reasonCode, refund, refundReason } = req.body;
    if (!reasonCode) {
      return res.status(400).json({ message: "Causale annullamento richiesta (codice SIAE obbligatorio)" });
    }
    const user = req.user as any;
    
    // Prima ottieni il biglietto per avere il transactionId
    const existingTicket = await siaeStorage.getSiaeTicket(req.params.id);
    if (!existingTicket) {
      return res.status(404).json({ message: "Biglietto non trovato" });
    }
    
    // Controllo permessi: gestori/organizer/super_admin possono cancellare tutti i biglietti della propria azienda
    // Cassieri possono cancellare solo i biglietti emessi dalla propria sessione/cassa
    const isCassiere = user.role === 'cassiere';
    const isGestore = user.role === 'gestore' || user.role === 'organizer' || user.role === 'super_admin' || user.role === 'admin';
    
    // Verifica che il biglietto appartenga alla stessa azienda dell'utente
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(existingTicket.ticketedEventId);
    if (!ticketedEvent) {
      return res.status(404).json({ message: "Evento del biglietto non trovato" });
    }
    
    // Per cassieri: usa getSiaeCashierId per ottenere l'ID corretto dalla sessione
    // e verifica l'azienda tramite allocazione evento
    if (isCassiere) {
      const cashierId = getSiaeCashierId(user);
      if (!cashierId) {
        return res.status(403).json({ message: "Non autorizzato: impossibile identificare il cassiere" });
      }
      
      // Verifica che il cassiere sia allocato a questo evento (questo garantisce anche la stessa azienda)
      const allocation = await siaeStorage.getCashierAllocationByCashierAndEvent(cashierId, existingTicket.ticketedEventId);
      if (!allocation) {
        return res.status(403).json({ message: "Non autorizzato: non sei allocato a questo evento" });
      }
      
      // SICUREZZA: I cassieri possono cancellare SOLO biglietti con issuedByUserId valido
      if (!existingTicket.issuedByUserId) {
        return res.status(403).json({ message: "Non autorizzato: questo biglietto può essere annullato solo da un gestore" });
      }
      
      // Verifica che il biglietto sia stato emesso da questo cassiere
      // Supporta entrambi i formati: user.id (vecchi biglietti) e cashierId (nuovi biglietti)
      const isIssuedByCashier = existingTicket.issuedByUserId === cashierId || 
                                existingTicket.issuedByUserId === user.id;
      if (!isIssuedByCashier) {
        return res.status(403).json({ message: "Non autorizzato: puoi annullare solo i biglietti emessi dalla tua cassa" });
      }
    } else if (isGestore) {
      // Per gestori: verifica companyId obbligatoriamente (tranne super_admin)
      const userCompanyId = user.companyId;
      if (user.role !== 'super_admin') {
        if (!userCompanyId) {
          return res.status(403).json({ message: "Non autorizzato: impossibile verificare l'azienda dell'utente" });
        }
        if (ticketedEvent.companyId !== userCompanyId) {
          return res.status(403).json({ message: "Non autorizzato: biglietto di un'altra azienda" });
        }
      }
    } else {
      return res.status(403).json({ message: "Non autorizzato ad annullare biglietti" });
    }
    
    // Processa rimborso se richiesto
    let stripeRefundId: string | null = null;
    let refundAmount: string | null = null;
    
    if (refund === true && existingTicket.transactionId) {
      try {
        // Trova la transazione per ottenere il payment intent ID
        const transaction = await siaeStorage.getSiaeTransaction(existingTicket.transactionId);
        
        if (transaction && transaction.paymentReference) {
          const stripe = await getUncachableStripeClient();
          
          // Calcola l'importo del rimborso (prezzo biglietto)
          const ticketPrice = Number(existingTicket.ticketPrice || existingTicket.grossAmount) * 100;
          
          // Crea rimborso parziale per questo singolo biglietto
          const stripeRefund = await stripe.refunds.create({
            payment_intent: transaction.paymentReference,
            amount: Math.round(ticketPrice),
            reason: 'requested_by_customer',
            metadata: {
              ticketId: existingTicket.id,
              ticketCode: existingTicket.ticketCode || '',
              cancelledBy: user.id,
              reasonCode: reasonCode,
              refundReason: refundReason || 'Annullamento biglietto'
            }
          });
          
          stripeRefundId = stripeRefund.id;
          refundAmount = (ticketPrice / 100).toFixed(2);
          
          console.log(`[SIAE] Refund processed for ticket ${existingTicket.id}: ${stripeRefundId}, amount: €${refundAmount}`);
        } else {
          console.warn(`[SIAE] Cannot refund ticket ${existingTicket.id}: no payment reference found`);
        }
      } catch (refundError: any) {
        console.error(`[SIAE] Refund failed for ticket ${existingTicket.id}:`, refundError.message);
        return res.status(500).json({ 
          message: `Annullamento fallito: errore nel rimborso Stripe - ${refundError.message}` 
        });
      }
    }
    
    // Annulla il biglietto
    const ticket = await siaeStorage.cancelSiaeTicket(req.params.id, reasonCode, user.id);
    if (!ticket) {
      return res.status(404).json({ message: "Biglietto non trovato" });
    }
    
    // Se rimborso avvenuto, aggiorna i campi rimborso
    if (stripeRefundId) {
      await db.update(siaeTickets)
        .set({
          refundedAt: new Date(),
          refundAmount: refundAmount,
          stripeRefundId: stripeRefundId,
          refundInitiatorId: user.id,
          refundReason: refundReason || 'Annullamento con rimborso',
          updatedAt: new Date()
        })
        .where(eq(siaeTickets.id, req.params.id));
      
      // Ricarica il biglietto per restituire i dati aggiornati
      const updatedTicket = await siaeStorage.getSiaeTicket(req.params.id);
      return res.json({ 
        ...updatedTicket, 
        refunded: true, 
        refundId: stripeRefundId,
        refundedAmount: refundAmount
      });
    }
    
    res.json(ticket);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/tickets/:id/validate", requireAuth, async (req: Request, res: Response) => {
  try {
    const { scannerId } = req.body;
    const ticket = await siaeStorage.markSiaeTicketUsed(req.params.id, scannerId || 'manual');
    if (!ticket) {
      return res.status(404).json({ message: "Biglietto non trovato" });
    }
    res.json(ticket);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Transactions (Public - for purchase) ====================

router.get("/api/siae/ticketed-events/:eventId/transactions", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const transactions = await siaeStorage.getSiaeTransactionsByEvent(req.params.eventId);
    res.json(transactions);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// GET all transactions for a company (for admin/gestore views)
router.get("/api/siae/transactions", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { companyId } = req.query;
    
    // Super admin can see all, gestore sees only their company
    let targetCompanyId: string | undefined;
    if (user.role === 'super_admin') {
      targetCompanyId = companyId as string | undefined;
    } else if (user.companyId) {
      targetCompanyId = user.companyId;
    } else {
      return res.status(403).json({ message: "Accesso non autorizzato" });
    }
    
    // Get all ticketed events for this company
    const ticketedEventIds: string[] = [];
    if (targetCompanyId) {
      const companyEvents = await db
        .select({ id: siaeTicketedEvents.id })
        .from(siaeTicketedEvents)
        .where(eq(siaeTicketedEvents.companyId, targetCompanyId));
      ticketedEventIds.push(...companyEvents.map(e => e.id));
    } else {
      // Super admin without filter - get all
      const allEvents = await db.select({ id: siaeTicketedEvents.id }).from(siaeTicketedEvents);
      ticketedEventIds.push(...allEvents.map(e => e.id));
    }
    
    if (ticketedEventIds.length === 0) {
      return res.json([]);
    }
    
    // Get all transactions for these events with event info
    const transactions = await db
      .select({
        transaction: siaeTransactions,
        eventId: siaeTicketedEvents.eventId,
        eventName: events.name,
      })
      .from(siaeTransactions)
      .innerJoin(siaeTicketedEvents, eq(siaeTransactions.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id))
      .where(inArray(siaeTransactions.ticketedEventId, ticketedEventIds))
      .orderBy(desc(siaeTransactions.createdAt));
    
    // Flatten the response to include event info at the transaction level
    const result = transactions.map(row => ({
      ...row.transaction,
      eventId: row.eventId,
      eventName: row.eventName,
    }));
    
    res.json(result);
  } catch (error: any) {
    console.error('[GET /api/siae/transactions] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/transactions/:id", requireAuth, async (req: Request, res: Response) => {
  try {
    const transaction = await siaeStorage.getSiaeTransaction(req.params.id);
    if (!transaction) {
      return res.status(404).json({ message: "Transazione non trovata" });
    }
    res.json(transaction);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Export transaction XML for SIAE
router.get("/api/siae/transactions/:id/export-xml", requireAuth, async (req: Request, res: Response) => {
  try {
    const transaction = await siaeStorage.getSiaeTransaction(req.params.id);
    if (!transaction) {
      return res.status(404).json({ message: "Transazione non trovata" });
    }

    // Get tickets for this transaction
    const tickets = await db.select().from(siaeTickets)
      .where(eq(siaeTickets.transactionId, req.params.id));

    // Get event info
    const ticketedEvent = await db.select().from(siaeTicketedEvents)
      .where(eq(siaeTicketedEvents.id, transaction.ticketedEventId))
      .then(rows => rows[0]);

    let eventName = "Evento";
    if (ticketedEvent) {
      const event = await db.select().from(events)
        .where(eq(events.id, ticketedEvent.eventId))
        .then(rows => rows[0]);
      if (event) eventName = event.name;
    }

    // Generate XML
    const xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<TransazioneSIAE>
  <Intestazione>
    <CodiceTransazione>${transaction.transactionCode}</CodiceTransazione>
    <DataTransazione>${transaction.createdAt ? new Date(transaction.createdAt).toISOString() : ''}</DataTransazione>
    <StatoTransazione>${transaction.status}</StatoTransazione>
  </Intestazione>
  <Evento>
    <NomeEvento>${eventName}</NomeEvento>
    <CodiceEvento>${transaction.ticketedEventId}</CodiceEvento>
  </Evento>
  <Cliente>
    <CodiceCliente>${transaction.customerUniqueCode || ''}</CodiceCliente>
    <Email>${transaction.customerEmail || ''}</Email>
  </Cliente>
  <DatiPagamento>
    <MetodoPagamento>${transaction.paymentMethod}</MetodoPagamento>
    <ImportoTotale>${transaction.totalAmount}</ImportoTotale>
    <NumeroBiglietti>${transaction.ticketsCount}</NumeroBiglietti>
  </DatiPagamento>
  <Biglietti>
${tickets.map(ticket => `    <Biglietto>
      <CodiceBiglietto>${ticket.ticketCode}</CodiceBiglietto>
      <SigilloFiscale>${ticket.fiscalSealCode || ''}</SigilloFiscale>
      <Prezzo>${ticket.grossAmount || 0}</Prezzo>
      <Stato>${ticket.status}</Stato>
      <Partecipante>${ticket.participantFirstName || ''} ${ticket.participantLastName || ''}</Partecipante>
    </Biglietto>`).join('\n')}
  </Biglietti>
</TransazioneSIAE>`;

    res.json({ xml: xmlContent });
  } catch (error: any) {
    console.error('[GET /api/siae/transactions/:id/export-xml] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/transactions", async (req: Request, res: Response) => {
  try {
    const data = insertSiaeTransactionSchema.parse(req.body);
    const transaction = await siaeStorage.createSiaeTransaction(data);
    res.status(201).json(transaction);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/transactions/:id", requireAuth, async (req: Request, res: Response) => {
  try {
    const data = patchTransactionSchema.parse(req.body);
    const transaction = await siaeStorage.updateSiaeTransaction(req.params.id, data);
    if (!transaction) {
      return res.status(404).json({ message: "Transazione non trovata" });
    }
    res.json(transaction);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// ==================== Admin Name Changes (Super Admin & Gestore) ====================

router.get("/api/siae/admin/name-changes", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { companyId, eventId, status, page = '1', limit = '50' } = req.query;
    
    // Gestori can only see their company's name changes
    // Super admins can see all or filter by company
    const effectiveCompanyId = user.role === 'super_admin' 
      ? (companyId as string | undefined) 
      : user.companyId;
    
    // Build query with filters
    let query = db
      .select({
        nameChange: siaeNameChanges,
        ticket: {
          id: siaeTickets.id,
          ticketCode: siaeTickets.ticketCode,
          participantFirstName: siaeTickets.participantFirstName,
          participantLastName: siaeTickets.participantLastName,
          ticketedEventId: siaeTickets.ticketedEventId,
          fiscalSealCode: siaeTickets.fiscalSealCode,
        },
        ticketedEvent: {
          id: siaeTicketedEvents.id,
          eventId: siaeTicketedEvents.eventId,
          companyId: siaeTicketedEvents.companyId,
          nameChangeFee: siaeTicketedEvents.nameChangeFee,
        },
        event: {
          id: events.id,
          name: events.name,
          startDatetime: events.startDatetime,
        },
        company: {
          id: companies.id,
          name: companies.name,
        },
      })
      .from(siaeNameChanges)
      .innerJoin(siaeTickets, eq(siaeNameChanges.originalTicketId, siaeTickets.id))
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id))
      .innerJoin(companies, eq(siaeTicketedEvents.companyId, companies.id));
    
    // Apply filters
    const conditions: any[] = [];
    // For gestore, always filter by their company; for super_admin, use query param if provided
    if (effectiveCompanyId) {
      conditions.push(eq(siaeTicketedEvents.companyId, effectiveCompanyId));
    }
    if (eventId && typeof eventId === 'string') {
      conditions.push(eq(siaeTicketedEvents.eventId, eventId));
    }
    if (status && typeof status === 'string') {
      conditions.push(eq(siaeNameChanges.status, status));
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions)) as any;
    }
    
    // Add ordering and pagination
    const pageNum = parseInt(page as string) || 1;
    const limitNum = Math.min(parseInt(limit as string) || 50, 100);
    const offset = (pageNum - 1) * limitNum;
    
    const results = await query
      .orderBy(desc(siaeNameChanges.createdAt))
      .limit(limitNum)
      .offset(offset);
    
    // Get total count for pagination (apply same filters)
    let countQuery = db
      .select({ count: count() })
      .from(siaeNameChanges)
      .innerJoin(siaeTickets, eq(siaeNameChanges.originalTicketId, siaeTickets.id))
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id));
    
    if (conditions.length > 0) {
      countQuery = countQuery.where(and(...conditions)) as any;
    }
    
    const countResult = await countQuery;
    const total = countResult[0]?.count || 0;
    
    res.json({
      nameChanges: results.map(r => ({
        ...r.nameChange,
        ticket: {
          ...r.ticket,
          fiscalSealCode: r.ticket.fiscalSealCode, // Esplicito per conformità SIAE
        },
        ticketedEvent: r.ticketedEvent,
        event: r.event,
        company: r.company,
        // SIAE Compliance: sigillo fiscale per tracciabilità
        sigilloFiscaleOriginale: r.ticket.fiscalSealCode,
      })),
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum),
      },
    });
  } catch (error: any) {
    console.error('[ADMIN NAME-CHANGES] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

// Get companies and events for filters
router.get("/api/siae/admin/name-changes/filters", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    
    // For gestore, filter to their company only
    const companyFilter = user.role === 'super_admin' 
      ? undefined 
      : user.companyId;
    
    // Get all companies with name changes (super_admin sees all, gestore sees only theirs)
    let companiesQuery = db
      .selectDistinct({
        id: companies.id,
        name: companies.name,
      })
      .from(siaeNameChanges)
      .innerJoin(siaeTickets, eq(siaeNameChanges.originalTicketId, siaeTickets.id))
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(companies, eq(siaeTicketedEvents.companyId, companies.id));
    
    if (companyFilter) {
      companiesQuery = companiesQuery.where(eq(siaeTicketedEvents.companyId, companyFilter)) as any;
    }
    const companiesWithChanges = await companiesQuery.orderBy(companies.name);
    
    // Get all events with name changes (filtered by company for gestore)
    let eventsQuery = db
      .selectDistinct({
        id: events.id,
        name: events.name,
        companyId: siaeTicketedEvents.companyId,
      })
      .from(siaeNameChanges)
      .innerJoin(siaeTickets, eq(siaeNameChanges.originalTicketId, siaeTickets.id))
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id));
    
    if (companyFilter) {
      eventsQuery = eventsQuery.where(eq(siaeTicketedEvents.companyId, companyFilter)) as any;
    }
    const eventsWithChanges = await eventsQuery.orderBy(events.name);
    
    res.json({
      companies: companiesWithChanges,
      events: eventsWithChanges,
      statuses: ['pending', 'completed', 'rejected'],
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// SIAE Compliance: Biglietti annullati per riemissione non ancora agganciati al nuovo titolo
// Per tracciabilità fiscale - mostra i titoli annullati con causale cambio nominativo in attesa di riemissione
router.get("/api/siae/admin/name-changes/pending-reissue", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { companyId, eventId } = req.query;
    
    // For gestore, always filter by their company
    const effectiveCompanyId = user.role === 'super_admin' 
      ? (companyId as string | undefined) 
      : user.companyId;
    
    // Find tickets cancelled for name change (code 10) that don't have a replacement yet
    // OR name change requests that are pending
    const conditions: SQL[] = [
      and(
        eq(siaeTickets.cancellationReasonCode, '10'), // Cambio nominativo - vecchio titolo
        isNull(siaeTickets.replacedByTicketId) // Non ancora riemesso
      )!
    ];
    
    if (effectiveCompanyId) {
      conditions.push(eq(siaeTicketedEvents.companyId, effectiveCompanyId));
    }
    if (eventId) {
      conditions.push(eq(siaeTicketedEvents.eventId, eventId as string));
    }
    
    // Get cancelled tickets awaiting reissue
    const cancelledAwaitingReissue = await db
      .select({
        ticket: siaeTickets,
        ticketedEvent: siaeTicketedEvents,
        event: events,
        company: companies,
      })
      .from(siaeTickets)
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id))
      .innerJoin(companies, eq(siaeTicketedEvents.companyId, companies.id))
      .where(and(...conditions))
      .orderBy(desc(siaeTickets.cancellationDate));
    
    // Get pending name change requests (not yet processed)
    const pendingRequests = await db
      .select({
        nameChange: siaeNameChanges,
        ticket: siaeTickets,
        ticketedEvent: siaeTicketedEvents,
        event: events,
        company: companies,
      })
      .from(siaeNameChanges)
      .innerJoin(siaeTickets, eq(siaeNameChanges.originalTicketId, siaeTickets.id))
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id))
      .innerJoin(companies, eq(siaeTicketedEvents.companyId, companies.id))
      .where(eq(siaeNameChanges.status, 'pending'))
      .orderBy(desc(siaeNameChanges.createdAt));
    
    res.json({
      // Biglietti già annullati ma senza nuovo titolo emesso (anomalia fiscale)
      cancelledAwaitingReissue: cancelledAwaitingReissue.map(r => ({
        ...r.ticket,
        ticketedEvent: r.ticketedEvent,
        event: r.event,
        company: r.company,
        sigilloFiscaleOriginale: r.ticket.fiscalSealCode,
      })),
      // Richieste di cambio nominativo in attesa di elaborazione
      pendingRequests: pendingRequests.map(r => ({
        ...r.nameChange,
        ticket: r.ticket,
        ticketedEvent: r.ticketedEvent,
        event: r.event,
        company: r.company,
        sigilloFiscaleOriginale: r.ticket.fiscalSealCode,
      })),
      summary: {
        cancelledAwaitingReissueCount: cancelledAwaitingReissue.length,
        pendingRequestsCount: pendingRequests.length,
        totalPendingReissue: cancelledAwaitingReissue.length + pendingRequests.length,
      }
    });
  } catch (error: any) {
    console.error('[ADMIN PENDING-REISSUE] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

// Process name change (super_admin or gestore for their company)
router.post("/api/siae/admin/name-changes/:id/process", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { id } = req.params;
    const { action, rejectionReason } = req.body;
    
    if (!action || !['approve', 'reject'].includes(action)) {
      return res.status(400).json({ message: "Azione non valida. Usa 'approve' o 'reject'" });
    }
    
    // Get the name change request with company info
    const [nameChangeWithCompany] = await db
      .select({
        nameChange: siaeNameChanges,
        companyId: siaeTicketedEvents.companyId,
      })
      .from(siaeNameChanges)
      .innerJoin(siaeTickets, eq(siaeNameChanges.originalTicketId, siaeTickets.id))
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
      .where(eq(siaeNameChanges.id, id));
    
    if (!nameChangeWithCompany) {
      return res.status(404).json({ message: "Richiesta di cambio nominativo non trovata" });
    }
    
    const nameChange = nameChangeWithCompany.nameChange;
    
    // Gestori can only process name changes for their own company
    if (user.role !== 'super_admin' && nameChangeWithCompany.companyId !== user.companyId) {
      return res.status(403).json({ message: "Non autorizzato a elaborare questa richiesta" });
    }
    
    if (nameChange.status !== 'pending') {
      return res.status(400).json({ message: "Solo le richieste in attesa possono essere elaborate" });
    }
    
    // Handle rejection
    if (action === 'reject') {
      await db.update(siaeNameChanges)
        .set({
          status: 'rejected',
          processedAt: new Date(),
          notes: rejectionReason || 'Rifiutata dall\'amministratore' // schema uses 'notes' not 'rejectionReason'
        })
        .where(eq(siaeNameChanges.id, id));
      
      return res.json({ success: true, message: "Richiesta rifiutata" });
    }
    
    // Handle approval - check payment if required
    if (nameChange.fee && parseFloat(nameChange.fee) > 0 && nameChange.paymentStatus !== 'paid') {
      return res.status(400).json({ 
        message: "Non è possibile approvare: pagamento commissione non completato",
        code: "PAYMENT_REQUIRED"
      });
    }
    
    // Get original ticket
    const [originalTicket] = await db.select().from(siaeTickets).where(eq(siaeTickets.id, nameChange.originalTicketId));
    if (!originalTicket) {
      return res.status(404).json({ message: "Biglietto originale non trovato" });
    }
    
    // Create new ticket with updated name
    // For SIAE compliance: new ticket gets a new progressivo and new sigillo via smart card
    const now = new Date();
    const newTicketId = crypto.randomUUID();
    const newTicketCode = `NC-${now.getTime().toString(36).toUpperCase()}`;
    
    // Request fiscal seal via bridge (smart card SIAE)
    const priceInCents = Math.round(parseFloat(originalTicket.grossAmount || "0") * 100);
    let sealData;
    try {
      console.log(`[NAME-CHANGE] Requesting fiscal seal for name change, price: ${priceInCents} cents`);
      sealData = await requestFiscalSeal(priceInCents);
      console.log(`[NAME-CHANGE] Seal received: ${sealData.sealCode}, counter: ${sealData.counter}`);
    } catch (sealError: any) {
      console.error(`[NAME-CHANGE] Failed to get fiscal seal:`, sealError.message);
      return res.status(503).json({
        message: `Impossibile generare sigillo fiscale: ${sealError.message.replace(/^[A-Z_]+:\s*/, '')}`,
        code: sealError.message.split(':')[0] || 'SEAL_ERROR'
      });
    }
    
    // Get next progressivo for this event
    const [maxProgressivo] = await db
      .select({ max: sql<number>`COALESCE(MAX(${siaeTickets.progressiveNumber}), 0)` })
      .from(siaeTickets)
      .where(eq(siaeTickets.ticketedEventId, originalTicket.ticketedEventId));
    const nextProgressivo = (maxProgressivo?.max || 0) + 1;
    
    // SIAE Compliant: New ticket must reference original ticket for fiscal traceability
    // Per Allegato B: il nuovo titolo deve contenere riferimento esplicito al sigillo fiscale del titolo annullato
    await db.insert(siaeTickets).values({
      ticketCode: newTicketCode,
      ticketedEventId: originalTicket.ticketedEventId,
      sectorId: originalTicket.sectorId,
      sectorCode: originalTicket.sectorCode,
      ticketTypeCode: originalTicket.ticketTypeCode,
      ticketType: originalTicket.ticketType, // schema uses ticketType not ticketTypeId
      customerId: originalTicket.customerId, // IMPORTANTE: Preserva customerId per rivendita
      participantFirstName: nameChange.newFirstName,
      participantLastName: nameChange.newLastName,
      // Note: participantEmail, participantCodiceFiscale, participantPhone don't exist in schema
      grossAmount: originalTicket.grossAmount, // schema uses grossAmount not price/finalPrice
      netAmount: originalTicket.netAmount,
      vatAmount: originalTicket.vatAmount,
      status: 'valid',
      fiscalSealCode: sealData.sealCode, // schema uses fiscalSealCode not sigilloFiscale
      fiscalSealCounter: sealData.counter, // Counter from SIAE card
      cardCode: sealData.serialNumber, // Card serial number
      progressiveNumber: nextProgressivo, // schema uses progressiveNumber not progressivoSerata
      // Note: entranceType, orderId don't exist in schema
      paymentMethod: originalTicket.paymentMethod,
      // RIFERIMENTO FISCALE AL TITOLO ANNULLATO (Allegato B SIAE)
      originalTicketId: originalTicket.id, // Link al biglietto originale annullato
      emissionDate: now,
      createdAt: now,
      updatedAt: now,
    });
    
    // Annul original ticket with SIAE-compliant causale (TAB.5 code '10' = Cambio nominativo)
    // Per Allegato B: annullamento con causale riemissione + riferimento al nuovo titolo
    await db.update(siaeTickets)
      .set({ 
        status: 'annullato_cambio_nominativo',
        cancellationReasonCode: '10', // TAB.5: "Cambio nominativo - vecchio titolo"
        cancellationDate: now,
        replacedByTicketId: newTicketId, // Link al biglietto sostitutivo (tracciabilità SIAE)
        // Note: annullamentoMotivo doesn't exist in schema - use customText for notes
        customText: `Cambio nominativo - Sigillo originale: ${originalTicket.fiscalSealCode || 'N/A'} - Nuovo: ${sealData.sealCode}`,
        updatedAt: now
      })
      .where(eq(siaeTickets.id, originalTicket.id));
    
    // Update name change request
    await db.update(siaeNameChanges)
      .set({
        status: 'completed',
        newTicketId: newTicketId,
        processedAt: new Date()
      })
      .where(eq(siaeNameChanges.id, id));
    
    res.json({ 
      success: true, 
      message: "Cambio nominativo approvato",
      newTicketId,
      newTicketCode
    });
  } catch (error: any) {
    console.error("[ADMIN-NAME-CHANGE] Error:", error);
    res.status(500).json({ message: error.message });
  }
});

// Direct name change by gestore (no customer request)
router.post("/api/siae/tickets/:ticketId/gestore-name-change", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { ticketId } = req.params;
    const { newFirstName, newLastName, newCodiceFiscale, newEmail, causale } = req.body;
    
    // Validate required fields
    if (!newFirstName || !newLastName || !causale) {
      return res.status(400).json({ message: "Nome, cognome e causale sono obbligatori" });
    }
    
    // Get the original ticket with event/company info
    const [ticketWithEvent] = await db
      .select({
        ticket: siaeTickets,
        ticketedEvent: siaeTicketedEvents,
      })
      .from(siaeTickets)
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
      .where(eq(siaeTickets.id, ticketId));
    
    if (!ticketWithEvent) {
      return res.status(404).json({ message: "Biglietto non trovato" });
    }
    
    const originalTicket = ticketWithEvent.ticket;
    const ticketedEvent = ticketWithEvent.ticketedEvent;
    
    // Gestori can only process tickets for their own company
    if (user.role !== 'super_admin' && ticketedEvent.companyId !== user.companyId) {
      return res.status(403).json({ message: "Non autorizzato a modificare questo biglietto" });
    }
    
    // Check ticket status - only valid/sold tickets can be changed
    const validStatuses = ['valid', 'sold', 'emitted', 'active'];
    if (!validStatuses.includes(originalTicket.status)) {
      return res.status(400).json({ message: `Biglietto non modificabile: stato '${originalTicket.status}'` });
    }
    
    // Check if name change is allowed for this event
    if (!ticketedEvent.allowsChangeName) {
      return res.status(400).json({ message: "Cambio nominativo non abilitato per questo evento" });
    }
    
    const now = new Date();
    const newTicketId = crypto.randomUUID();
    const newTicketCode = `NC-${now.getTime().toString(36).toUpperCase()}`;
    
    // Request fiscal seal via bridge (smart card SIAE)
    const priceInCents = Math.round(parseFloat(originalTicket.grossAmount || "0") * 100);
    let sealData;
    try {
      console.log(`[GESTORE-NAME-CHANGE] Requesting fiscal seal, price: ${priceInCents} cents`);
      sealData = await requestFiscalSeal(priceInCents);
      console.log(`[GESTORE-NAME-CHANGE] Seal received: ${sealData.sealCode}, counter: ${sealData.counter}`);
    } catch (sealError: any) {
      console.error(`[GESTORE-NAME-CHANGE] Failed to get fiscal seal:`, sealError.message);
      return res.status(503).json({
        message: `Impossibile generare sigillo fiscale: ${sealError.message.replace(/^[A-Z_]+:\s*/, '')}`,
        code: sealError.message.split(':')[0] || 'SEAL_ERROR'
      });
    }
    
    // Get next progressivo for this event
    const [maxProgressivo] = await db
      .select({ max: sql<number>`COALESCE(MAX(${siaeTickets.progressiveNumber}), 0)` })
      .from(siaeTickets)
      .where(eq(siaeTickets.ticketedEventId, originalTicket.ticketedEventId));
    const nextProgressivo = (maxProgressivo?.max || 0) + 1;
    
    // Create new ticket with updated holder data
    await db.insert(siaeTickets).values({
      ticketCode: newTicketCode,
      ticketedEventId: originalTicket.ticketedEventId,
      sectorId: originalTicket.sectorId,
      sectorCode: originalTicket.sectorCode,
      ticketTypeCode: originalTicket.ticketTypeCode,
      ticketType: originalTicket.ticketType, // schema uses ticketType not ticketTypeId
      customerId: originalTicket.customerId,
      participantFirstName: newFirstName,
      participantLastName: newLastName,
      // Note: participantEmail, participantCodiceFiscale, participantPhone don't exist in schema
      grossAmount: originalTicket.grossAmount, // schema uses grossAmount not price/finalPrice
      netAmount: originalTicket.netAmount,
      vatAmount: originalTicket.vatAmount,
      status: 'valid',
      fiscalSealCode: sealData.sealCode, // schema uses fiscalSealCode not sigilloFiscale
      fiscalSealCounter: sealData.counter,
      cardCode: sealData.serialNumber,
      progressiveNumber: nextProgressivo, // schema uses progressiveNumber not progressivoSerata
      // Note: entranceType, orderId don't exist in schema
      paymentMethod: 'name_change',
      originalTicketId: originalTicket.id,
      emissionDate: now,
      createdAt: now,
      updatedAt: now,
    });
    
    // Annul original ticket with causale from gestore
    await db.update(siaeTickets)
      .set({ 
        status: 'annullato_cambio_nominativo',
        cancellationReasonCode: '10',
        cancellationDate: now,
        replacedByTicketId: newTicketId,
        // Note: annullamentoMotivo doesn't exist in schema - use customText for notes
        customText: `Cambio nominativo gestore: ${causale} - Sigillo originale: ${originalTicket.fiscalSealCode || 'N/A'} - Nuovo: ${sealData.sealCode}`,
        updatedAt: now
      })
      .where(eq(siaeTickets.id, originalTicket.id));
    
    // Create name change record with status 'completed' directly
    const nameChangeId = crypto.randomUUID();
    await db.insert(siaeNameChanges).values({
      id: nameChangeId,
      originalTicketId: originalTicket.id,
      newTicketId: newTicketId,
      newFirstName,
      newLastName,
      newEmail: newEmail || null,
      newFiscalCode: newCodiceFiscale || null,
      requestedById: user.id,
      requestedByType: 'operator',
      status: 'completed',
      processedAt: now,
      processedByUserId: user.id,
      fee: '0',
      paymentStatus: 'paid',
      createdAt: now,
    });
    
    console.log(`[GESTORE-NAME-CHANGE] Success - Original: ${originalTicket.id}, New: ${newTicketId}, Causale: ${causale}`);
    
    res.json({ 
      success: true, 
      message: "Cambio nominativo completato",
      newTicketId,
      newTicketCode,
      nameChangeId
    });
  } catch (error: any) {
    console.error("[GESTORE-NAME-CHANGE] Error:", error);
    res.status(500).json({ message: error.message });
  }
});

// ==================== Name Changes (Customer / Organizer) ====================

// Get all name changes (for super_admin/gestore with company selector)
router.get("/api/siae/name-changes/all", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const changes = await siaeStorage.getAllSiaeNameChanges();
    res.json(changes);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/companies/:companyId/name-changes", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const changes = await siaeStorage.getSiaeNameChangesByCompany(req.params.companyId);
    res.json(changes);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/tickets/:ticketId/name-changes", requireAuth, async (req: Request, res: Response) => {
  try {
    const changes = await siaeStorage.getSiaeNameChanges(req.params.ticketId);
    res.json(changes);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/name-changes", requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const data = insertSiaeNameChangeSchema.parse(req.body);
    
    // Validate ticket exists and get event info
    const [originalTicket] = await db.select().from(siaeTickets).where(eq(siaeTickets.id, data.originalTicketId));
    if (!originalTicket) {
      return res.status(404).json({ message: "Biglietto non trovato" });
    }
    
    const [ticketedEvent] = await db.select().from(siaeTicketedEvents).where(eq(siaeTicketedEvents.id, originalTicket.ticketedEventId));
    if (!ticketedEvent) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    // Check if name changes are allowed for this event
    if (!ticketedEvent.allowsChangeName) {
      return res.status(400).json({ 
        message: "Il cambio nominativo non è abilitato per questo evento",
        code: "NAME_CHANGE_NOT_ALLOWED"
      });
    }
    
    // Get event details for datetime
    const [eventDetails] = await db.select().from(events).where(eq(events.id, ticketedEvent.eventId));
    if (!eventDetails) {
      return res.status(404).json({ message: "Dettagli evento non trovati" });
    }
    
    // Check temporal limit - deadline hours before event
    // Use startDatetime for event timing (required field)
    const eventDateSource = eventDetails.startDatetime;
    const deadlineHours = ticketedEvent.nameChangeDeadlineHours || 48;
    
    if (eventDateSource) {
      const eventStartTime = new Date(eventDateSource);
      const deadlineTime = new Date(eventStartTime.getTime() - (deadlineHours * 60 * 60 * 1000));
      const now = new Date();
      
      if (now > deadlineTime) {
        const hoursRemaining = Math.max(0, Math.floor((eventStartTime.getTime() - now.getTime()) / (1000 * 60 * 60)));
        return res.status(400).json({ 
          message: `Cambio nominativo non più disponibile. Il termine era ${deadlineHours} ore prima dell'evento (${hoursRemaining} ore rimaste).`,
          code: "NAME_CHANGE_DEADLINE_PASSED",
          deadlineHours,
          hoursRemaining
        });
      }
    } else {
      // No event date available - log warning and allow name change (legacy compatibility)
      console.warn(`[NAME-CHANGE] Event ${ticketedEvent.id} has no startDatetime or date - skipping deadline check`);
    }
    
    // Check max name changes per ticket limit
    const maxChanges = ticketedEvent.maxNameChangesPerTicket || 1;
    const existingChanges = await siaeStorage.getSiaeNameChanges(data.originalTicketId);
    const completedChanges = existingChanges.filter(c => c.status === 'completed').length;
    
    if (completedChanges >= maxChanges) {
      return res.status(400).json({ 
        message: `Limite massimo di cambi nominativo raggiunto (${maxChanges}). Non è possibile richiedere ulteriori modifiche.`,
        code: "MAX_NAME_CHANGES_EXCEEDED",
        maxChanges,
        currentChanges: completedChanges
      });
    }
    
    // Check if ticket status allows name change
    const validStatuses = ['active', 'sold', 'paid', 'emitted', 'valid'];
    if (!validStatuses.includes(originalTicket.status || '')) {
      return res.status(400).json({ 
        message: `Il biglietto non è in stato valido per il cambio nominativo (stato: ${originalTicket.status})`,
        code: "INVALID_TICKET_STATUS"
      });
    }
    
    // Check if there's already a pending name change request
    const pendingChanges = existingChanges.filter(c => c.status === 'pending');
    if (pendingChanges.length > 0) {
      return res.status(400).json({ 
        message: "Esiste già una richiesta di cambio nominativo in attesa per questo biglietto",
        code: "PENDING_REQUEST_EXISTS",
        pendingRequestId: pendingChanges[0].id
      });
    }
    
    // Create the name change request
    const change = await siaeStorage.createSiaeNameChange(data);
    
    // Check if auto-approval is enabled for this event
    if (ticketedEvent.autoApproveNameChanges) {
        // Check if payment is required but not yet paid - skip auto-approval
        const feeAmount = parseFloat(ticketedEvent.nameChangeFee || '0');
        if (feeAmount > 0 && change.paymentStatus !== 'paid') {
          console.log(`[NAME-CHANGE] Auto-approval skipped: payment required (€${feeAmount}) but not yet paid for ${change.id}`);
          // Fall through to return pending status with payment info
        } else {
          // Auto-process the name change
          console.log(`[NAME-CHANGE] Auto-approving name change ${change.id} for event ${ticketedEvent.id}`);
        
        // Check bridge availability
        const bridgeStatus = getCachedBridgeStatus();
        if (bridgeStatus.bridgeConnected && bridgeStatus.cardInserted) {
          try {
            // Request fiscal seal
            const priceInCents = Math.round(Number(originalTicket.grossAmount || originalTicket.ticketPrice || 0) * 100);
            const sealData = await requestFiscalSeal(priceInCents);
            
            // Process the name change
            const result = await db.transaction(async (tx) => {
              // Get next progressive number
              const [{ maxProgress }] = await tx
                .select({ maxProgress: sql<number>`COALESCE(MAX(progressive_number), 0)` })
                .from(siaeTickets)
                .where(eq(siaeTickets.ticketedEventId, originalTicket.ticketedEventId));
              const newProgressiveNumber = (maxProgress || 0) + 1;
              
              // Generate new ticket code
              const newTicketCode = `${ticketedEvent.siaeEventCode || 'TKT'}-NC-${newProgressiveNumber.toString().padStart(6, '0')}`;
              
              // Create new ticket
              const [newTicket] = await tx.insert(siaeTickets)
                .values({
                  ticketedEventId: originalTicket.ticketedEventId,
                  sectorId: originalTicket.sectorId,
                  transactionId: originalTicket.transactionId,
                  customerId: originalTicket.customerId,
                  fiscalSealCode: sealData.sealCode,
                  fiscalSealCounter: sealData.counter,
                  progressiveNumber: newProgressiveNumber,
                  cardCode: sealData.serialNumber,
                  emissionDate: new Date(),
                  emissionDateStr: new Date().toISOString().slice(0, 10).replace(/-/g, ''),
                  emissionTimeStr: new Date().toTimeString().slice(0, 5).replace(':', ''),
                  ticketTypeCode: originalTicket.ticketTypeCode,
                  sectorCode: originalTicket.sectorCode,
                  ticketCode: newTicketCode,
                  ticketType: originalTicket.ticketType,
                  ticketPrice: originalTicket.ticketPrice,
                  seatId: originalTicket.seatId,
                  row: originalTicket.row,
                  seatNumber: originalTicket.seatNumber,
                  grossAmount: originalTicket.grossAmount,
                  netAmount: originalTicket.netAmount,
                  vatAmount: originalTicket.vatAmount,
                  prevendita: originalTicket.prevendita,
                  prevenditaVat: originalTicket.prevenditaVat,
                  participantFirstName: data.newFirstName,
                  participantLastName: data.newLastName,
                  issuedByUserId: userId,
                  isComplimentary: originalTicket.isComplimentary,
                  paymentMethod: 'name_change',
                  status: 'sold',
                  originalTicketId: originalTicket.id,
                  qrCode: `SIAE-TKT-NC-${newProgressiveNumber}`
                })
                .returning();
              
              // Update original ticket with replacement reference and SIAE-compliant annulment
              await tx.update(siaeTickets)
                .set({ 
                  replacedByTicketId: newTicket.id,
                  status: 'annullato_cambio_nominativo',
                  cancellationReasonCode: '10', // TAB.5: "Cambio nominativo - vecchio titolo"
                  cancellationDate: new Date(),
                  cancelledByUserId: userId,
                  customText: `Cambio nominativo auto-approvato - Sigillo originale: ${originalTicket.fiscalSealCode || 'N/A'} - Nuovo: ${sealData.sealCode}`
                })
                .where(eq(siaeTickets.id, originalTicket.id));
              
              // Update name change request
              const [updatedChange] = await tx.update(siaeNameChanges)
                .set({
                  newTicketId: newTicket.id,
                  status: 'completed',
                  processedAt: new Date(),
                  processedByUserId: userId,
                  updatedAt: new Date()
                })
                .where(eq(siaeNameChanges.id, change.id))
                .returning();
              
              return { newTicket, updatedChange };
            });
            
            // Send email to new holder (async)
            if (data.newEmail) {
              const [event] = await db.select().from(events).where(eq(events.id, ticketedEvent.eventId));
              const [sector] = await db.select().from(siaeEventSectors).where(eq(siaeEventSectors.id, originalTicket.sectorId));
              
              if (event) {
                try {
                  const { sendTicketEmail } = await import('./email-service');
                  const { generateDigitalTicketPdf } = await import('./pdf-service');
                  
                  // Fetch template for the company (if available)
                  const template = await storage.getDefaultDigitalTicketTemplate(ticketedEvent.companyId || undefined);
                  
                  const ticketData = {
                    eventName: event.name,
                    eventDate: event.startDatetime,
                    locationName: event.locationId || 'N/A',
                    sectorName: sector?.name || 'N/A',
                    holderName: `${data.newFirstName} ${data.newLastName}`,
                    price: String(originalTicket.grossAmount || originalTicket.ticketPrice || '0'),
                    ticketCode: result.newTicket.ticketCode || '',
                    qrCode: result.newTicket.qrCode || '',
                    fiscalSealCode: sealData.sealCode
                  };
                  
                  const pdfBuffer = await generateDigitalTicketPdf(ticketData, template);
                  
                  const ticketHtml = `
                    <div style="border:1px solid #ddd; padding:20px; border-radius:8px;">
                      <h2 style="color:#6366f1;">Biglietto - ${event.name}</h2>
                      <p><strong>Intestatario:</strong> ${ticketData.holderName}</p>
                      <p><strong>Settore:</strong> ${ticketData.sectorName}</p>
                      <p><strong>Codice:</strong> ${ticketData.ticketCode}</p>
                      <p><strong>Sigillo SIAE:</strong> ${ticketData.fiscalSealCode}</p>
                    </div>
                  `;
                  
                  await sendTicketEmail({
                    to: data.newEmail,
                    subject: `Cambio Nominativo Completato - ${event.name}`,
                    eventName: event.name,
                    tickets: [{ id: result.newTicket.id, html: ticketHtml }],
                    pdfBuffers: [pdfBuffer]
                  });
                } catch (emailError) {
                  console.error('[NAME-CHANGE] Auto-approval email error:', emailError);
                }
              }
            }
            
            // Create audit log
            await siaeStorage.createAuditLog({
              companyId: ticketedEvent.companyId,
              userId,
              action: 'name_change_auto_approved',
              entityType: 'ticket',
              entityId: result.newTicket.id,
              description: `Auto-approvato: originalTicket=${originalTicket.id}, newTicket=${result.newTicket.id}, seal=${sealData.sealCode}`
            });
            
            return res.status(201).json({
              ...result.updatedChange,
              autoApproved: true,
              newTicket: result.newTicket,
              message: "Cambio nominativo approvato automaticamente"
            });
          } catch (processError: any) {
            console.error('[NAME-CHANGE] Auto-approval failed:', processError);
            // Fall through to return pending status
          }
        } else {
          console.log('[NAME-CHANGE] Auto-approval skipped: bridge not ready');
        }
      }
    }
    
    res.status(201).json(change);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/name-changes/:id", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = patchNameChangeSchema.parse(req.body);
    const change = await siaeStorage.updateSiaeNameChange(req.params.id, data);
    if (!change) {
      return res.status(404).json({ message: "Richiesta cambio nominativo non trovata" });
    }
    res.json(change);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// ==================== Process Name Change (Complete Workflow) ====================
router.post("/api/siae/name-changes/:id/process", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    const { action, rejectionReason } = req.body;
    
    if (!action || !['approve', 'reject'].includes(action)) {
      return res.status(400).json({ message: "Azione non valida. Usa 'approve' o 'reject'" });
    }
    
    // 1. Get the name change request
    const [nameChangeRequest] = await db.select().from(siaeNameChanges).where(eq(siaeNameChanges.id, req.params.id));
    if (!nameChangeRequest) {
      return res.status(404).json({ message: "Richiesta cambio nominativo non trovata" });
    }
    
    if (nameChangeRequest.status !== 'pending') {
      return res.status(400).json({ message: "Richiesta già processata" });
    }
    
    // Handle rejection - no payment check needed
    if (action === 'reject') {
      // If fee was paid and rejecting, process refund first
      const shouldRefund = nameChangeRequest.paymentStatus === 'paid' && parseFloat(nameChangeRequest.fee || '0') > 0;
      
      let refundId: string | null = null;
      let refundSuccess = false;
      let refundError: string | null = null;
      
      // Check for missing paymentIntentId when refund is needed
      if (shouldRefund && !nameChangeRequest.paymentIntentId) {
        console.error(`[NAME-CHANGE] Cannot refund - missing paymentIntentId for request ${req.params.id}`);
        return res.status(400).json({
          message: "Impossibile rifiutare: pagamento presente ma ID pagamento mancante. Contatta il supporto per elaborazione manuale.",
          code: "MISSING_PAYMENT_INTENT",
          requiresManualIntervention: true,
        });
      }
      
      // Attempt Stripe refund BEFORE updating DB status
      if (shouldRefund && nameChangeRequest.paymentIntentId) {
        try {
          console.log(`[NAME-CHANGE] Processing refund for payment ${nameChangeRequest.paymentIntentId}`);
          const stripe = await getUncachableStripeClient();
          const refund = await stripe.refunds.create({
            payment_intent: nameChangeRequest.paymentIntentId,
            reason: 'requested_by_customer',
            metadata: {
              type: 'name_change_fee_refund',
              nameChangeId: req.params.id,
              rejectionReason: rejectionReason || 'Rejected by operator',
            },
          });
          refundId = refund.id;
          refundSuccess = true;
          console.log(`[NAME-CHANGE] Refund processed successfully: ${refundId}`);
        } catch (err: any) {
          console.error(`[NAME-CHANGE] Refund failed for ${nameChangeRequest.paymentIntentId}:`, err);
          refundError = err.message;
          // Continue with rejection but note the failure
        }
      }
      
      // Only set 'refunded' if refund actually succeeded, otherwise keep 'paid'
      const finalPaymentStatus = refundSuccess ? 'refunded' : nameChangeRequest.paymentStatus;
      const notes = refundError 
        ? `${rejectionReason || 'Rifiutata'}. ATTENZIONE: Rimborso fallito - elaborazione manuale necessaria. Errore: ${refundError}`
        : (rejectionReason || 'Rifiutata dall\'operatore');
      
      const [updated] = await db.update(siaeNameChanges)
        .set({
          status: 'rejected',
          paymentStatus: finalPaymentStatus,
          refundId: refundId,
          refundedAt: refundSuccess ? new Date() : null,
          notes,
          processedAt: new Date(),
          processedByUserId: userId,
          updatedAt: new Date()
        })
        .where(eq(siaeNameChanges.id, req.params.id))
        .returning();
      
      if (refundError) {
        // Return partial success - rejection worked but refund failed
        return res.status(207).json({ 
          success: false,
          partialSuccess: true,
          rejectionCompleted: true,
          refundCompleted: false,
          nameChange: updated, 
          message: "Richiesta rifiutata. ATTENZIONE: Rimborso non riuscito - elaborazione manuale necessaria.",
          refundInitiated: false,
          refundError,
          requiresManualRefund: true,
        });
      }
      
      return res.json({ 
        success: true, 
        nameChange: updated, 
        message: refundSuccess ? "Richiesta rifiutata e rimborso elaborato." : "Richiesta rifiutata",
        refundInitiated: refundSuccess,
        refundId,
      });
    }
    
    // Check if payment is required and not yet paid (for approval only)
    const feeAmount = parseFloat(nameChangeRequest.fee || '0');
    if (feeAmount > 0 && nameChangeRequest.paymentStatus !== 'paid') {
      return res.status(400).json({ 
        message: `Impossibile approvare: la commissione di €${feeAmount.toFixed(2)} non è stata ancora pagata.`,
        code: "PAYMENT_REQUIRED",
        fee: feeAmount,
        paymentStatus: nameChangeRequest.paymentStatus,
      });
    }
    
    // 2. Get the original ticket with all details
    const [originalTicket] = await db.select().from(siaeTickets).where(eq(siaeTickets.id, nameChangeRequest.originalTicketId));
    if (!originalTicket) {
      return res.status(404).json({ message: "Biglietto originale non trovato" });
    }
    
    // Accept all valid ticket statuses that can be changed
    const validStatuses = ['emitted', 'active', 'valid', 'sold', 'paid'];
    if (!validStatuses.includes(originalTicket.status)) {
      console.log(`[NAME-CHANGE] Ticket status not valid for change: ${originalTicket.status}`);
      return res.status(400).json({ message: `Biglietto non modificabile (stato: ${originalTicket.status})` });
    }
    console.log(`[NAME-CHANGE] Processing name change for ticket ${originalTicket.id}, status: ${originalTicket.status}`);
    
    // 3. Get ticketed event details
    const [ticketedEvent] = await db.select().from(siaeTicketedEvents).where(eq(siaeTicketedEvents.id, originalTicket.ticketedEventId));
    if (!ticketedEvent) {
      return res.status(404).json({ message: "Evento ticketed non trovato" });
    }
    
    // 4. Get event details for email
    const [event] = await db.select().from(events).where(eq(events.id, ticketedEvent.eventId));
    
    // 5. Get sector details
    const [sector] = await db.select().from(siaeEventSectors).where(eq(siaeEventSectors.id, originalTicket.sectorId));
    
    // 6. Check bridge/smart card availability
    const bridgeStatus = getCachedBridgeStatus();
    if (!bridgeStatus.bridgeConnected || !bridgeStatus.cardInserted) {
      return res.status(503).json({ 
        message: "Lettore smart card SIAE non disponibile. Connetti il bridge desktop e inserisci la carta.",
        code: "BRIDGE_NOT_READY"
      });
    }
    
    // 7. Request fiscal seal for new ticket
    let sealData;
    try {
      const priceInCents = Math.round(Number(originalTicket.grossAmount || originalTicket.ticketPrice || 0) * 100);
      sealData = await requestFiscalSeal(priceInCents);
    } catch (sealError: any) {
      console.error('[NAME-CHANGE] Failed to get fiscal seal:', sealError);
      return res.status(503).json({
        message: "Errore nella richiesta del sigillo fiscale. Riprova.",
        code: "SEAL_REQUEST_FAILED",
        details: sealError.message
      });
    }
    
    // 8. Begin transaction: Cancel old ticket and create new one
    const result = await db.transaction(async (tx) => {
      // 8a. Annul original ticket with SIAE-compliant causale (TAB.5 code '10')
      await tx.update(siaeTickets)
        .set({
          status: 'annullato_cambio_nominativo',
          cancellationReasonCode: '10', // TAB.5: "Cambio nominativo - vecchio titolo"
          cancellationDate: new Date(),
          cancelledByUserId: userId,
          customText: `Cambio nominativo - Sigillo originale: ${originalTicket.fiscalSealCode || 'N/A'} - Nuovo: ${sealData.sealCode}`,
          updatedAt: new Date()
        })
        .where(eq(siaeTickets.id, originalTicket.id));
      
      // 8b. Get next progressive number
      const [{ maxProgress }] = await tx
        .select({ maxProgress: sql<number>`COALESCE(MAX(progressive_number), 0)` })
        .from(siaeTickets)
        .where(eq(siaeTickets.ticketedEventId, originalTicket.ticketedEventId));
      const newProgressiveNumber = (maxProgress || 0) + 1;
      
      // 8c. Generate new ticket code
      const newTicketCode = `${ticketedEvent.siaeEventCode || 'TKT'}-NC-${newProgressiveNumber.toString().padStart(6, '0')}`;
      
      // 8d. Create new ticket with new holder data
      const [newTicket] = await tx.insert(siaeTickets)
        .values({
          ticketedEventId: originalTicket.ticketedEventId,
          sectorId: originalTicket.sectorId,
          transactionId: originalTicket.transactionId,
          customerId: originalTicket.customerId,
          // Fiscal seal data
          fiscalSealCode: sealData.sealCode,
          fiscalSealCounter: sealData.counter,
          progressiveNumber: newProgressiveNumber,
          cardCode: sealData.serialNumber,
          // Dates
          emissionDate: new Date(),
          emissionDateStr: new Date().toISOString().slice(0, 10).replace(/-/g, ''),
          emissionTimeStr: new Date().toTimeString().slice(0, 5).replace(':', ''),
          // Ticket type
          ticketTypeCode: originalTicket.ticketTypeCode,
          sectorCode: originalTicket.sectorCode,
          ticketCode: newTicketCode,
          ticketType: originalTicket.ticketType,
          ticketPrice: originalTicket.ticketPrice,
          // Seat info (if numbered)
          seatId: originalTicket.seatId,
          row: originalTicket.row,
          seatNumber: originalTicket.seatNumber,
          // Prices
          grossAmount: originalTicket.grossAmount,
          netAmount: originalTicket.netAmount,
          vatAmount: originalTicket.vatAmount,
          prevendita: originalTicket.prevendita,
          prevenditaVat: originalTicket.prevenditaVat,
          // NEW HOLDER DATA
          participantFirstName: nameChangeRequest.newFirstName,
          participantLastName: nameChangeRequest.newLastName,
          // Emission info
          issuedByUserId: userId,
          isComplimentary: originalTicket.isComplimentary,
          paymentMethod: 'name_change',
          // Status - use 'sold' for consistency with admin route
          status: 'sold',
          // Reference to original
          originalTicketId: originalTicket.id,
          // QR Code
          qrCode: `SIAE-TKT-NC-${newProgressiveNumber}`
        })
        .returning();
      
      // 8e. Update original ticket with replacement reference
      await tx.update(siaeTickets)
        .set({ replacedByTicketId: newTicket.id })
        .where(eq(siaeTickets.id, originalTicket.id));
      
      // 8f. Update name change request
      const [updatedNameChange] = await tx.update(siaeNameChanges)
        .set({
          newTicketId: newTicket.id,
          status: 'completed',
          processedAt: new Date(),
          processedByUserId: userId,
          updatedAt: new Date()
        })
        .where(eq(siaeNameChanges.id, req.params.id))
        .returning();
      
      return { newTicket, updatedNameChange };
    });
    
    // 9. Send email to new holder (async, don't block response)
    if (nameChangeRequest.newEmail && event) {
      try {
        const { sendTicketEmail } = await import('./email-service');
        const { generateDigitalTicketPdf } = await import('./pdf-service');
        
        // Fetch template for the company (if available)
        const template = await storage.getDefaultDigitalTicketTemplate(ticketedEvent.companyId || undefined);
        
        const ticketData = {
          eventName: event.name,
          eventDate: event.startDatetime,
          locationName: event.locationId || 'N/A',
          sectorName: sector?.name || 'N/A',
          holderName: `${nameChangeRequest.newFirstName} ${nameChangeRequest.newLastName}`,
          price: String(originalTicket.grossAmount || originalTicket.ticketPrice || '0'),
          ticketCode: result.newTicket.ticketCode || '',
          qrCode: result.newTicket.qrCode || `SIAE-TKT-NC-${result.newTicket.id}`,
          fiscalSealCode: sealData.sealCode
        };
        
        const pdfBuffer = await generateDigitalTicketPdf(ticketData, template);
        
        // Simple HTML for email body
        const ticketHtml = `
          <div style="border:1px solid #ddd; padding:20px; border-radius:8px;">
            <h2 style="color:#6366f1;">Biglietto - ${ticketData.eventName}</h2>
            <p><strong>Intestatario:</strong> ${ticketData.holderName}</p>
            <p><strong>Settore:</strong> ${ticketData.sectorName}</p>
            <p><strong>Codice:</strong> ${ticketData.ticketCode}</p>
            <p><strong>Sigillo SIAE:</strong> ${ticketData.fiscalSealCode}</p>
            <p style="color:#666; font-size:12px;">Il biglietto PDF è allegato a questa email.</p>
          </div>
        `;
        
        await sendTicketEmail({
          to: nameChangeRequest.newEmail,
          subject: `Cambio Nominativo Completato - ${event.name}`,
          eventName: event.name,
          tickets: [{ id: result.newTicket.id, html: ticketHtml }],
          pdfBuffers: [pdfBuffer]
        });
        
        console.log(`[NAME-CHANGE] Email sent to new holder: ${nameChangeRequest.newEmail}`);
      } catch (emailError) {
        console.error('[NAME-CHANGE] Failed to send email:', emailError);
        // Don't fail the request, email is not critical
      }
    }
    
    // 10. Create audit log
    await siaeStorage.createAuditLog({
      companyId: ticketedEvent.companyId,
      userId,
      action: 'name_change_completed',
      entityType: 'ticket',
      entityId: result.newTicket.id,
      description: `Completato: ${originalTicket.participantFirstName} ${originalTicket.participantLastName} -> ${nameChangeRequest.newFirstName} ${nameChangeRequest.newLastName}, seal=${sealData.sealCode}`
    });
    
    res.json({
      success: true,
      message: "Cambio nominativo completato con successo",
      nameChange: result.updatedNameChange,
      newTicket: result.newTicket,
      oldTicketId: originalTicket.id
    });
    
  } catch (error: any) {
    console.error('[NAME-CHANGE] Process error:', error);
    res.status(500).json({ message: error.message || "Errore durante il processamento del cambio nominativo" });
  }
});

// ==================== Resales (Customer) ====================

// GET all resales for super_admin (global view with company info)
router.get("/api/siae/resales/all", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = (req as any).user;
    if (user?.role !== 'super_admin') {
      return res.status(403).json({ message: "Accesso riservato a super admin" });
    }
    
    // Get all resales with company and event info
    const allResales = await db
      .select({
        resale: siaeResales,
        companyId: siaeTicketedEvents.companyId,
        companyName: companies.name,
        eventName: events.name,
        eventDate: events.startDatetime,
        ticketCode: siaeTickets.ticketCode,
        sectorName: siaeEventSectors.name,
      })
      .from(siaeResales)
      .innerJoin(siaeTickets, eq(siaeResales.originalTicketId, siaeTickets.id))
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id))
      .innerJoin(companies, eq(siaeTicketedEvents.companyId, companies.id))
      .leftJoin(siaeEventSectors, eq(siaeTickets.sectorId, siaeEventSectors.id))
      .orderBy(desc(siaeResales.listedAt));
    
    // Flatten result
    const result = allResales.map(r => ({
      ...r.resale,
      companyId: r.companyId,
      companyName: r.companyName,
      eventName: r.eventName,
      eventDate: r.eventDate,
      ticketCode: r.ticketCode,
      sectorName: r.sectorName,
    }));
    
    res.json(result);
  } catch (error: any) {
    console.error('[SIAE] Get all resales error:', error);
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/companies/:companyId/resales", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const resales = await siaeStorage.getSiaeResalesByCompany(req.params.companyId);
    res.json(resales);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/resales/available", async (req: Request, res: Response) => {
  try {
    const resales = await siaeStorage.getAvailableSiaeResales();
    res.json(resales);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/ticketed-events/:eventId/resales", async (req: Request, res: Response) => {
  try {
    const resales = await siaeStorage.getSiaeResalesByEvent(req.params.eventId);
    res.json(resales);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/ticketed-events/:eventId/name-changes", async (req: Request, res: Response) => {
  try {
    const changes = await siaeStorage.getSiaeNameChangesByEvent(req.params.eventId);
    res.json(changes);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/resales", requireAuth, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeResaleSchema.parse(req.body);
    
    // === VALIDAZIONE ALLEGATO B - NORMATIVA 2025 ===
    // NOTA OPERATIVA: L'acquirente non è noto al momento della messa in vendita.
    // L'identità acquirente viene verificata al momento del completamento (PATCH con status=completed).
    // Questo flusso rispetta l'Allegato B che prevede:
    // - Venditore: identificato alla messa in vendita
    // - Acquirente: identificato al momento dell'acquisto
    
    // 1. Causale rivendita obbligatoria e valida
    const causaliValide = ['IMP', 'VOL', 'ALT'] as const; // IMP=Impossibilità, VOL=Volontaria, ALT=Altro
    if (!data.causaleRivendita || !causaliValide.includes(data.causaleRivendita as any)) {
      return res.status(400).json({ 
        message: "Causale rivendita obbligatoria (IMP=Impossibilità, VOL=Volontaria, ALT=Altro)",
        code: "ALLEGATO_B_CAUSALE_MANCANTE"
      });
    }
    
    // 2. Se causale=ALT, dettaglio obbligatorio
    if (data.causaleRivendita === 'ALT' && !data.causaleDettaglio) {
      return res.status(400).json({ 
        message: "Per causale ALT è obbligatorio specificare il dettaglio",
        code: "ALLEGATO_B_DETTAGLIO_MANCANTE"
      });
    }
    
    // 3. Controllo prezzo massimo (Art. 1 comma 545 L. 232/2016): non può superare prezzo originale
    if (data.newPrice && data.originalPrice) {
      const prezzoOriginale = Number(data.originalPrice);
      const prezzoNuovo = Number(data.newPrice);
      if (prezzoNuovo > prezzoOriginale) {
        return res.status(400).json({ 
          message: `Prezzo rivendita (€${prezzoNuovo.toFixed(2)}) non può superare il prezzo originale (€${prezzoOriginale.toFixed(2)}) - Art. 1 comma 545 L. 232/2016`,
          code: "ALLEGATO_B_PREZZO_MASSIMO_SUPERATO"
        });
      }
    }
    
    // 4. ALLEGATO B: Verifica identità venditore obbligatoria
    // Se identitaVenditoreVerificata è false o assente, blocca (normativa anti-bagarinaggio)
    if (!data.identitaVenditoreVerificata) {
      return res.status(400).json({ 
        message: "Verifica identità venditore obbligatoria per Allegato B. Inserire documento di identità.",
        code: "ALLEGATO_B_IDENTITA_VENDITORE_MANCANTE"
      });
    }
    
    // 5. Documento venditore obbligatorio se identità verificata
    if (!data.venditoreDocumentoTipo || !data.venditoreDocumentoNumero) {
      return res.status(400).json({ 
        message: "Tipo e numero documento venditore obbligatori per Allegato B.",
        code: "ALLEGATO_B_DOCUMENTO_VENDITORE_MANCANTE"
      });
    }
    
    // Imposta flags di controllo
    const dataWithControls = {
      ...data,
      controlloPrezzoMassimoEseguito: true,
      controlloPrezzoMassimoSuperato: false,
      controlloPrezzoMassimoData: new Date(),
      identitaVenditoreVerificataData: new Date(),
    };
    
    const resale = await siaeStorage.createSiaeResale(dataWithControls);
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: resale.companyId || user.companyId,
      userId: user.id,
      action: 'resale_created',
      entityType: 'resale',
      entityId: resale.id,
      description: `Rimessa in vendita creata per biglietto ${resale.originalTicketId}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.status(201).json(resale);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/resales/:id", requireAuth, async (req: Request, res: Response) => {
  try {
    const data = patchResaleSchema.parse(req.body);
    
    // Recupera la resale esistente per validazione
    const existingResale = await siaeStorage.getSiaeResale(req.params.id);
    if (!existingResale) {
      return res.status(404).json({ message: "Rimessa in vendita non trovata" });
    }
    
    // === VALIDAZIONE ALLEGATO B - NORMATIVA 2025 (COMPLETA) ===
    
    // 1. Controllo prezzo massimo se viene aggiornato il prezzo
    if (data.newPrice !== undefined) {
      const prezzoOriginale = Number(existingResale.originalPrice || data.originalPrice || 0);
      const prezzoNuovo = Number(data.newPrice);
      if (prezzoNuovo > prezzoOriginale && prezzoOriginale > 0) {
        return res.status(400).json({ 
          message: `Prezzo rivendita (€${prezzoNuovo.toFixed(2)}) non può superare il prezzo originale (€${prezzoOriginale.toFixed(2)}) - Art. 1 comma 545 L. 232/2016`,
          code: "ALLEGATO_B_PREZZO_MASSIMO_SUPERATO"
        });
      }
    }
    
    // 2. Se causale viene cambiata a ALT, verifica dettaglio
    const causaleFinale = data.causaleRivendita || existingResale.causaleRivendita;
    const dettaglioFinale = data.causaleDettaglio || existingResale.causaleDettaglio;
    if (causaleFinale === 'ALT' && !dettaglioFinale) {
      return res.status(400).json({ 
        message: "Per causale ALT è obbligatorio specificare il dettaglio",
        code: "ALLEGATO_B_DETTAGLIO_MANCANTE"
      });
    }
    
    // 3. Se stato cambia a 'completed' o 'approved', verifica identità acquirente
    if (data.status === 'completed' || data.status === 'approved') {
      const identitaAcquirente = data.identitaAcquirenteVerificata ?? existingResale.identitaAcquirenteVerificata;
      const docTipo = data.acquirenteDocumentoTipo || existingResale.acquirenteDocumentoTipo;
      const docNumero = data.acquirenteDocumentoNumero || existingResale.acquirenteDocumentoNumero;
      
      if (!identitaAcquirente) {
        return res.status(400).json({ 
          message: "Per completare la rivendita è obbligatoria la verifica identità acquirente (Allegato B).",
          code: "ALLEGATO_B_IDENTITA_ACQUIRENTE_MANCANTE"
        });
      }
      
      if (!docTipo || !docNumero) {
        return res.status(400).json({ 
          message: "Tipo e numero documento acquirente obbligatori per completare la rivendita (Allegato B).",
          code: "ALLEGATO_B_DOCUMENTO_ACQUIRENTE_MANCANTE"
        });
      }
    }
    
    // 4. Verifica che identità venditore sia sempre presente (non può essere rimossa)
    const identitaVenditoreFinale = data.identitaVenditoreVerificata ?? existingResale.identitaVenditoreVerificata;
    if (!identitaVenditoreFinale) {
      return res.status(400).json({ 
        message: "La verifica identità venditore è obbligatoria e non può essere rimossa (Allegato B).",
        code: "ALLEGATO_B_IDENTITA_VENDITORE_MANCANTE"
      });
    }
    
    // 5. Impedire la rimozione di dati di verifica già impostati (immutabilità Allegato B)
    if (existingResale.identitaVenditoreVerificata === true && data.identitaVenditoreVerificata === false) {
      return res.status(400).json({ 
        message: "La verifica identità venditore non può essere annullata una volta confermata (Allegato B).",
        code: "ALLEGATO_B_MODIFICA_NON_CONSENTITA"
      });
    }
    if (existingResale.identitaAcquirenteVerificata === true && data.identitaAcquirenteVerificata === false) {
      return res.status(400).json({ 
        message: "La verifica identità acquirente non può essere annullata una volta confermata (Allegato B).",
        code: "ALLEGATO_B_MODIFICA_NON_CONSENTITA"
      });
    }
    
    // 6. Non permettere rimozione documenti venditore già registrati
    if (existingResale.venditoreDocumentoNumero && data.venditoreDocumentoNumero === null) {
      return res.status(400).json({ 
        message: "Il documento venditore non può essere rimosso una volta registrato (Allegato B).",
        code: "ALLEGATO_B_MODIFICA_NON_CONSENTITA"
      });
    }
    
    // 7. Controllo prezzo massimo su ogni modifica prezzo (non solo nuovo)
    const prezzoNuovoFinale = data.newPrice !== undefined ? Number(data.newPrice) : null;
    const prezzoOriginaleFinale = Number(existingResale.originalPrice || 0);
    if (prezzoNuovoFinale !== null && prezzoOriginaleFinale > 0 && prezzoNuovoFinale > prezzoOriginaleFinale) {
      return res.status(400).json({ 
        message: `Prezzo rivendita (€${prezzoNuovoFinale.toFixed(2)}) non può superare il prezzo originale (€${prezzoOriginaleFinale.toFixed(2)}) - Art. 1 comma 545 L. 232/2016`,
        code: "ALLEGATO_B_PREZZO_MASSIMO_SUPERATO"
      });
    }
    
    // Imposta timestamp controlli se identità acquirente verificata ora
    const dataWithTimestamps = { ...data };
    if (data.identitaAcquirenteVerificata && !existingResale.identitaAcquirenteVerificata) {
      (dataWithTimestamps as any).identitaAcquirenteVerificataData = new Date();
    }
    
    const resale = await siaeStorage.updateSiaeResale(req.params.id, dataWithTimestamps);
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: resale?.companyId || user.companyId,
      userId: user.id,
      action: 'resale_updated',
      entityType: 'resale',
      entityId: req.params.id,
      description: `Rimessa in vendita aggiornata${data.status ? ` (status: ${data.status})` : ''}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json(resale);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// ==================== Logs (Super Admin / Gestore) ====================

router.get("/api/siae/companies/:companyId/logs", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const limit = parseInt(req.query.limit as string) || 100;
    const logs = await siaeStorage.getSiaeLogs(req.params.companyId, limit);
    res.json(logs);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Transmissions (Gestore) ====================

router.get("/api/siae/companies/:companyId/transmissions", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const transmissions = await siaeStorage.getSiaeTransmissionsByCompany(req.params.companyId);
    res.json(transmissions);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Get SIAE ticketed events for RCA report selection
// Returns only approved events (for RCA, only approved events can be transmitted)
router.get("/api/siae/companies/:companyId/ticketed-events", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { companyId } = req.params;
    const ticketedEvents = await siaeStorage.getSiaeTicketedEventsByCompany(companyId);
    
    // The getSiaeTicketedEventsByCompany function already includes eventName, eventDate, ticketingStatus
    // Filter to only show approved events (RCA requires SIAE-approved events)
    // Return 'closed' status if EITHER ticketingStatus OR event.status is closed
    const filteredEvents = ticketedEvents
      .filter(te => te.approvalStatus === 'approved')
      .map(te => {
        // Consider event closed if either ticketingStatus or base event status is closed
        const isClosed = te.ticketingStatus === 'closed' || te.status === 'closed';
        return {
          id: te.id,
          eventId: te.eventId,
          eventName: te.eventName || 'Evento sconosciuto',
          eventDate: te.eventDate || te.createdAt,
          status: isClosed ? 'closed' : te.ticketingStatus, // Show as closed if either is closed
        };
      });
    
    // Sort by event date descending (most recent first)
    filteredEvents.sort((a, b) => new Date(b.eventDate).getTime() - new Date(a.eventDate).getTime());
    
    res.json(filteredEvents);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Transmission Settings API (Global Singleton) ====================

// Get global transmission settings
router.get("/api/siae/transmission-settings", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const settings = await siaeStorage.getOrCreateGlobalSiaeTransmissionSettings();
    res.json(settings);
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to get transmission settings:', error);
    res.status(500).json({ message: error.message });
  }
});

// Update global transmission settings
router.put("/api/siae/transmission-settings", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    // Ensure settings exist first
    await siaeStorage.getOrCreateGlobalSiaeTransmissionSettings();
    
    // Update with provided values
    const settings = await siaeStorage.updateGlobalSiaeTransmissionSettings(req.body);
    
    if (!settings) {
      return res.status(404).json({ message: "Impostazioni non trovate" });
    }
    
    res.json(settings);
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to update transmission settings:', error);
    res.status(400).json({ message: error.message });
  }
});

// Get transmissions filtered by organizer and optionally by event
router.get("/api/siae/transmissions-list", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const companyId = req.query.companyId as string || user?.companyId;
    const ticketedEventId = req.query.ticketedEventId as string;
    
    if (!companyId) {
      return res.status(400).json({ message: "Company ID richiesto" });
    }
    
    let transmissions;
    if (ticketedEventId) {
      transmissions = await siaeStorage.getSiaeTransmissionsByTicketedEvent(ticketedEventId);
    } else {
      transmissions = await siaeStorage.getSiaeTransmissionsByCompany(companyId);
    }
    
    // Enrich with event info
    const enrichedTransmissions = await Promise.all(transmissions.map(async (t) => {
      let eventName = 'N/D';
      let eventDate = null;
      if (t.ticketedEventId) {
        const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(t.ticketedEventId);
        if (ticketedEvent) {
          const event = await storage.getEvent(ticketedEvent.eventId);
          eventName = event?.name || ticketedEvent.eventTitle || 'Evento sconosciuto';
          eventDate = event?.startDatetime || ticketedEvent.createdAt;
        }
      }
      return {
        ...t,
        eventName,
        eventDate,
      };
    }));
    
    res.json(enrichedTransmissions);
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to get transmissions list:', error);
    res.status(500).json({ message: error.message });
  }
});

// Resend transmission with Sostituzione="S"
router.post("/api/siae/transmissions/:id/resend", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { toEmail } = req.body;
    
    // Get original transmission
    const original = await siaeStorage.getSiaeTransmission(id);
    if (!original) {
      return res.status(404).json({ message: "Trasmissione originale non trovata" });
    }
    
    if (!original.ticketedEventId) {
      return res.status(400).json({ message: "Trasmissione senza evento associato" });
    }
    
    // Count existing transmissions for this event to get next progressivo
    const existingTransmissions = await siaeStorage.getSiaeTransmissionsByTicketedEvent(original.ticketedEventId);
    const sameTypeTransmissions = existingTransmissions.filter(t => 
      t.transmissionType === original.transmissionType
    );
    const nextProgressivo = sameTypeTransmissions.length + 1;
    
    // Get event and company data for XML regeneration
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(original.ticketedEventId);
    if (!ticketedEvent) {
      return res.status(400).json({ message: "Evento SIAE non trovato" });
    }
    
    const company = await storage.getCompany(original.companyId);
    const baseEvent = await storage.getEvent(ticketedEvent.eventId);
    const allTickets = await siaeStorage.getSiaeTicketsByCompany(original.companyId);
    const eventTickets = allTickets.filter(t => t.ticketedEventId === original.ticketedEventId);
    const systemConfig = await siaeStorage.getSiaeSystemConfig(original.companyId);
    const activationCards = await siaeStorage.getSiaeActivationCardsByCompany(original.companyId);
    const activeCard = activationCards.find(c => c.status === 'active');
    const taxId = systemConfig?.taxId || company?.fiscalCode || company?.taxId || '';
    
    // FIX 2026-01-17: Per reinvio RCA (S/MIME), il codice DEVE provenire dalla Smart Card
    const resendCachedEfff = getCachedEfffData();
    const resendIsRca = original.transmissionType === 'rca';
    let resendResolvedSystemCode: string;
    
    // FIX 2026-01-18: TUTTI i report sono firmati S/MIME, usa resolveSystemCodeForSmime
    const smimeResult = resolveSystemCodeForSmime(resendCachedEfff, systemConfig ? { systemCode: systemConfig.systemCode ?? undefined } : null);
    if (!smimeResult.success || !smimeResult.systemCode) {
      console.error(`[SIAE-ROUTES] Resend BLOCCO ${original.transmissionType}: ${smimeResult.error}`);
      return res.status(400).json({
        message: smimeResult.error || 'Smart Card richiesta per reinvio trasmissioni S/MIME',
        code: 'SMARTCARD_REQUIRED_FOR_SMIME'
      });
    }
    resendResolvedSystemCode = smimeResult.systemCode;
    if (smimeResult.warning) {
      console.warn(`[SIAE-ROUTES] Resend ${original.transmissionType} Warning: ${smimeResult.warning}`);
    }
    console.log(`[SIAE-ROUTES] Resend: ${original.transmissionType} systemCode from ${smimeResult.source}: ${resendResolvedSystemCode}`);
    
    // FIX 2026-01-18: Import correct generators based on transmission type
    const { generateRCAXml, generateC1Xml } = await import('./siae-utils');
    
    // Map transmissionType to filename type and validation type
    const getFilenameType = (tt: string): 'rca' | 'mensile' | 'giornaliero' => {
      if (tt === 'monthly') return 'mensile';
      if (tt === 'daily') return 'giornaliero';
      return 'rca';
    };
    const filenameType = getFilenameType(original.transmissionType);
    
    // Variables for XML result
    let generatedXml: string;
    let resendTicketsCount: number;
    let resendTotalAmount: number;
    let resendCancelledCount: number = 0;
    
    if (original.transmissionType === 'rca') {
      // RCA: Use generateRCAXml
      const eventForLog = {
        id: ticketedEvent.id,
        name: baseEvent?.name || 'Evento',
        date: baseEvent?.startDatetime || new Date(),
        time: baseEvent?.startDatetime || null,
        venueCode: ticketedEvent.siaeLocationCode || '0000000000001',
        genreCode: ticketedEvent.genreCode || 'S1',
        organizerTaxId: taxId,
        organizerName: company?.name || 'N/D',
        tipoTassazione: (ticketedEvent.taxType as 'S' | 'I') || 'S',
        ivaPreassolta: (ticketedEvent.ivaPreassolta as 'N' | 'B' | 'F') || 'N',
      };
      
      const ticketsForRca = eventTickets.map(ticket => ({
        id: ticket.id,
        fiscalSealCode: ticket.fiscalSealCode || null,
        progressiveNumber: ticket.progressiveNumber || 1,
        cardCode: ticket.cardCode || null,
        emissionChannelCode: ticket.emissionChannelCode || null,
        emissionDate: ticket.emissionDate ? new Date(ticket.emissionDate) : new Date(),
        ticketTypeCode: ticket.ticketTypeCode || 'R1',
        sectorCode: ticket.sectorCode || 'A0',
        grossAmount: ticket.grossAmount || '0',
        netAmount: ticket.netAmount || null,
        vatAmount: ticket.vatAmount || null,
        prevendita: ticket.prevendita || '0',
        prevenditaVat: ticket.prevenditaVat || null,
        status: ticket.status || 'emitted',
        cancellationReasonCode: ticket.cancellationReasonCode || null,
        cancellationDate: ticket.cancellationDate || null,
      }));
      
      const rcaResult = generateRCAXml({
        companyId: original.companyId,
        eventId: ticketedEvent.eventId,
        event: eventForLog,
        tickets: ticketsForRca,
        systemConfig: { systemCode: resendResolvedSystemCode ?? undefined },
        companyName: company?.name || 'N/D',
        taxId,
        progressivo: nextProgressivo,
        forceSubstitution: true
      });
      
      generatedXml = rcaResult.xml;
      resendTicketsCount = rcaResult.ticketCount;
      resendTotalAmount = rcaResult.totalGrossAmount;
      resendCancelledCount = rcaResult.cancelledCount;
    } else {
      // Monthly (RPM) or Daily (RMG): Use generateC1Xml with hydrateC1EventContextFromTickets
      const isMonthly = original.transmissionType === 'monthly';
      const reportDate = new Date(original.periodDate);
      
      const hydratedData = await hydrateC1EventContextFromTickets(
        eventTickets,
        original.companyId,
        reportDate,
        isMonthly
      );
      
      // FIX 2026-01-18: Per report giornaliero (RMG), 0 biglietti è permesso
      // Per report mensile (RPM), rimane un errore bloccante
      if (hydratedData.events.length === 0 && hydratedData.subscriptions.length === 0) {
        if (isMonthly) {
          return res.status(400).json({
            message: 'SIAE_NO_EVENTS: Nessun biglietto o abbonamento trovato per il periodo richiesto.',
            code: 'NO_DATA_FOR_PERIOD'
          });
        }
        console.warn('[SIAE-ROUTES] Report giornaliero (resend) senza eventi/abbonamenti - generazione consentita');
      }
      
      const c1Result = generateC1Xml({
        reportKind: isMonthly ? 'mensile' : 'giornaliero',
        companyId: original.companyId,
        reportDate,
        resolvedSystemCode: resendResolvedSystemCode,
        progressivo: nextProgressivo, // progressivo > 1 forces Sostituzione="S"
        taxId,
        businessName: company?.name || 'N/D',
        events: hydratedData.events,
        subscriptions: hydratedData.subscriptions,
      });
      
      generatedXml = c1Result.xml;
      resendTicketsCount = c1Result.stats.ticketsCount;
      resendTotalAmount = c1Result.stats.totalRevenue;
      resendCancelledCount = 0; // C1 doesn't track cancelled separately in result
    }
    
    // FIX 2026-01-18: Validazione DTD pre-trasmissione obbligatoria per tutti i flussi
    const resendPreValidation = await validatePreTransmission(
      generatedXml,
      resendResolvedSystemCode,
      filenameType,
      new Date(original.periodDate)
    );
    if (!resendPreValidation.canTransmit) {
      console.error(`[SIAE-ROUTES] Resend DTD validation failed: ${resendPreValidation.errors.map(e => `[${e.siaeErrorCode || 'ERR'}] ${e.message}`).join('; ')}`);
      return res.status(400).json({
        success: false,
        error: 'Validazione pre-trasmissione fallita',
        errors: resendPreValidation.errors,
        warnings: resendPreValidation.warnings,
        code: 'DTD_VALIDATION_FAILED'
      });
    }
    if (resendPreValidation.warnings.length > 0) {
      console.warn(`[SIAE-ROUTES] Resend DTD warnings: ${resendPreValidation.warnings.map(w => w.message).join('; ')}`);
    }
    
    // Calculate transmission statistics
    const resendStats = await calculateTransmissionStats(
      eventTickets,
      original.companyId,
      original.ticketedEventId,
      ticketedEvent.tipoTassazione,
      ticketedEvent.entertainmentIncidence
    );
    const resendFileHash = calculateFileHash(generatedXml);
    
    // FIX 2026-01-18: Use correct filename type based on transmissionType
    const resendFileName = generateSiaeAttachmentName(filenameType, new Date(original.periodDate), nextProgressivo, null, resendResolvedSystemCode);
    
    // Create new transmission with substitution flag
    const newTransmission = await siaeStorage.createSiaeTransmission({
      companyId: original.companyId,
      ticketedEventId: original.ticketedEventId,
      transmissionType: original.transmissionType,
      periodDate: original.periodDate,
      scheduleType: 'manual',
      isSubstitution: true,
      originalTransmissionId: original.id,
      progressivoInvio: nextProgressivo,
      fileName: resendFileName.replace(/\.xsi(\.p7m)?$/, ''),
      fileExtension: '.xsi',
      fileContent: generatedXml,
      status: 'pending',
      ticketsCount: resendTicketsCount,
      ticketsCancelled: resendCancelledCount,
      totalAmount: resendTotalAmount.toFixed(2),
      systemCode: resendResolvedSystemCode,
      fileHash: resendFileHash,
      totalIva: resendStats.totalIva.toFixed(2),
      totalEsenti: resendStats.totalEsenti.toFixed(2),
      totalImpostaIntrattenimento: resendStats.totalImpostaIntrattenimento.toFixed(2),
      cfOrganizzatore: systemConfig?.taxId || '',
      ticketsChanged: resendStats.ticketsChanged,
      ticketsResold: resendStats.ticketsResold,
    });
    
    console.log(`[SIAE-ROUTES] Created substitution transmission ${newTransmission.id} (progressivo: ${nextProgressivo}) for original ${id}`);
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: newTransmission.companyId,
      userId: user.id,
      action: 'transmission_resent',
      entityType: 'transmission',
      entityId: newTransmission.id,
      description: `Trasmissione sostitutiva creata (progressivo: ${nextProgressivo}) per originale ${id}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    // If toEmail provided, send immediately
    if (toEmail) {
      const { sendSiaeTransmissionEmail } = await import('./email-service');
      
      // FIX 2026-01-18: Use correct validation type based on transmissionType
      const preValidation = await validatePreTransmission(
        generatedXml,
        resendResolvedSystemCode,
        filenameType, // FIX: Use mapped type (rca/mensile/giornaliero)
        original.periodDate
      );
      
      if (!preValidation.canTransmit) {
        await siaeStorage.updateSiaeTransmission(newTransmission.id, {
          status: 'error',
          errorMessage: preValidation.errors.map(e => `[${e.siaeErrorCode || 'ERR'}] ${e.message}`).join('; '),
        });
        return res.status(400).json({
          success: false,
          error: 'Validazione pre-trasmissione fallita',
          errors: preValidation.errors,
          warnings: preValidation.warnings,
          details: preValidation.details
        });
      }
      
      await sendSiaeTransmissionEmail({
        to: toEmail,
        companyName: company?.name || 'N/A',
        transmissionType: original.transmissionType as "monthly" | "daily" | "rca" | "corrective",
        periodDate: original.periodDate,
        ticketsCount: resendTicketsCount, // FIX 2026-01-18: Use unified variable
        totalAmount: resendTotalAmount.toFixed(2), // FIX 2026-01-18: Use unified variable
        xmlContent: generatedXml, // FIX 2026-01-18: Use unified variable
        transmissionId: newTransmission.id,
        systemCode: resendResolvedSystemCode,
        sequenceNumber: nextProgressivo,
        signWithSmime: true,
        requireSignature: true,
      });
      
      await siaeStorage.updateSiaeTransmission(newTransmission.id, {
        status: 'sent',
        sentAt: new Date(),
        sentToPec: toEmail,
      });
      
      console.log(`[SIAE-ROUTES] Sent substitution transmission to ${toEmail}`);
    }
    
    res.status(201).json({
      message: `Trasmissione sostitutiva creata con progressivo ${nextProgressivo}`,
      transmission: newTransmission,
      sent: !!toEmail,
    });
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to resend transmission:', error);
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/transmissions", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeTransmissionSchema.parse(req.body);
    
    // FIX 2026-01-17: Validazione coerenza systemCode per prevenire errori SIAE 0600/0603
    // Per RCA, il codice DEVE provenire dalla Smart Card
    if (data.fileContent && typeof data.fileContent === 'string') {
      const systemConfig = await siaeStorage.getSiaeSystemConfig(data.companyId);
      const postCachedEfff = getCachedEfffData();
      const postIsRca = data.transmissionType === 'rca';
      let postResolvedSystemCode: string;
      
      // FIX 2026-01-18: TUTTI i report sono firmati S/MIME, usa resolveSystemCodeForSmime
      const smimeResult = resolveSystemCodeForSmime(postCachedEfff, systemConfig ? { systemCode: systemConfig.systemCode ?? undefined } : null);
      if (!smimeResult.success || !smimeResult.systemCode) {
        console.error(`[SIAE-ROUTES] POST BLOCCO ${data.transmissionType}: ${smimeResult.error}`);
        return res.status(400).json({
          message: smimeResult.error || 'Smart Card richiesta per trasmissioni S/MIME',
          code: 'SMARTCARD_REQUIRED_FOR_SMIME'
        });
      }
      postResolvedSystemCode = smimeResult.systemCode;
      
      const systemCodeValidation = validateSystemCodeConsistency(data.fileContent, postResolvedSystemCode);
      if (!systemCodeValidation.valid) {
        console.error(`[SIAE-ROUTES] POST transmissions: ${systemCodeValidation.error}`);
        return res.status(400).json({
          message: "System code is required for transmission creation",
          error: systemCodeValidation.error,
          xmlSystemCode: systemCodeValidation.xmlSystemCode,
          expectedSystemCode: systemCodeValidation.filenameSystemCode,
          code: "SYSTEM_CODE_MISMATCH"
        });
      }
      console.log(`[SIAE-ROUTES] POST transmissions: SystemCode validated - XML=${systemCodeValidation.xmlSystemCode}, expected=${postResolvedSystemCode}`);
      
      // FIX 2026-01-18: Validazione DTD pre-trasmissione obbligatoria
      const postReportType: 'giornaliero' | 'mensile' | 'rca' = data.transmissionType === 'rca' ? 'rca' : (data.transmissionType === 'monthly' ? 'mensile' : 'giornaliero');
      const postPreValidation = await validatePreTransmission(
        data.fileContent,
        postResolvedSystemCode,
        postReportType,
        data.periodDate ? new Date(data.periodDate) : new Date()
      );
      if (!postPreValidation.canTransmit) {
        console.error(`[SIAE-ROUTES] POST DTD validation failed: ${postPreValidation.errors.map(e => `[${e.siaeErrorCode || 'ERR'}] ${e.message}`).join('; ')}`);
        return res.status(400).json({
          success: false,
          error: 'Validazione pre-trasmissione fallita',
          errors: postPreValidation.errors,
          warnings: postPreValidation.warnings,
          code: 'DTD_VALIDATION_FAILED'
        });
      }
      if (postPreValidation.warnings.length > 0) {
        console.warn(`[SIAE-ROUTES] POST DTD warnings: ${postPreValidation.warnings.map(w => w.message).join('; ')}`);
      }
    }
    
    const transmission = await siaeStorage.createSiaeTransmission(data);
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: transmission.companyId,
      userId: user.id,
      action: 'transmission_created',
      entityType: 'transmission',
      entityId: transmission.id,
      description: `Trasmissione creata: ${transmission.transmissionType || 'RCA'} - ${transmission.fileName || 'N/D'}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.status(201).json(transmission);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/transmissions/:id", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const data = patchTransmissionSchema.parse(req.body);
    const transmission = await siaeStorage.updateSiaeTransmission(req.params.id, data);
    if (!transmission) {
      return res.status(404).json({ message: "Trasmissione non trovata" });
    }
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: transmission.companyId,
      userId: user.id,
      action: 'transmission_updated',
      entityType: 'transmission',
      entityId: transmission.id,
      description: `Trasmissione aggiornata: ${transmission.transmissionType || 'RCA'}${data.status ? ` (status: ${data.status})` : ''}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json(transmission);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// Send XML transmission via email (with optional digital signature)
router.post("/api/siae/transmissions/:id/send-email", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { toEmail } = req.body;
    
    // Get the transmission
    const transmissions = await siaeStorage.getSiaeTransmissionsByCompany(req.body.companyId || '');
    const transmission = transmissions.find(t => t.id === id);
    
    if (!transmission) {
      return res.status(404).json({ message: "Trasmissione non trovata" });
    }
    
    if (!transmission.fileContent) {
      return res.status(400).json({ message: "Trasmissione senza contenuto XML" });
    }
    
    // Get company name
    const company = await storage.getCompany(transmission.companyId);
    const companyName = company?.name || 'N/A';
    
    // FIX 2026-01-17: Per RCA (S/MIME), il systemCode DEVE provenire dalla Smart Card
    const systemConfig = await siaeStorage.getSiaeSystemConfig(transmission.companyId);
    let resolvedSystemCodeForEmail: string;
    const isRcaTransmission = transmission.transmissionType === 'rca';
    
    if (transmission.systemCode && transmission.systemCode.length === 8) {
      // Usa il systemCode salvato nella trasmissione (preferito per coerenza con XML esistente)
      resolvedSystemCodeForEmail = transmission.systemCode;
      console.log(`[SIAE-ROUTES] SendEmail: Using SAVED systemCode=${resolvedSystemCodeForEmail} from transmission record`);
    } else {
      // FIX 2026-01-18: TUTTI i report sono firmati S/MIME, DEVE usare Smart Card
      const sendEmailCachedEfff = getCachedEfffData();
      const smimeResult = resolveSystemCodeForSmime(sendEmailCachedEfff, systemConfig ? { systemCode: systemConfig.systemCode ?? undefined } : null);
      if (!smimeResult.success || !smimeResult.systemCode) {
        console.error(`[SIAE-ROUTES] SendEmail BLOCCO ${transmission.transmissionType}: ${smimeResult.error}`);
        return res.status(400).json({
          message: smimeResult.error || 'Smart Card richiesta per trasmissioni S/MIME',
          code: 'SMARTCARD_REQUIRED_FOR_SMIME'
        });
      }
      resolvedSystemCodeForEmail = smimeResult.systemCode;
      if (smimeResult.warning) {
        console.warn(`[SIAE-ROUTES] SendEmail ${transmission.transmissionType} Warning: ${smimeResult.warning}`);
      }
      console.log(`[SIAE-ROUTES] SendEmail: ${transmission.transmissionType} systemCode from ${smimeResult.source}: ${resolvedSystemCodeForEmail}`);
    }
    
    // CRITICAL FIX: Rigenera SEMPRE l'XML obbligatoriamente per garantire formato corretto
    // LogTransazione causa errore SIAE 40605 "Il riepilogo risulta illegibile"
    let xmlContent = transmission.fileContent;
    let regeneratedXml = false;
    
    // RIGENERAZIONE OBBLIGATORIA: Se abbiamo eventId, rigenera SEMPRE l'XML
    if (transmission.ticketedEventId) {
      console.log(`[SIAE-ROUTES] RIGENERAZIONE OBBLIGATORIA XML per trasmissione ${id}...`);
      console.log(`[SIAE-ROUTES] Transmission type: ${transmission.transmissionType}, eventId: ${transmission.ticketedEventId}`);
        
        // Rigenerazione XML RCA
        try {
          const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(transmission.ticketedEventId);
          if (!ticketedEvent) {
            return res.status(400).json({ message: "Evento SIAE non trovato per rigenerazione XML" });
          }
          
          const baseEvent = await storage.getEvent(ticketedEvent.eventId);
          const allTickets = await siaeStorage.getSiaeTicketsByCompany(transmission.companyId);
          const eventTickets = allTickets.filter(t => t.ticketedEventId === transmission.ticketedEventId);
          // systemConfig già recuperato sopra
          const activationCards = await siaeStorage.getSiaeActivationCardsByCompany(transmission.companyId);
          const activeCard = activationCards.find(c => c.status === 'active');
          const taxId = systemConfig?.taxId || company?.fiscalCode || company?.taxId || '';
          
          // Prepare SiaeEventForLog with correct interface fields
          const eventForLog: SiaeEventForLog = {
            id: ticketedEvent.id,
            name: baseEvent?.name || 'N/D',
            date: baseEvent?.startDatetime ? new Date(baseEvent.startDatetime) : new Date(),
            time: baseEvent?.startDatetime ? new Date(baseEvent.startDatetime) : null,
            venueCode: ticketedEvent.siaeLocationCode || '0000000000001',
            genreCode: ticketedEvent.genreCode || 'S1',
            organizerTaxId: taxId,
            organizerName: companyName,
            tipoTassazione: (ticketedEvent.taxType as 'S' | 'I') || 'S',
            ivaPreassolta: (ticketedEvent.ivaPreassolta as 'N' | 'B' | 'F') || 'N',
          };
          
          // Convert tickets to SiaeTicketForLog[] with correct interface fields
          const ticketsForLog: SiaeTicketForLog[] = eventTickets.map(t => {
            // Determina lo status corretto: se ha motivo/data annullamento, è annullato
            let effectiveStatus = t.status || 'emitted';
            if (!isCancelledStatus(effectiveStatus) && (t.cancellationReasonCode || t.cancellationDate)) {
              effectiveStatus = 'cancelled';
            }
            
            return {
              id: t.id,
              fiscalSealCode: t.fiscalSealCode || null,
              progressiveNumber: t.progressiveNumber || 1,
              cardCode: t.cardCode || activeCard?.cardCode || null,
              emissionChannelCode: t.emissionChannelCode || null,
              emissionDate: t.emissionDate ? new Date(t.emissionDate) : new Date(),
              ticketTypeCode: t.ticketTypeCode || 'R1',
              sectorCode: t.sectorCode || 'A0',
              grossAmount: t.grossAmount || '0',
              netAmount: t.netAmount || null,
              vatAmount: t.vatAmount || null,
              prevendita: t.prevendita || '0',
              prevenditaVat: t.prevenditaVat || null,
              status: effectiveStatus,
              cancellationReasonCode: t.cancellationReasonCode || null,
              cancellationDate: t.cancellationDate || null,
              isComplimentary: t.isComplimentary || false,
              row: t.row || null,
              seatNumber: t.seatNumber || null,
              participantFirstName: t.participantFirstName || null,
              participantLastName: t.participantLastName || null,
              originalTicketId: t.originalTicketId || null,
              replacedByTicketId: t.replacedByTicketId || null,
              originalProgressiveNumber: t.progressiveNumber || null,
            };
          });
          
          // Calculate progressivo for RCA based on previous transmissions for this event
          // Per errore 40604 "riepilogo già elaborato": 
          // - Sostituzione="S" non basta, SIAE richiede anche ProgressivoRiepilogo incrementato
          const allTransmissions = await siaeStorage.getSiaeTransmissionsByCompany(transmission.companyId);
          const rcaTransmissionsForEvent = allTransmissions.filter(t => 
            t.transmissionType === 'rca' && t.ticketedEventId === transmission.ticketedEventId
          );
          // Per reinvio: incrementa progressivo rispetto alle trasmissioni precedenti
          const rcaProgressivo = rcaTransmissionsForEvent.length + 1;
          console.log(`[SIAE-ROUTES] RCA progressivo per reinvio: ${rcaProgressivo} (trasmissioni precedenti: ${rcaTransmissionsForEvent.length})`);
          
          // Generate RCA XML (RiepilogoControlloAccessi format) con Sostituzione="S"
          // Usa resolvedSystemCodeForEmail già calcolato all'inizio della funzione
          const rcaResult = generateRCAXml({
            companyId: transmission.companyId,
            eventId: ticketedEvent.id,
            event: eventForLog,
            tickets: ticketsForLog,
            systemConfig: {
              systemCode: resolvedSystemCodeForEmail, // FIX: Usa codice risolto per coerenza
              taxId: taxId,
              businessName: systemConfig?.businessName || companyName,
            },
            companyName,
            taxId,
            progressivo: rcaProgressivo, // Progressivo incrementato per reinvio
            forceSubstitution: true, // Reinvio = sempre Sostituzione="S"
          });
          
          xmlContent = rcaResult.xml;
          regeneratedXml = true;
          
          // AUTO-CORREZIONE PREVENTIVA: Correggi automaticamente errori comuni prima dell'invio
          const autoCorrectionEmail = autoCorrectSiaeXml(xmlContent, eventForLog.genreCode);
          if (autoCorrectionEmail.corrections.length > 0) {
            console.log(`[SIAE-ROUTES] AUTO-CORREZIONE: Applicate ${autoCorrectionEmail.corrections.length} correzioni automatiche per RCA email:`);
            for (const corr of autoCorrectionEmail.corrections) {
              console.log(`  - ${corr.field}: ${corr.reason} (previene errore SIAE ${corr.siaeErrorPrevented})`);
            }
            xmlContent = autoCorrectionEmail.correctedXml;
          }
          if (autoCorrectionEmail.uncorrectableErrors.length > 0) {
            console.log(`[SIAE-ROUTES] ERRORI NON CORREGGIBILI: ${autoCorrectionEmail.uncorrectableErrors.map(e => e.message).join('; ')}`);
          }
          
          // Aggiorna il database con l'XML corretto
          await siaeStorage.updateSiaeTransmission(id, {
            fileContent: xmlContent,
            p7mContent: null, // Invalida la vecchia firma
            signedAt: null,
          });
          
        console.log(`[SIAE-ROUTES] RCA XML regenerated successfully with ${rcaResult.ticketCount} tickets`);
        console.log(`[SIAE-ROUTES] Regenerated XML Preview: ${xmlContent.substring(0, 300)}`);
        
      } catch (regenError: any) {
        console.error(`[SIAE-ROUTES] Failed to regenerate RCA XML: ${regenError.message}`);
        return res.status(400).json({ 
          message: `Impossibile rigenerare l'XML RCA: ${regenError.message}. Genera una nuova trasmissione dalla pagina dell'evento.`,
          code: "RCA_REGENERATION_FAILED"
        });
      }
    }
    
    // CRITICAL FIX: Rimuovi DOCTYPE dall'XML se presente
    // I Web Service SIAE non risolvono DTD esterni (XXE protection) - causa errore 40605
    if (xmlContent.includes('<!DOCTYPE')) {
      console.log(`[SIAE-ROUTES] Removing DOCTYPE from XML (WS SIAE non risolve DTD esterni)`);
      xmlContent = xmlContent.replace(/<!DOCTYPE[^>]*>/g, '');
      // Aggiorna il database con l'XML senza DOCTYPE
      await siaeStorage.updateSiaeTransmission(id, {
        fileContent: xmlContent,
        p7mContent: null, // Invalida la vecchia firma
        signedAt: null,
      });
      regeneratedXml = true; // Forza nuova firma
    }
    
    // Try to digitally sign the XML using smart card
    let signatureInfo = '';
    let p7mBase64: string | undefined;
    let signedXmlContent: string | undefined;
    
    try {
      if (isBridgeConnected()) {
        console.log(`[SIAE-ROUTES] Bridge connected, attempting digital signature...`);
        // Usa xmlContent (potrebbe essere rigenerato per RCA)
        const signatureResult = await requestXmlSignature(xmlContent);
        
        // Supporta sia CAdES-BES (nuovo) che XMLDSig (legacy)
        if (signatureResult.p7mBase64) {
          // CAdES-BES: mantieni il P7M Base64 separato
          p7mBase64 = signatureResult.p7mBase64;
          signatureInfo = ` (firmato CAdES-BES ${signatureResult.algorithm || 'SHA-256'})`;
          console.log(`[SIAE-ROUTES] CAdES-BES signature created at ${signatureResult.signedAt}`);
        } else if (signatureResult.signedXml) {
          // Legacy XMLDSig (deprecato)
          signedXmlContent = signatureResult.signedXml;
          signatureInfo = ' (firmato XMLDSig - DEPRECATO)';
          console.log(`[SIAE-ROUTES] XMLDSig signature created at ${signatureResult.signedAt}`);
        }
        
        // Update transmission with signed content
        if (p7mBase64 || signedXmlContent) {
          await siaeStorage.updateSiaeTransmission(id, {
            fileContent: signedXmlContent || xmlContent,
            p7mContent: p7mBase64 || null, // Salva P7M per resend offline
            signatureFormat: p7mBase64 ? 'cades' : 'xmldsig',
            signedAt: new Date(),
          });
        }
      } else {
        console.log(`[SIAE-ROUTES] Bridge not connected, checking for existing signature...`);
        // Se il bridge è offline E l'XML NON è stato rigenerato, prova a usare la firma salvata
        // Se l'XML è stato rigenerato, la vecchia firma non è più valida
        if (!regeneratedXml && transmission.p7mContent) {
          p7mBase64 = transmission.p7mContent;
          signatureInfo = ' (firma CAdES-BES da cache)';
          console.log(`[SIAE-ROUTES] Using cached CAdES-BES signature from database`);
        } else if (!regeneratedXml && transmission.signatureFormat === 'xmldsig') {
          signedXmlContent = xmlContent;
          signatureInfo = ' (firma XMLDSig da cache)';
          console.log(`[SIAE-ROUTES] Using cached XMLDSig signature`);
        } else if (regeneratedXml) {
          console.log(`[SIAE-ROUTES] XML was regenerated, cached signature is invalid - need fresh signature`);
          return res.status(400).json({ 
            message: "L'XML RCA è stato rigenerato con il formato corretto, ma il bridge desktop non è connesso per la nuova firma digitale. Connetti il bridge desktop e riprova.",
            code: "BRIDGE_REQUIRED_FOR_REGENERATED_XML"
          });
        } else {
          console.log(`[SIAE-ROUTES] No cached signature found, sending unsigned XML`);
        }
      }
    } catch (signError: any) {
      console.warn(`[SIAE-ROUTES] Digital signature failed: ${signError.message}`);
      // Fallback a firma salvata se disponibile E l'XML non è stato rigenerato
      if (!regeneratedXml && transmission.p7mContent) {
        p7mBase64 = transmission.p7mContent;
        signatureInfo = ' (firma CAdES-BES da cache dopo errore)';
      }
    }
    
    // Import email service
    const { sendSiaeTransmissionEmail } = await import('./email-service');
    
    // Validazione pre-trasmissione SIAE (async per DTD validator)
    // FIX 2026-01-15: Usa resolvedSystemCodeForEmail (già calcolato all'inizio) invece di transmission.systemCode
    // Questo garantisce coerenza tra XML rigenerato, nome file allegato e subject email
    const transmissionReportType: 'giornaliero' | 'mensile' | 'rca' = 
      transmission.transmissionType === 'monthly' ? 'mensile' : 
      transmission.transmissionType === 'daily' ? 'giornaliero' : 'rca';
    const preValidation = await validatePreTransmission(
      signedXmlContent || xmlContent,
      resolvedSystemCodeForEmail,
      transmissionReportType,
      new Date(transmission.periodDate)
    );
    
    if (!preValidation.canTransmit) {
      await siaeStorage.updateSiaeTransmission(transmission.id, {
        status: 'error',
        errorMessage: preValidation.errors.map(e => `[${e.siaeErrorCode || 'ERR'}] ${e.message}`).join('; '),
      });
      return res.status(400).json({
        success: false,
        error: 'Validazione pre-trasmissione fallita',
        errors: preValidation.errors,
        warnings: preValidation.warnings,
        details: preValidation.details
      });
    }
    
    // Send the email to SIAE test environment
    const destinationEmail = getSiaeDestinationEmail(toEmail);
    const emailResult = await sendSiaeTransmissionEmail({
      to: destinationEmail,
      companyName,
      transmissionType: transmission.transmissionType as 'daily' | 'monthly' | 'corrective',
      periodDate: new Date(transmission.periodDate),
      ticketsCount: transmission.ticketsCount || 0,
      totalAmount: transmission.totalAmount || '0',
      xmlContent: signedXmlContent || xmlContent, // Usa xmlContent (potrebbe essere rigenerato)
      transmissionId: transmission.id,
      systemCode: resolvedSystemCodeForEmail, // FIX 2026-01-15: systemCode obbligatorio per nome file allegato
      p7mBase64: p7mBase64, // CAdES-BES P7M per allegato email
      signatureFormat: p7mBase64 ? 'cades' : (signedXmlContent ? 'xmldsig' : undefined),
      signWithSmime: true,
      requireSignature: true,
    });
    
    if (!emailResult.success) {
      return res.status(400).json({ 
        success: false, 
        message: emailResult.error || 'Invio email fallito - Firma S/MIME richiesta'
      });
    }
    
    console.log(`[SIAE-ROUTES] Transmission sent to: ${destinationEmail}${signatureInfo} (Test mode: ${SIAE_TEST_MODE})`);
    
    // Update transmission status to sent
    await siaeStorage.updateSiaeTransmission(id, {
      status: 'sent',
      sentAt: new Date(),
      sentToPec: destinationEmail,
    });
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: transmission.companyId,
      userId: user.id,
      action: 'transmission_sent',
      entityType: 'transmission',
      entityId: id,
      description: `Trasmissione ${transmission.transmissionType} inviata a ${destinationEmail}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json({ success: true, message: `Email inviata con successo${signatureInfo}` });
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to send transmission email:', error);
    res.status(500).json({ message: error.message });
  }
});

// ==================== C1 Transmission Handler (Shared Logic) ====================
// Shared handler for generating and sending C1 transmissions (daily, monthly, or RCA)
// Used by both /send-c1 and legacy /send-daily endpoints
// RCA = RiepilogoControlloAccessi for single event (SIAE responds with Log.xsi)
// RMG = Riepilogo Giornaliero (silent)
// RPM = Riepilogo Mensile (silent)
interface SendC1Params {
  companyId: string;
  date?: string;
  toEmail?: string;
  type?: 'daily' | 'monthly' | 'rca';
  eventId?: string; // Required for RCA type
  signWithSmartCard?: boolean;
  forceSubstitution?: boolean; // Forza Sostituzione="S" per reinvio report già elaborati (errore 40604)
}

async function handleSendC1Transmission(params: SendC1Params): Promise<{
  success: boolean;
  statusCode: number;
  data?: any;
  error?: string;
}> {
  const { companyId, date, toEmail, type = 'daily', eventId, signWithSmartCard = true, forceSubstitution = false } = params;
  const isMonthly = type === 'monthly';
  const isRCA = type === 'rca';
  
  // RCA requires eventId
  if (isRCA && !eventId) {
    return { success: false, statusCode: 400, error: "EventId richiesto per report RCA" };
  }
  
  const reportDate = date ? new Date(date) : new Date();
  reportDate.setHours(0, 0, 0, 0);
  
  // Get activation card for company
  const activationCards = await siaeStorage.getSiaeActivationCardsByCompany(companyId);
  const activeCard = activationCards.find(c => c.status === 'active');
  
  if (!activeCard) {
    return { success: false, statusCode: 400, error: "Nessuna carta di attivazione attiva trovata" };
  }
  
  // Get system config for fiscal code
  const systemConfig = await siaeStorage.getSiaeSystemConfig(companyId);
  const company = await storage.getCompany(companyId);
  const companyName = company?.name || 'N/A';
  
  // CONTROLLO OBBLIGATORIO: Codice Fiscale/P.IVA Emittente
  // Priorità: systemConfig.taxId > company.fiscalCode (16 char) > company.taxId
  const taxId = systemConfig?.taxId || company?.fiscalCode || company?.taxId;
  if (!taxId) {
    return { 
      success: false, 
      statusCode: 400, 
      error: "Codice Fiscale Emittente non configurato. Vai su Impostazioni SIAE > Dati Aziendali per configurarlo prima di generare report.",
      data: { code: "TAX_ID_REQUIRED" }
    };
  }
  
  // Get tickets based on report type
  // RCA: single event by eventId
  // RMG/RPM: date range filtering by EVENT DATE (not emission date)
  const allTickets = await siaeStorage.getSiaeTicketsByCompany(companyId);
  
  // Pre-fetch all ticketed events to get their event dates and IDs
  const ticketedEventsMap = new Map<string, { eventDate: Date; eventId: string }>();
  const uniqueTicketedEventIds = Array.from(new Set(allTickets.map(t => t.ticketedEventId).filter(Boolean)));
  
  for (const ticketedEventId of uniqueTicketedEventIds) {
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(ticketedEventId);
    if (ticketedEvent) {
      const eventDetails = await storage.getEvent(ticketedEvent.eventId);
      if (eventDetails) {
        ticketedEventsMap.set(ticketedEventId, { 
          eventDate: new Date(eventDetails.startDatetime),
          eventId: ticketedEvent.eventId
        });
      }
    }
  }
  
  let filteredTickets: typeof allTickets;
  let rcaEventName = '';
  let rcaEventDate: Date | null = null;
  
  if (isRCA && eventId) {
    // RCA: filter by specific SIAE ticketed event ID
    const rcaTicketedEvent = await siaeStorage.getSiaeTicketedEvent(eventId);
    if (!rcaTicketedEvent) {
      return { success: false, statusCode: 400, error: "Evento ticketed non trovato" };
    }
    
    // Security validation: verify event belongs to requesting company
    if (rcaTicketedEvent.companyId !== companyId) {
      return { success: false, statusCode: 403, error: "Accesso non autorizzato: l'evento non appartiene a questa azienda" };
    }
    
    // Status validation: verify event is closed/completed for RCA
    // Allow both 'closed' ticketingStatus OR if the base event status is 'closed'
    const baseEvent = await storage.getEvent(rcaTicketedEvent.eventId);
    const eventIsClosed = rcaTicketedEvent.ticketingStatus === 'closed' || baseEvent?.status === 'closed';
    
    console.log(`[SIAE-ROUTES] RCA validation: ticketingStatus=${rcaTicketedEvent.ticketingStatus}, eventStatus=${baseEvent?.status}, eventIsClosed=${eventIsClosed}`);
    
    if (!eventIsClosed) {
      return { success: false, statusCode: 400, error: "L'evento deve essere chiuso per generare il report RCA. Stato attuale biglietteria: " + rcaTicketedEvent.ticketingStatus + ", stato evento: " + (baseEvent?.status || 'sconosciuto') };
    }
    
    const rcaEventDetails = await storage.getEvent(rcaTicketedEvent.eventId);
    if (rcaEventDetails) {
      rcaEventName = rcaEventDetails.name;
      rcaEventDate = new Date(rcaEventDetails.startDatetime);
    }
    
    // NORMATIVA SIAE: Il report C1 DEVE includere TUTTI i biglietti, inclusi gli annullati
    // I biglietti annullati vengono conteggiati separatamente nella sezione TotaleTitoliAnnullati
    // Provvedimento 04/03/2008 - Allegato B: sezione Annullati obbligatoria
    filteredTickets = allTickets.filter(t => t.ticketedEventId === eventId);
    
    const validTicketsCount = filteredTickets.filter(t => !isCancelledStatus(t.status)).length;
    const cancelledTicketsCount = filteredTickets.filter(t => isCancelledStatus(t.status)).length;
    console.log(`[SIAE-ROUTES] RCA report for event "${rcaEventName}" - ${filteredTickets.length} total tickets (${validTicketsCount} valid, ${cancelledTicketsCount} annullati - INCLUSI per normativa)`);
  } else {
    // RMG/RPM: Calculate date range and filter
    let startDate: Date, endDate: Date;
    if (isMonthly) {
      // For monthly: entire month
      startDate = new Date(reportDate.getFullYear(), reportDate.getMonth(), 1);
      endDate = new Date(reportDate.getFullYear(), reportDate.getMonth() + 1, 0, 23, 59, 59, 999);
    } else {
      // For daily: single day
      startDate = new Date(reportDate);
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(reportDate);
      endDate.setHours(23, 59, 59, 999);
    }
    
    filteredTickets = allTickets.filter(t => {
      // Use EVENT DATE for filtering (not ticket emission date)
      const eventInfo = ticketedEventsMap.get(t.ticketedEventId);
      if (!eventInfo) return false;
      
      const eventDate = eventInfo.eventDate;
      return eventDate >= startDate && eventDate <= endDate;
    });
  }
  
  const now = new Date();
  const oraGen = now.toTimeString().split(' ')[0].replace(/:/g, '');
  
  // Calculate totals
  const totalAmount = filteredTickets.reduce((sum, t) => sum + parseFloat(t.grossAmount || '0'), 0);
  
  // For RCA, use the event date as report date
  const effectiveReportDate = isRCA && rcaEventDate ? rcaEventDate : reportDate;
  
  // Validate eventId for RCA type (required)
  if (isRCA && !eventId) {
    return {
      success: false,
      statusCode: 400,
      error: 'eventId è obbligatorio per trasmissioni RCA',
      data: { code: 'MISSING_EVENT_ID' }
    };
  }
  
  // Generate XML using appropriate function based on type
  let xml: string;
  // FIX 2026-01-14: Calcola il progressivo UNA SOLA VOLTA e riusa per XML e nome file
  let calculatedProgressivo: number;
  
  // FIX 2026-01-17: Per RCA (S/MIME), codice sistema DEVE provenire dalla Smart Card
  // Usare siaeConfig.systemCode con Smart Card diversa causa errore SIAE 0600
  const { getCachedEfffData } = await import('./bridge-relay');
  const cachedEfffData = getCachedEfffData();
  
  // FIX 2026-01-18: TUTTI i report (RCA, RMG, RPM) sono firmati S/MIME
  // Quindi il system code DEVE provenire dalla Smart Card per TUTTI i tipi
  // Usare siaeConfig.systemCode con Smart Card diversa causa errore SIAE 0600
  let preResolvedSystemCode: string;
  const smimeResult = resolveSystemCodeForSmime(cachedEfffData, systemConfig ? { systemCode: systemConfig.systemCode ?? undefined } : null);
  
  if (!smimeResult.success || !smimeResult.systemCode) {
    console.error(`[SIAE-ROUTES] BLOCCO ${type.toUpperCase()}: ${smimeResult.error}`);
    return {
      success: false,
      statusCode: 400,
      error: smimeResult.error || 'Smart Card richiesta per trasmissioni SIAE',
      data: {
        code: 'SMARTCARD_REQUIRED_FOR_SMIME',
        reportType: type,
        source: smimeResult.source,
        suggestion: 'Collegare la Smart Card SIAE tramite Desktop Bridge prima di inviare report'
      }
    };
  }
  preResolvedSystemCode = smimeResult.systemCode;
  if (smimeResult.warning) {
    console.warn(`[SIAE-ROUTES] ${type.toUpperCase()} Warning: ${smimeResult.warning}`);
  }
  console.log(`[SIAE-ROUTES] FIX 2026-01-18: ${type.toUpperCase()} system code from ${smimeResult.source}: ${preResolvedSystemCode}`)
  
  // FIX 2026-01-16: Valida codice sistema PRIMA della generazione XML
  // Il codice default EVENT4U1 NON è registrato presso SIAE e causa errore 0600
  const systemCodeValidationResult = validateSiaeSystemCode(preResolvedSystemCode);
  if (!systemCodeValidationResult.valid) {
    console.error(`[SIAE-ROUTES] BLOCCO TRASMISSIONE: Codice sistema non valido - ${systemCodeValidationResult.error}`);
    return {
      success: false,
      statusCode: 400,
      error: systemCodeValidationResult.error,
      data: {
        code: 'INVALID_SYSTEM_CODE',
        systemCode: preResolvedSystemCode,
        isDefault: systemCodeValidationResult.isDefault,
        isTestCode: systemCodeValidationResult.isTestCode,
        suggestion: systemCodeValidationResult.isDefault 
          ? 'Configurare il codice sistema SIAE in Impostazioni > SIAE > Configurazione Sistema, oppure collegare una Smart Card di attivazione attiva tramite il Desktop Bridge.'
          : 'Verificare il formato del codice sistema. Codici test: P + 7 cifre (es: P0004010)'
      }
    };
  }
  console.log(`[SIAE-ROUTES] Codice sistema validato: ${preResolvedSystemCode} (test: ${systemCodeValidationResult.isTestCode})`);
  
  if (isRCA && eventId) {
    // RCA: Use RiepilogoControlloAccessi format per DTD ControlloAccessi_v0001_20080626.dtd
    // NOTA: NON usare LogTransazione per RCA - causa errore SIAE 40605
    // Fetch ticketed event and base event for SiaeEventForLog
    const rcaTicketedEvent = await siaeStorage.getSiaeTicketedEvent(eventId);
    const rcaEventDetails = rcaTicketedEvent ? await storage.getEvent(rcaTicketedEvent.eventId) : null;
    
    // Prepare SiaeEventForLog
    const eventForLog: SiaeEventForLog = {
      id: eventId,
      name: rcaEventDetails?.name || 'N/D',
      date: rcaEventDetails?.startDatetime ? new Date(rcaEventDetails.startDatetime) : new Date(),
      time: rcaEventDetails?.startDatetime ? new Date(rcaEventDetails.startDatetime) : null,
      venueCode: rcaTicketedEvent?.siaeLocationCode || '0000000000001',
      genreCode: rcaTicketedEvent?.genreCode || 'S1',
      organizerTaxId: taxId,
      organizerName: companyName,
      tipoTassazione: (rcaTicketedEvent?.taxType as 'S' | 'I') || 'S',
      ivaPreassolta: (rcaTicketedEvent?.ivaPreassolta as 'N' | 'B' | 'F') || 'N',
    };
    
    // Convert filteredTickets to SiaeTicketForLog[]
    // IMPORTANTE: Determinare correttamente lo status per conformità SIAE
    const ticketsForLog: SiaeTicketForLog[] = filteredTickets.map(ticket => {
      // Determina lo status corretto: se ha motivo/data annullamento, è annullato
      let effectiveStatus = ticket.status || 'emitted';
      if (!isCancelledStatus(effectiveStatus) && (ticket.cancellationReasonCode || ticket.cancellationDate)) {
        effectiveStatus = 'cancelled'; // Forza status annullato se ha dati di annullamento
      }
      
      return {
        id: ticket.id,
        fiscalSealCode: ticket.fiscalSealCode || null,
        progressiveNumber: ticket.progressiveNumber || 1,
        cardCode: ticket.cardCode || activeCard?.cardCode || null,
        emissionChannelCode: ticket.emissionChannelCode || null,
        emissionDate: ticket.emissionDate ? new Date(ticket.emissionDate) : new Date(),
        ticketTypeCode: ticket.ticketTypeCode || 'R1',
        sectorCode: ticket.sectorCode || 'A0',
        grossAmount: ticket.grossAmount || '0',
        netAmount: ticket.netAmount || null,
        vatAmount: ticket.vatAmount || null,
        prevendita: ticket.prevendita || '0',
        prevenditaVat: ticket.prevenditaVat || null,
        status: effectiveStatus,
        cancellationReasonCode: ticket.cancellationReasonCode || null,
        cancellationDate: ticket.cancellationDate || null,
        isComplimentary: ticket.isComplimentary || false,
        row: ticket.row || null,
        seatNumber: ticket.seatNumber || null,
        participantFirstName: ticket.participantFirstName || null,
        participantLastName: ticket.participantLastName || null,
        originalTicketId: ticket.originalTicketId || null,
        replacedByTicketId: ticket.replacedByTicketId || null,
        originalProgressiveNumber: ticket.progressiveNumber || null,
      };
    });
    
    // Calculate progressivo for RCA based on previous transmissions for this event
    // Per errore 40604 "riepilogo già elaborato": 
    // - Sostituzione="S" non basta, SIAE richiede anche ProgressivoRiepilogo incrementato
    // FIX: Usa ticketedEventId (campo corretto nello schema) invece di eventId
    const allTransmissions = await siaeStorage.getSiaeTransmissionsByCompany(companyId);
    const rcaTransmissionsForEvent = allTransmissions.filter(t => 
      t.transmissionType === 'rca' && t.ticketedEventId === eventId
    );
    let rcaProgressivo = rcaTransmissionsForEvent.length + 1;
    
    // Se forceSubstitution=true, aggiungi 1 extra per essere sicuri
    // (anche se già incrementato dal conteggio, SIAE potrebbe richiedere progressivo > precedente)
    if (forceSubstitution && rcaProgressivo <= rcaTransmissionsForEvent.length) {
      rcaProgressivo = rcaTransmissionsForEvent.length + 1;
    }
    console.log(`[SIAE-ROUTES] RCA progressivo: ${rcaProgressivo} (trasmissioni precedenti: ${rcaTransmissionsForEvent.length}, forceSubstitution: ${forceSubstitution})`);
    // FIX 2026-01-14: Salva progressivo per riuso nel nome file
    calculatedProgressivo = rcaProgressivo;
    
    // Generate RCA XML (RiepilogoControlloAccessi format - Allegato B Provvedimento 04/03/2008)
    // NOTA: Usa generateRCAXml invece di generateC1LogXml (deprecato - causa errore SIAE 40605)
    // FIX 2026-01-15: Usa preResolvedSystemCode per coerenza con nome file allegato (errori SIAE 0600/0603)
    const rcaResult = generateRCAXml({
      companyId,
      eventId,
      event: eventForLog,
      tickets: ticketsForLog,
      systemConfig: {
        systemCode: preResolvedSystemCode, // FIX: Usa preResolvedSystemCode invece di systemConfig.systemCode
        taxId: systemConfig?.taxId || taxId,
        businessName: systemConfig?.businessName || companyName,
      },
      companyName,
      taxId,
      progressivo: rcaProgressivo, // Progressivo incrementato per ogni trasmissione
      forceSubstitution, // Forza Sostituzione="S" per reinvio (errore 40604)
    });
    
    if (!rcaResult.success) {
      console.error(`[SIAE-ROUTES] RCA generation failed:`, rcaResult.errors);
      return {
        success: false,
        statusCode: 400,
        error: `Generazione RiepilogoControlloAccessi fallita: ${rcaResult.errors.join('; ')}`,
        data: {
          code: 'RCA_GENERATION_FAILED',
          errors: rcaResult.errors,
          warnings: rcaResult.warnings,
        }
      };
    }
    
    // Log any warnings
    if (rcaResult.warnings.length > 0) {
      console.log(`[SIAE-ROUTES] RCA warnings:`, rcaResult.warnings);
    }
    
    xml = rcaResult.xml;
    
    // AUTO-CORREZIONE PREVENTIVA: Correggi automaticamente errori comuni prima dell'invio
    const autoCorrectionC1 = autoCorrectSiaeXml(xml, eventForLog.genreCode);
    if (autoCorrectionC1.corrections.length > 0) {
      console.log(`[SIAE-ROUTES] AUTO-CORREZIONE: Applicate ${autoCorrectionC1.corrections.length} correzioni automatiche per RCA C1:`);
      for (const corr of autoCorrectionC1.corrections) {
        console.log(`  - ${corr.field}: ${corr.reason} (previene errore SIAE ${corr.siaeErrorPrevented})`);
      }
      xml = autoCorrectionC1.correctedXml;
    }
    if (autoCorrectionC1.uncorrectableErrors.length > 0) {
      console.log(`[SIAE-ROUTES] ERRORI NON CORREGGIBILI: ${autoCorrectionC1.uncorrectableErrors.map(e => e.message).join('; ')}`);
    }
    
    // CRITICAL DIAGNOSTIC: Verify XML format is RiepilogoControlloAccessi (not LogTransazione)
    const xmlRoot = xml.substring(0, 300);
    const isCorrectFormat = xml.includes('<RiepilogoControlloAccessi');
    const hasWrongFormat = xml.includes('<LogTransazione');
    console.log(`[SIAE-ROUTES] RCA XML Format Check: isRiepilogoControlloAccessi=${isCorrectFormat}, hasLogTransazione=${hasWrongFormat}`);
    console.log(`[SIAE-ROUTES] RCA XML Preview: ${xmlRoot}`);
    if (hasWrongFormat) {
      console.error(`[SIAE-ROUTES] CRITICAL ERROR: RCA XML contains LogTransazione instead of RiepilogoControlloAccessi!`);
    }
    console.log(`[SIAE-ROUTES] Generated RiepilogoControlloAccessi for RCA with ${rcaResult.ticketCount} tickets`);
  } else {
    // RMG/RPM: Use existing RiepilogoGiornaliero/RiepilogoMensile format
    // FIX 2026-01-14: Calcola il progressivo PRIMA della generazione XML per coerenza nome file/contenuto
    const transmissionTypeForCalc = isMonthly ? 'monthly' : 'daily';
    const existingTransmissionsForCalc = await siaeStorage.getSiaeTransmissionsByCompany(companyId);
    const sameTypeTransmissionsForCalc = existingTransmissionsForCalc.filter(t => {
      const tDate = new Date(t.periodDate);
      if (isMonthly) {
        // Per mensile, confronta anno e mese
        return t.transmissionType === 'monthly' &&
               tDate.getFullYear() === effectiveReportDate.getFullYear() &&
               tDate.getMonth() === effectiveReportDate.getMonth();
      } else {
        // Per giornaliero, confronta anno, mese e giorno
        return t.transmissionType === 'daily' &&
               tDate.getFullYear() === effectiveReportDate.getFullYear() &&
               tDate.getMonth() === effectiveReportDate.getMonth() &&
               tDate.getDate() === effectiveReportDate.getDate();
      }
    });
    const preCalculatedProgressivo = sameTypeTransmissionsForCalc.length + 1;
    console.log(`[SIAE-ROUTES] Pre-calculated progressivo for ${transmissionTypeForCalc}: ${preCalculatedProgressivo} (existing: ${sameTypeTransmissionsForCalc.length})`);
    // FIX 2026-01-14: Salva progressivo per riuso nel nome file
    calculatedProgressivo = preCalculatedProgressivo;
    
    // FIX 2026-01-14: Genera nome file PRIMA della generazione XML per attributo NomeFile obbligatorio
    // L'attributo NomeFile deve corrispondere esattamente al nome dell'allegato email (errore SIAE 0600)
    // FIX 2026-01-15: Usa preResolvedSystemCode già calcolato all'inizio (non ridefinire!)
    const preReportTypeForFileName: 'giornaliero' | 'mensile' = isMonthly ? 'mensile' : 'giornaliero';
    console.log(`[SIAE-ROUTES] Using pre-resolved system code for RMG/RPM: ${preResolvedSystemCode}`);
    
    const preGeneratedFileName = generateSiaeFileName(
      preReportTypeForFileName,
      effectiveReportDate,
      preCalculatedProgressivo,
      null, // senza firma - il nome .xsi è quello che va nell'attributo NomeFile
      preResolvedSystemCode
    );
    console.log(`[SIAE-ROUTES] Pre-generated filename for XML NomeFile attribute: ${preGeneratedFileName}`);
    
    const hydratedData = await hydrateC1EventContextFromTickets(filteredTickets, companyId, effectiveReportDate, isMonthly);
    
    // FIX 2026-01-18: Per report giornaliero (RMG), 0 biglietti è permesso
    // Per report mensile (RPM), rimane un errore bloccante
    if (hydratedData.events.length === 0 && hydratedData.subscriptions.length === 0) {
      if (isMonthly) {
        throw new Error('SIAE_NO_EVENTS: Nessun biglietto o abbonamento trovato per il periodo richiesto. Il report mensile richiede almeno un evento.');
      }
      console.warn('[SIAE-ROUTES] Report giornaliero senza eventi/abbonamenti - generazione consentita');
    }
    
    const c1Params: C1XmlParams = {
      reportKind: isMonthly ? 'mensile' : 'giornaliero',
      companyId,
      reportDate: effectiveReportDate,
      resolvedSystemCode: preResolvedSystemCode,
      progressivo: preCalculatedProgressivo,
      taxId,
      businessName: companyName,
      events: hydratedData.events,
      subscriptions: hydratedData.subscriptions,
    };
    
    const c1Result = generateC1Xml(c1Params);
    xml = c1Result.xml;
  }
  
  const transmissionType = isRCA ? 'rca' : (isMonthly ? 'monthly' : 'daily');
  const typeLabel = isRCA ? `RCA evento "${rcaEventName}"` : (isMonthly ? 'mensile' : 'giornaliera');
  
  // ==================== XML/TYPE COHERENCE VALIDATION (Fix SIAE Error 0601) ====================
  // Verify that XML content matches the expected report type to prevent "Oggetto del messaggio sbagliato" error
  const hasRCA = xml.includes('<RiepilogoControlloAccessi');
  const hasRMG = xml.includes('<RiepilogoGiornaliero');
  const hasRPM = xml.includes('<RiepilogoMensile');
  
  let xmlTypeError: string | null = null;
  if (isRCA && !hasRCA) {
    xmlTypeError = `ERRORE COERENZA: Richiesto report RCA ma XML contiene formato ${hasRMG ? 'RiepilogoGiornaliero' : hasRPM ? 'RiepilogoMensile' : 'sconosciuto'}. Il nome file sarebbe RCA_* ma il contenuto non corrisponde.`;
  } else if (!isRCA && !isMonthly && !hasRMG) {
    xmlTypeError = `ERRORE COERENZA: Richiesto report giornaliero (RMG) ma XML contiene formato ${hasRCA ? 'RiepilogoControlloAccessi' : hasRPM ? 'RiepilogoMensile' : 'sconosciuto'}. Il nome file sarebbe RMG_* ma il contenuto non corrisponde.`;
  } else if (!isRCA && isMonthly && !hasRPM) {
    xmlTypeError = `ERRORE COERENZA: Richiesto report mensile (RPM) ma XML contiene formato ${hasRCA ? 'RiepilogoControlloAccessi' : hasRMG ? 'RiepilogoGiornaliero' : 'sconosciuto'}. Il nome file sarebbe RPM_* ma il contenuto non corrisponde.`;
  }
  
  if (xmlTypeError) {
    console.error(`[SIAE-ROUTES] ${xmlTypeError}`);
    return {
      success: false,
      statusCode: 400,
      error: xmlTypeError,
      data: {
        code: 'XML_TYPE_MISMATCH',
        expectedType: isRCA ? 'RCA (RiepilogoControlloAccessi)' : (isMonthly ? 'RPM (RiepilogoMensile)' : 'RMG (RiepilogoGiornaliero)'),
        actualContent: hasRCA ? 'RiepilogoControlloAccessi' : hasRMG ? 'RiepilogoGiornaliero' : hasRPM ? 'RiepilogoMensile' : 'unknown',
        suggestion: 'Verificare il tipo di report selezionato. Per eventi singoli usare RCA, per report giornalieri RMG, per mensili RPM.'
      }
    };
  }
  console.log(`[SIAE-ROUTES] Coerenza XML/tipo verificata: ${transmissionType} → ${hasRCA ? 'RCA' : hasRMG ? 'RMG' : 'RPM'}`);
  // ==========================================================================================
  
  // ==================== SYSTEM CODE CONSISTENCY VALIDATION (Fix SIAE Error 0600/0603) ====================
  // FIX 2026-01-15: Usa funzione centralizzata per validazione coerenza codice sistema
  const systemCodeValidation = validateSystemCodeConsistency(xml, preResolvedSystemCode);
  
  if (!systemCodeValidation.valid) {
    console.error(`[SIAE-ROUTES] ${systemCodeValidation.error}`);
    return {
      success: false,
      statusCode: 400,
      error: systemCodeValidation.error || 'Codice sistema non coerente',
      data: {
        code: 'SYSTEM_CODE_MISMATCH',
        xmlSystemCode: systemCodeValidation.xmlSystemCode,
        filenameSystemCode: systemCodeValidation.filenameSystemCode,
        suggestion: 'Il codice sistema deve essere identico nel nome file, nell\'attributo NomeFile XML e negli elementi SistemaEmissione/CodiceSistemaCA.'
      }
    };
  }
  console.log(`[SIAE-ROUTES] Coerenza codice sistema verificata: XML=${systemCodeValidation.xmlSystemCode}, filename=${systemCodeValidation.filenameSystemCode}`);
  // ==========================================================================================
  
  // ==================== AUTOMATIC VALIDATION ====================
  // Validate XML before sending - blocks transmission if errors found
  const validation = validateC1Report(xml);
  console.log(`[SIAE-ROUTES] Validazione automatica C1 ${typeLabel}: ${validation.valid ? 'OK' : 'ERRORI TROVATI'}`);
  
  if (!validation.valid) {
    console.error(`[SIAE-ROUTES] Validazione C1 fallita:`, validation.errors);
    return {
      success: false,
      statusCode: 400,
      error: `Validazione report fallita: ${validation.errors.join('; ')}`,
      data: {
        code: 'VALIDATION_FAILED',
        validation: {
          valid: false,
          errors: validation.errors,
          warnings: validation.warnings,
          summary: validation.summary
        }
      }
    };
  }
  
  // Log warnings but continue
  if (validation.warnings.length > 0) {
    console.log(`[SIAE-ROUTES] Avvisi validazione C1:`, validation.warnings);
  }
  // ===============================================================
  
  // Try to sign the XML with smart card if requested (with retry for unstable connections)
  let signatureInfo = '';
  let p7mBase64: string | undefined;
  let signedXmlContent: string | undefined;
  let signatureData = null;
  
  if (signWithSmartCard) {
    const MAX_SIGNATURE_RETRIES = 3;
    const RETRY_DELAY_MS = 2000;
    
    for (let attempt = 1; attempt <= MAX_SIGNATURE_RETRIES; attempt++) {
      try {
        const bridgeConnected = isBridgeConnected();
        console.log(`[SIAE-ROUTES] Signature attempt ${attempt}/${MAX_SIGNATURE_RETRIES}: bridgeConnected=${bridgeConnected}`);
        
        if (bridgeConnected) {
          console.log(`[SIAE-ROUTES] Attempting XML signature for C1 ${typeLabel} report...`);
          signatureData = await requestXmlSignature(xml);
          
          // Supporta sia CAdES-BES (nuovo) che XMLDSig (legacy)
          if (signatureData.p7mBase64) {
            // CAdES-BES: mantieni il P7M Base64 separato
            p7mBase64 = signatureData.p7mBase64;
            signatureInfo = ` (firmato CAdES-BES ${signatureData.algorithm || 'SHA-256'})`;
            console.log(`[SIAE-ROUTES] CAdES-BES signature created for C1 ${typeLabel}`);
          } else if (signatureData.signedXml) {
            // Legacy XMLDSig (deprecato)
            signedXmlContent = signatureData.signedXml;
            signatureInfo = ' (firmato XMLDSig - DEPRECATO)';
            console.log(`[SIAE-ROUTES] XMLDSig signature created for C1 ${typeLabel}`);
          }
          break; // Success, exit retry loop
        } else {
          console.log(`[SIAE-ROUTES] Bridge not connected on attempt ${attempt}, waiting ${RETRY_DELAY_MS}ms...`);
          if (attempt < MAX_SIGNATURE_RETRIES) {
            await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
          } else {
            console.log(`[SIAE-ROUTES] Bridge not connected after ${MAX_SIGNATURE_RETRIES} attempts, sending unsigned XML for C1 ${typeLabel}`);
            signatureInfo = ' (non firmato - bridge non connesso)';
          }
        }
      } catch (signError: any) {
        console.error(`[SIAE-ROUTES] XML signature failed on attempt ${attempt}:`, signError.message);
        if (attempt < MAX_SIGNATURE_RETRIES) {
          console.log(`[SIAE-ROUTES] Retrying in ${RETRY_DELAY_MS}ms...`);
          await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
        } else {
          signatureInfo = ` (non firmato - ${signError.message})`;
        }
      }
    }
  }
  
  // FIX 2026-01-14: Usa il progressivo già calcolato prima della generazione XML
  // Questo garantisce coerenza tra nome file e contenuto XML (evita errore SIAE 0600)
  const effectiveReportDateForCount = isRCA && rcaEventDate ? rcaEventDate : reportDate;
  const sequenceNumber = calculatedProgressivo;
  console.log(`[SIAE-ROUTES] Using pre-calculated progressivo for filename: ${sequenceNumber}`);
  
  // Generate file name using the correct format (Allegato C SIAE)
  const reportTypeForFileName: 'giornaliero' | 'mensile' | 'rca' | 'log' = 
    isRCA ? 'rca' : (isMonthly ? 'mensile' : 'giornaliero');
  const effectiveSignatureFormat = p7mBase64 ? 'cades' : (signedXmlContent ? 'xmldsig' : null);
  // FIX 2026-01-15: Usa lo STESSO codice sistema già calcolato prima della generazione XML!
  // NON ricalcolare - la cache può cambiare tra le due chiamate causando errori SIAE 0600/0603
  // Il codice sistema DEVE essere identico in: NomeFile XML, nome file allegato, SistemaEmissione
  const effectiveSystemCode = preResolvedSystemCode;
  console.log(`[SIAE-ROUTES] FIX 2026-01-15: Using preResolvedSystemCode for attachment filename: ${effectiveSystemCode}`);
  const generatedFileName = generateSiaeFileName(
    reportTypeForFileName, 
    effectiveReportDateForCount, 
    sequenceNumber,
    effectiveSignatureFormat,
    effectiveSystemCode
  );
  const fileExtension = effectiveSignatureFormat === 'cades' ? '.p7m' : '.xsi';
  
  // Calculate transmission statistics
  // For RCA, get tipoTassazione and entertainmentIncidence from the ticketed event
  let c1TipoTassazione: string | undefined;
  let c1EntertainmentIncidence: number | undefined;
  if (isRCA && eventId) {
    const c1TicketedEvent = await siaeStorage.getSiaeTicketedEvent(eventId);
    c1TipoTassazione = c1TicketedEvent?.tipoTassazione || undefined;
    c1EntertainmentIncidence = c1TicketedEvent?.entertainmentIncidence || undefined;
  }
  const c1Stats = await calculateTransmissionStats(
    filteredTickets,
    companyId,
    eventId,
    c1TipoTassazione,
    c1EntertainmentIncidence
  );
  const c1FileHash = calculateFileHash(signedXmlContent || xml);
  
  // Create transmission record - salva firma appropriata e nome file conforme
  // FIX: Includere ticketedEventId per tutti i tipi se un evento è selezionato
  // FIX 2026-01-15: Salva systemCode per garantire coerenza nei reinvii (errori SIAE 0600/0603)
  const transmission = await siaeStorage.createSiaeTransmission({
    companyId,
    ticketedEventId: eventId || undefined, // Collegamento evento SIAE (sempre se selezionato)
    transmissionType,
    periodDate: reportDate,
    fileName: generatedFileName.replace(fileExtension, ''), // Nome senza estensione
    fileExtension: fileExtension,
    fileContent: signedXmlContent || xml, // XMLDSig firmato o XML originale
    p7mContent: p7mBase64 || null, // CAdES-BES P7M per resend offline
    signatureFormat: p7mBase64 ? 'cades' : (signedXmlContent ? 'xmldsig' : null),
    signedAt: (p7mBase64 || signedXmlContent) ? new Date() : null,
    status: 'pending',
    ticketsCount: filteredTickets.length,
    totalAmount: totalAmount.toString(),
    progressivoInvio: sequenceNumber, // Progressivo invio per periodo fiscale
    systemCode: effectiveSystemCode, // FIX: Salva codice per reinvii futuri
    fileHash: c1FileHash,
    totalIva: c1Stats.totalIva.toFixed(2),
    totalEsenti: c1Stats.totalEsenti.toFixed(2),
    totalImpostaIntrattenimento: c1Stats.totalImpostaIntrattenimento.toFixed(2),
    cfOrganizzatore: systemConfig?.taxId || '',
    ticketsChanged: c1Stats.ticketsChanged,
    ticketsResold: c1Stats.ticketsResold,
  });
  
  // Import and send the email with SIAE-compliant format (Allegato C)
  const { sendSiaeTransmissionEmail } = await import('./email-service');
  
  // Validazione pre-trasmissione SIAE (async per DTD validator)
  const c1ReportType: 'giornaliero' | 'mensile' | 'rca' = isRCA ? 'rca' : (isMonthly ? 'mensile' : 'giornaliero');
  const preValidation = await validatePreTransmission(
    signedXmlContent || xml,
    effectiveSystemCode,
    c1ReportType,
    effectiveReportDateForCount
  );
  
  if (!preValidation.canTransmit) {
    await siaeStorage.updateSiaeTransmission(transmission.id, {
      status: 'error',
      errorMessage: preValidation.errors.map(e => `[${e.siaeErrorCode || 'ERR'}] ${e.message}`).join('; '),
    });
    return {
      success: false,
      statusCode: 400,
      data: {
        error: 'Validazione pre-trasmissione fallita',
        errors: preValidation.errors,
        warnings: preValidation.warnings,
        details: preValidation.details,
        transmissionId: transmission.id,
      }
    };
  }
  
  const destination = getSiaeDestinationEmail(toEmail);
  const emailResult = await sendSiaeTransmissionEmail({
    to: destination,
    companyName,
    transmissionType,
    periodDate: effectiveReportDateForCount,
    ticketsCount: filteredTickets.length,
    totalAmount: totalAmount.toString(),
    xmlContent: signedXmlContent || xml, // XML originale o XMLDSig firmato
    transmissionId: transmission.id,
    systemCode: effectiveSystemCode, // CRITICAL: Must match XML CodiceSistemaCA
    sequenceNumber: sequenceNumber, // Progressivo calcolato dinamicamente
    signWithSmime: true, // Per Allegato C SIAE 1.6.2 - firma S/MIME obbligatoria
    requireSignature: true,
    p7mBase64: p7mBase64, // CAdES-BES P7M per allegato email
    signatureFormat: p7mBase64 ? 'cades' : (signedXmlContent ? 'xmldsig' : undefined),
  });
  
  // Controlla se l'invio è fallito (firma S/MIME non disponibile)
  if (!emailResult.success) {
    await siaeStorage.updateSiaeTransmission(transmission.id, {
      status: 'failed',
      errorMessage: emailResult.error || 'Invio email fallito',
    });
    return {
      success: false,
      statusCode: 400,
      data: {
        message: emailResult.error || 'Invio email fallito - Firma S/MIME richiesta',
        transmissionId: transmission.id,
      }
    };
  }
  
  const smimeInfo = emailResult.smimeSigned 
    ? ` (S/MIME: ${emailResult.signerEmail})` 
    : ' (NON firmata S/MIME)';
  console.log(`[SIAE-ROUTES] ${typeLabel.toUpperCase()} C1 transmission sent to: ${destination}${signatureInfo}${smimeInfo} (Test mode: ${SIAE_TEST_MODE})`);
  
  // Create email audit trail for traceability - calcola hash su contenuto appropriato
  const crypto = await import('crypto');
  const attachmentContent = p7mBase64 ? Buffer.from(p7mBase64, 'base64') : Buffer.from(signedXmlContent || xml, 'utf-8');
  const attachmentHash = crypto.createHash('sha256').update(attachmentContent).digest('hex');
  await siaeStorage.createSiaeEmailAudit({
    companyId,
    transmissionId: transmission.id,
    emailType: transmissionType === 'daily' ? 'c1_daily' : 'c1_monthly',
    recipientEmail: destination,
    senderEmail: emailResult.signerEmail || process.env.SIAE_SMTP_USER || undefined,
    subject: `Trasmissione SIAE ${typeLabel.toUpperCase()} - ${companyName}`,
    bodyPreview: `Trasmissione ${typeLabel} per ${companyName} - ${filteredTickets.length} biglietti - ${totalAmount.toString()} EUR`,
    attachmentName: `siae_${transmissionType}_${reportDate.toISOString().split('T')[0]}.xml`,
    attachmentHash,
    smimeSigned: emailResult.smimeSigned || false,
    smimeSignerEmail: emailResult.signerEmail || undefined,
    smimeSignedAt: emailResult.signedAt ? new Date(emailResult.signedAt) : undefined,
    status: 'sent',
    sentAt: new Date(),
  });
  
  // Update transmission status with S/MIME info
  await siaeStorage.updateSiaeTransmission(transmission.id, {
    status: 'sent',
    sentAt: new Date(),
    sentToPec: destination,
    smimeSigned: emailResult.smimeSigned || false,
    smimeSignerEmail: emailResult.signerEmail || null,
    smimeSignerName: emailResult.signerName || null,
    smimeSignedAt: emailResult.signedAt ? new Date(emailResult.signedAt) : null,
  });
  
  return {
    success: true,
    statusCode: 200,
    data: {
      message: `Trasmissione ${typeLabel} generata e inviata con successo${signatureInfo}${emailResult.smimeSigned ? ' (email firmata S/MIME)' : ''}`,
      transmission: {
        id: transmission.id,
        type: transmissionType,
        ticketsCount: filteredTickets.length,
        totalAmount: totalAmount.toString(),
        sentTo: destination,
        signed: signatureData !== null,
        smimeSigned: emailResult.smimeSigned,
        smimeSignerEmail: emailResult.signerEmail,
      },
      validation: {
        valid: true,
        warnings: validation.warnings,
        summary: validation.summary
      }
    }
  };
}

// Generate and send C1 transmission (daily, monthly, or RCA)
// type: 'rca' for single event (SIAE responds), 'daily' for RMG (silent), 'monthly' for RPM (silent)
router.post("/api/siae/companies/:companyId/transmissions/send-c1", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { companyId } = req.params;
    const { date, toEmail, type = 'daily', eventId, signWithSmartCard = true, forceSubstitution = false } = req.body;
    
    console.log(`[SIAE-ROUTES] send-c1 request received - type: ${type}, eventId: ${eventId}, companyId: ${companyId}, forceSubstitution: ${forceSubstitution}`);
    
    const result = await handleSendC1Transmission({
      companyId,
      date,
      toEmail,
      type,
      eventId, // Required for RCA type
      signWithSmartCard,
      forceSubstitution, // Forza Sostituzione="S" per reinvio (errore 40604)
    });
    
    if (result.success) {
      const user = req.user as any;
      await siaeStorage.createAuditLog({
        companyId,
        userId: user.id,
        action: 'c1_report_sent',
        entityType: 'transmission',
        entityId: result.data?.transmission?.id || '',
        description: `Trasmissione C1 ${type} inviata (${result.data?.transmission?.ticketsCount || 0} biglietti)`,
        ipAddress: req.ip,
        userAgent: req.get('user-agent'),
      });
      res.json({ success: true, ...result.data });
    } else {
      res.status(result.statusCode).json({ message: result.error, ...result.data });
    }
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to send C1 transmission:', error);
    res.status(500).json({ message: error.message });
  }
});

// Legacy endpoint - uses shared C1 handler with type=daily
// DEPRECATED: Use /api/siae/companies/:companyId/transmissions/send-c1 with type='daily' instead
router.post("/api/siae/companies/:companyId/transmissions/send-daily", requireAuth, requireGestore, async (req: Request, res: Response) => {
  console.log('[SIAE-ROUTES] Legacy send-daily endpoint called - using shared C1 handler with type=daily');
  try {
    const { companyId } = req.params;
    const { date, toEmail, signWithSmartCard = true } = req.body;
    
    const result = await handleSendC1Transmission({
      companyId,
      date,
      toEmail,
      type: 'daily',
      signWithSmartCard,
    });
    
    if (result.success) {
      const user = req.user as any;
      await siaeStorage.createAuditLog({
        companyId,
        userId: user.id,
        action: 'daily_report_sent',
        entityType: 'transmission',
        entityId: result.data?.transmission?.id || '',
        description: `Trasmissione giornaliera inviata (${result.data?.transmission?.ticketsCount || 0} biglietti)`,
        ipAddress: req.ip,
        userAgent: req.get('user-agent'),
      });
      res.json({ success: true, ...result.data });
    } else {
      res.status(result.statusCode).json({ message: result.error, ...result.data });
    }
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to send daily transmission (legacy):', error);
    res.status(500).json({ message: error.message });
  }
});

// Test email endpoint for transmission
// NOTA: Usa codice sistema test P0004010 per evitare errori SIAE 0600
router.post("/api/siae/transmissions/test-email", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { toEmail, companyId } = req.body;
    
    if (!toEmail) {
      return res.status(400).json({ message: "Indirizzo email richiesto" });
    }
    
    // FIX 2026-01-16: Usa codice sistema test valido invece di EVENT4U1
    // P0004010 è un codice test valido (P + 7 cifre)
    const TEST_SYSTEM_CODE = 'P0004010';
    
    // Get company name
    const company = companyId ? await storage.getCompany(companyId) : null;
    const companyName = company?.name || 'Test Company';
    
    // Create test XML in RiepilogoControlloAccessi format (Allegato B - Provvedimento 04/03/2008)
    const now = new Date();
    const dataRiepilogo = formatSiaeDateCompact(now);
    const oraGenerazione = formatSiaeTimeCompact(now);
    const oraEvento = formatSiaeTimeHHMM(now);
    
    // NOTA: Nessun DOCTYPE - i Web Service SIAE non risolvono DTD esterni (XXE protection)
    // FIX 2026-01-16: Usa codice sistema test P0004010 invece di EVENT4U1
    const testXml = `<?xml version="1.0" encoding="UTF-8"?>
<RiepilogoControlloAccessi Sostituzione="N">
  <Titolare>
    <DenominazioneTitolareCA>${escapeXml(companyName)}</DenominazioneTitolareCA>
    <CFTitolareCA>TSTSAE00A00A000A</CFTitolareCA>
    <CodiceSistemaCA>${TEST_SYSTEM_CODE}</CodiceSistemaCA>
    <DataRiepilogo>${dataRiepilogo}</DataRiepilogo>
    <DataGenerazioneRiepilogo>${dataRiepilogo}</DataGenerazioneRiepilogo>
    <OraGenerazioneRiepilogo>${oraGenerazione}</OraGenerazioneRiepilogo>
    <ProgressivoRiepilogo>1</ProgressivoRiepilogo>
  </Titolare>
  <Evento>
    <CFOrganizzatore>TSTSAE00A00A000A</CFOrganizzatore>
    <DenominazioneOrganizzatore>${escapeXml(companyName)}</DenominazioneOrganizzatore>
    <TipologiaOrganizzatore>G</TipologiaOrganizzatore>
    <SpettacoloIntrattenimento>N</SpettacoloIntrattenimento>
    <IncidenzaIntrattenimento>100</IncidenzaIntrattenimento>
    <DenominazioneLocale>Test Locale</DenominazioneLocale>
    <CodiceLocale>0000000000000</CodiceLocale>
    <DataEvento>${dataRiepilogo}</DataEvento>
    <OraEvento>${oraEvento}</OraEvento>
    <TipoGenere>DI</TipoGenere>
    <TitoloEvento>Test Event</TitoloEvento>
    <Autore></Autore>
    <Esecutore></Esecutore>
    <NazionalitaFilm></NazionalitaFilm>
    <NumOpereRappresentate>1</NumOpereRappresentate>
    <SistemaEmissione CFTitolare="TSTSAE00A00A000A" CodiceSistema="${TEST_SYSTEM_CODE}">
      <Titoli>
        <CodiceOrdinePosto>A0</CodiceOrdinePosto>
        <Capienza>100</Capienza>
        <TotaleTipoTitolo>
          <TipoTitolo>IN</TipoTitolo>
          <TotaleTitoliLTA>1</TotaleTitoliLTA>
          <TotaleTitoliNoAccessoTradiz>0</TotaleTitoliNoAccessoTradiz>
          <TotaleTitoliNoAccessoDigitali>0</TotaleTitoliNoAccessoDigitali>
          <TotaleTitoliLTAAccessoTradiz>1</TotaleTitoliLTAAccessoTradiz>
          <TotaleTitoliLTAAccessoDigitali>0</TotaleTitoliLTAAccessoDigitali>
          <TotaleCorrispettiviLordi>1000</TotaleCorrispettiviLordi>
          <TotaleDirittiPrevendita>0</TotaleDirittiPrevendita>
          <TotaleIVACorrispettivi>100</TotaleIVACorrispettivi>
          <TotaleIVADirittiPrevendita>0</TotaleIVADirittiPrevendita>
        </TotaleTipoTitolo>
        <TotaleTitoliAnnullati>
          <TipoTitolo>IN</TipoTitolo>
          <TotaleTitoliAnnull>0</TotaleTitoliAnnull>
          <TotaleCorrispettiviLordiAnnull>0</TotaleCorrispettiviLordiAnnull>
          <TotaleDirittiPrevenditaAnnull>0</TotaleDirittiPrevenditaAnnull>
          <TotaleIVACorrispettiviAnnull>0</TotaleIVACorrispettiviAnnull>
          <TotaleIVADirittiPrevenditaAnnull>0</TotaleIVADirittiPrevenditaAnnull>
        </TotaleTitoliAnnullati>
      </Titoli>
    </SistemaEmissione>
  </Evento>
</RiepilogoControlloAccessi>`;
    
    // Import and send the test email
    const { sendSiaeTransmissionEmail } = await import('./email-service');
    
    const emailResult = await sendSiaeTransmissionEmail({
      to: toEmail,
      companyName,
      transmissionType: 'daily',
      periodDate: now,
      ticketsCount: 1,
      totalAmount: '10.00',
      xmlContent: testXml,
      transmissionId: 'TEST-' + Date.now(),
      systemCode: TEST_SYSTEM_CODE, // FIX 2026-01-16: Usa codice test valido
      sequenceNumber: 1,
      signWithSmime: true, // Per Allegato C SIAE 1.6.2 - firma S/MIME obbligatoria
      requireSignature: true,
    });
    
    if (!emailResult.success) {
      return res.status(400).json({ 
        success: false, 
        message: emailResult.error || 'Invio email fallito - Firma S/MIME richiesta'
      });
    }
    
    res.json({
      success: true,
      message: `Email di test inviata con successo a ${toEmail}${emailResult.smimeSigned ? ' (S/MIME firmata)' : ' (NON firmata S/MIME - bridge non connesso)'}`,
      smimeSigned: emailResult.smimeSigned,
      smimeSignerEmail: emailResult.signerEmail,
    });
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to send test email:', error);
    res.status(500).json({ message: error.message });
  }
});

// Gmail OAuth - Get authorization URL (system-wide, no companyId needed)
router.get("/api/gmail/auth", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { getAuthUrl } = await import('./gmail-oauth');
    const authUrl = getAuthUrl();
    res.json({ authUrl });
  } catch (error: any) {
    console.error('[Gmail OAuth] Error generating auth URL:', error);
    res.status(500).json({ message: error.message });
  }
});

// Gmail OAuth - Callback from Google (system-wide)
router.get("/api/gmail/callback", async (req: Request, res: Response) => {
  try {
    const { code, error: oauthError } = req.query;
    
    if (oauthError) {
      console.error('[Gmail OAuth] OAuth error:', oauthError);
      return res.redirect('/siae/transmissions?gmail_error=access_denied');
    }
    
    if (!code) {
      return res.redirect('/siae/transmissions?gmail_error=missing_params');
    }
    
    const { exchangeCodeForTokens, saveSystemTokens } = await import('./gmail-oauth');
    
    // Exchange code for tokens
    const tokens = await exchangeCodeForTokens(code as string);
    
    // Save system-wide tokens
    await saveSystemTokens(tokens);
    
    console.log(`[Gmail OAuth] Successfully connected Gmail system-wide (${tokens.email})`);
    
    res.redirect(`/siae/transmissions?gmail_success=true&gmail_email=${encodeURIComponent(tokens.email || '')}`);
  } catch (error: any) {
    console.error('[Gmail OAuth] Callback error:', error);
    res.redirect('/siae/transmissions?gmail_error=' + encodeURIComponent(error.message));
  }
});

// Gmail OAuth - Get status (system-wide, no companyId needed)
router.get("/api/gmail/status", requireAuth, async (req: Request, res: Response) => {
  try {
    const { isGmailConnected } = await import('./gmail-oauth');
    const status = await isGmailConnected();
    res.json({
      authorized: status.connected,
      connected: status.connected,
      email: status.email,
      expiresAt: status.expiresAt,
    });
  } catch (error: any) {
    console.error('[Gmail OAuth] Error checking status:', error);
    res.status(500).json({ message: error.message });
  }
});

// Gmail OAuth - Disconnect (system-wide)
router.delete("/api/gmail/revoke", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { disconnectGmail } = await import('./gmail-oauth');
    await disconnectGmail();
    res.json({ success: true, message: "Gmail disconnesso" });
  } catch (error: any) {
    console.error('[Gmail OAuth] Error disconnecting:', error);
    res.status(500).json({ message: error.message });
  }
});

// Check for SIAE email responses and update transmission statuses
router.post("/api/siae/transmissions/check-responses", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { checkForSiaeResponses } = await import('./gmail-client');
    const companyId = req.query.companyId as string || (req.user as any)?.companyId;
    
    console.log(`[SIAE-ROUTES] Checking for SIAE email responses (company: ${companyId})...`);
    const responses = await checkForSiaeResponses(companyId);
    
    const updates: Array<{transmissionId: string; status: string; protocolNumber?: string; errorCode?: string}> = [];
    
    // Get all transmissions for matching (filter by status 'sent' in memory)
    const allTransmissions = await siaeStorage.getSiaeTransmissionsByCompany(companyId);
    const pendingTransmissions = allTransmissions.filter(t => t.status === 'sent');
    
    for (const response of responses) {
      // Skip if we don't have useful data
      if (response.status === 'unknown') continue;
      
      // Try to match with existing transmissions using multiple strategies
      let matchedTransmission = null;
      
      // Strategy 1: Direct ID match
      if (response.transmissionId) {
        matchedTransmission = await siaeStorage.getSiaeTransmission(response.transmissionId);
      }
      
      // Strategy 2: Match by subject containing filename
      if (!matchedTransmission && pendingTransmissions.length > 0) {
        for (const t of pendingTransmissions) {
          // Check if subject contains the filename
          if (t.fileName && response.subject.includes(t.fileName.replace('.xsi', ''))) {
            matchedTransmission = t;
            break;
          }
          
          // Check if any attachment filename matches transmission
          if (response.attachments && response.attachments.length > 0) {
            for (const att of response.attachments) {
              // Attachment filenames often contain date patterns like RCA_YYYY_MM_DD
              if (t.fileName && att.filename.includes(t.fileName.replace('.xsi', ''))) {
                matchedTransmission = t;
                break;
              }
            }
          }
        }
      }
      
      // Strategy 3: Match by date if only one transmission exists for that date
      // Only use this fallback if we have some parsed reference (protocol or error code)
      if (!matchedTransmission && pendingTransmissions.length > 0 && (response.protocolNumber || response.errorCode)) {
        const responseDate = response.date.toISOString().split('T')[0];
        const sameDateTransmissions = pendingTransmissions.filter(t => 
          t.sentAt && new Date(t.sentAt).toISOString().split('T')[0] === responseDate
        );
        if (sameDateTransmissions.length === 1) {
          matchedTransmission = sameDateTransmissions[0];
          console.log(`[SIAE-ROUTES] Matched by date fallback: ${matchedTransmission.id}`);
        }
      }
      
      // If we found a matching transmission and it hasn't been updated yet
      if (matchedTransmission && matchedTransmission.status === 'sent' && !matchedTransmission.responseEmailId) {
        // Determine new status
        const newStatus = response.status === 'accepted' ? 'received' : 
                         response.status === 'rejected' ? 'rejected' : 
                         response.status === 'error' ? 'error' : 'sent';
        
        // Build update payload
        const updatePayload: any = {
          status: newStatus,
          receivedAt: response.date,
          receiptProtocol: response.protocolNumber || null,
          receiptContent: response.body.substring(0, 1000),
          errorMessage: response.errorMessage || null,
          responseEmailId: response.messageId, // Track which email was associated
        };
        
        // Add error code if available from attachment parsing
        if (response.errorCode) {
          updatePayload.errorCode = response.errorCode;
        }
        
        await siaeStorage.updateSiaeTransmission(matchedTransmission.id, updatePayload);
        
        updates.push({
          transmissionId: matchedTransmission.id,
          status: newStatus,
          protocolNumber: response.protocolNumber,
          errorCode: response.errorCode,
        });
        
        // Log the update
        const eventDetails = response.status === 'accepted'
          ? `Risposta SIAE positiva - Protocollo: ${response.protocolNumber}`
          : `Risposta SIAE negativa - Errore ${response.errorCode || 'sconosciuto'}: ${response.errorMessage || 'Dettagli non disponibili'}`;
          
        await siaeStorage.createSiaeLog({
          companyId: matchedTransmission.companyId,
          logType: response.status === 'accepted' ? 'transmission_confirmed' : 'transmission_error',
          eventDetails,
          transmissionId: matchedTransmission.id,
          cfOrganizzatore: '',
          cfTitolare: '',
        });
        
        console.log(`[SIAE-ROUTES] Updated transmission ${matchedTransmission.id}: ${newStatus}`);
      }
    }
    
    res.json({
      success: true,
      totalEmails: responses.length,
      updatedTransmissions: updates.length,
      updates,
      responses: responses.map(r => ({
        messageId: r.messageId,
        subject: r.subject,
        from: r.from,
        date: r.date,
        status: r.status,
        protocolNumber: r.protocolNumber,
        errorCode: r.errorCode,
        transmissionId: r.transmissionId,
        attachments: r.attachments?.map(a => ({
          filename: a.filename,
          parsed: a.parsed
        })),
      })),
    });
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to check SIAE responses:', error);
    
    // Check for Gmail permission errors
    if (error.message?.includes('Insufficient Permission') || 
        error.message?.includes('GMAIL_PERMISSION_ERROR') ||
        error.code === 403) {
      return res.status(403).json({ 
        message: "Il connettore Gmail non ha i permessi per leggere le email. " +
                 "Per abilitare la verifica automatica delle risposte SIAE, ricollega il connettore Gmail " +
                 "con i permessi di lettura (Strumenti → Connettori → Gmail → Ricollega). " +
                 "In alternativa, puoi confermare manualmente il protocollo cliccando su una trasmissione e inserendo il numero di protocollo ricevuto.",
        code: 'GMAIL_PERMISSION_DENIED',
        canUseManualConfirm: true
      });
    }
    
    if (error.message?.includes('Gmail not connected') || 
        error.message?.includes('GMAIL_NOT_CONNECTED')) {
      return res.status(400).json({ 
        message: "Connettore Gmail non configurato. " +
                 "Per la verifica automatica delle risposte SIAE, configura il connettore Gmail (Strumenti → Connettori → Gmail). " +
                 "In alternativa, puoi confermare manualmente il protocollo cliccando su una trasmissione.",
        code: 'GMAIL_NOT_CONNECTED',
        canUseManualConfirm: true
      });
    }
    
    res.status(500).json({ message: error.message });
  }
});

// Confirm transmission receipt from SIAE
router.post("/api/siae/transmissions/:id/confirm-receipt", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { receiptProtocol, receiptContent, receivedAt } = req.body;
    
    if (!receiptProtocol) {
      return res.status(400).json({ message: "Il protocollo di ricezione è obbligatorio" });
    }
    
    const transmission = await siaeStorage.getSiaeTransmission(id);
    if (!transmission) {
      return res.status(404).json({ message: "Trasmissione non trovata" });
    }
    
    if (transmission.status !== 'sent') {
      return res.status(400).json({ message: "La trasmissione deve essere in stato 'inviato' per confermare la ricezione" });
    }
    
    // Update transmission with receipt info
    const updatedTransmission = await siaeStorage.updateSiaeTransmission(id, {
      status: 'received',
      receivedAt: receivedAt ? new Date(receivedAt) : new Date(),
      receiptProtocol,
      receiptContent: receiptContent || null,
    });
    
    // Log the confirmation
    await siaeStorage.createSiaeLog({
      companyId: transmission.companyId,
      logType: 'transmission_confirmed',
      eventDetails: `Conferma ricezione trasmissione ${id} - Protocollo: ${receiptProtocol}`,
      transmissionId: id,
      cfOrganizzatore: '',
      cfTitolare: '',
    });
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: transmission.companyId,
      userId: user.id,
      action: 'transmission_receipt_confirmed',
      entityType: 'transmission',
      entityId: id,
      description: `Conferma ricezione trasmissione - Protocollo SIAE: ${receiptProtocol}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json({
      success: true,
      message: "Conferma ricezione registrata con successo",
      transmission: updatedTransmission,
    });
  } catch (error: any) {
    console.error('[SIAE-ROUTES] Failed to confirm transmission receipt:', error);
    res.status(500).json({ message: error.message });
  }
});

// ==================== Box Office Sessions ====================

router.get("/api/siae/emission-channels/:channelId/sessions", requireAuth, async (req: Request, res: Response) => {
  try {
    const sessions = await siaeStorage.getSiaeBoxOfficeSessions(req.params.channelId);
    res.json(sessions);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/admin/box-office/sessions", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const sessions = await siaeStorage.getAllSiaeBoxOfficeSessionsAdmin();
    res.json(sessions);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/box-office/sessions", requireAuth, async (req: Request, res: Response) => {
  try {
    const sessions = await siaeStorage.getAllSiaeBoxOfficeSessions();
    res.json(sessions);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/box-office/active-session", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const session = await siaeStorage.getActiveSiaeBoxOfficeSession(user.id);
    res.json(session || null);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/box-office/sessions", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const data = insertSiaeBoxOfficeSessionSchema.parse({ ...req.body, userId: user.id });
    const session = await siaeStorage.createSiaeBoxOfficeSession(data);
    
    // Get companyId from emission channel or ticketed event
    let companyId = user.companyId;
    if (data.emissionChannelId) {
      const channel = await siaeStorage.getSiaeEmissionChannel(data.emissionChannelId);
      if (channel?.companyId) {
        companyId = channel.companyId;
      }
    }
    if (companyId) {
      await siaeStorage.createAuditLog({
        companyId,
        userId: user.id,
        action: 'box_office_session_created',
        entityType: 'box_office_session',
        entityId: session.id,
        description: `Sessione cassa aperta`,
        ipAddress: req.ip,
        userAgent: req.get('user-agent'),
      });
    }
    
    res.status(201).json(session);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.post("/api/siae/box-office/sessions/:id/close", requireAuth, async (req: Request, res: Response) => {
  try {
    const session = await siaeStorage.closeSiaeBoxOfficeSession(req.params.id, req.body);
    if (!session) {
      return res.status(404).json({ message: "Sessione non trovata" });
    }
    
    const user = req.user as any;
    
    // Get companyId from emission channel or ticketed event
    let companyId = user.companyId;
    if (session.emissionChannelId) {
      const channel = await siaeStorage.getSiaeEmissionChannel(session.emissionChannelId);
      if (channel?.companyId) {
        companyId = channel.companyId;
      }
    }
    if (companyId) {
      await siaeStorage.createAuditLog({
        companyId,
        userId: user.id,
        action: 'box_office_session_closed',
        entityType: 'box_office_session',
        entityId: session.id,
        description: `Sessione cassa chiusa`,
        ipAddress: req.ip,
        userAgent: req.get('user-agent'),
      });
    }
    
    res.json(session);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Subscriptions ====================

router.get("/api/siae/companies/:companyId/subscriptions", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const subscriptions = await siaeStorage.getSiaeSubscriptionsByCompany(req.params.companyId);
    res.json(subscriptions);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Admin endpoint to get all subscriptions with company details
// Supports query filters: companyId, ticketedEventId
router.get("/api/siae/admin/subscriptions", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const isSuperAdmin = user.role === 'super_admin';
    const userCompanyId = user.companyId;
    
    // Query parameter filters
    const filterCompanyId = req.query.companyId as string | undefined;
    const filterTicketedEventId = req.query.ticketedEventId as string | undefined;
    
    // Build where conditions
    const conditions: SQL[] = [];
    
    // Company authorization: non-super_admin can only see their own company
    if (!isSuperAdmin && userCompanyId) {
      conditions.push(eq(siaeSubscriptions.companyId, userCompanyId));
    } else if (filterCompanyId) {
      // Super admin can filter by specific company
      conditions.push(eq(siaeSubscriptions.companyId, filterCompanyId));
    }
    
    // Filter by ticketed event
    if (filterTicketedEventId) {
      conditions.push(eq(siaeSubscriptions.ticketedEventId, filterTicketedEventId));
    }
    
    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;
    
    const results = await db.select({
      id: siaeSubscriptions.id,
      companyId: siaeSubscriptions.companyId,
      customerId: siaeSubscriptions.customerId,
      ticketedEventId: siaeSubscriptions.ticketedEventId,
      subscriptionCode: siaeSubscriptions.subscriptionCode,
      progressiveNumber: siaeSubscriptions.progressiveNumber,
      turnType: siaeSubscriptions.turnType,
      eventsCount: siaeSubscriptions.eventsCount,
      eventsUsed: siaeSubscriptions.eventsUsed,
      validFrom: siaeSubscriptions.validFrom,
      validTo: siaeSubscriptions.validTo,
      totalAmount: siaeSubscriptions.totalAmount,
      rateoPerEvent: siaeSubscriptions.rateoPerEvent,
      holderFirstName: siaeSubscriptions.holderFirstName,
      holderLastName: siaeSubscriptions.holderLastName,
      status: siaeSubscriptions.status,
      cancellationReasonCode: siaeSubscriptions.cancellationReasonCode,
      cancellationDate: siaeSubscriptions.cancellationDate,
      createdAt: siaeSubscriptions.createdAt,
      companyName: companies.name,
      customerFirstName: siaeCustomers.firstName,
      customerLastName: siaeCustomers.lastName,
      eventName: events.name,
    })
    .from(siaeSubscriptions)
    .leftJoin(companies, eq(siaeSubscriptions.companyId, companies.id))
    .leftJoin(siaeCustomers, eq(siaeSubscriptions.customerId, siaeCustomers.id))
    .leftJoin(siaeTicketedEvents, eq(siaeSubscriptions.ticketedEventId, siaeTicketedEvents.id))
    .leftJoin(events, eq(siaeTicketedEvents.eventId, events.id))
    .where(whereClause)
    .orderBy(desc(siaeSubscriptions.createdAt));
    
    res.json(results);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/subscriptions", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    
    let customerId = req.body.customerId;
    
    // Se customerId non è fornito, creare automaticamente un nuovo cliente SIAE
    if (!customerId && req.body.holderFirstName && req.body.holderLastName) {
      const uniqueId = crypto.randomUUID().replace(/-/g, '').substring(0, 12).toUpperCase();
      const newCustomer = await siaeStorage.createSiaeCustomer({
        firstName: req.body.holderFirstName,
        lastName: req.body.holderLastName,
        uniqueCode: `CLT${uniqueId}`,
        email: `auto_${uniqueId}@placeholder.local`,
        phone: `+39000${uniqueId.substring(0, 7)}`,
        isActive: true,
      });
      customerId = newCustomer.id;
    }
    
    if (!customerId) {
      return res.status(400).json({ 
        message: "customerId richiesto oppure fornire holderFirstName e holderLastName per creare un nuovo cliente" 
      });
    }
    
    const data = insertSiaeSubscriptionSchema.parse({
      ...req.body,
      customerId,
    });
    const subscription = await siaeStorage.createSiaeSubscription(data);
    
    await siaeStorage.createAuditLog({
      companyId: subscription.companyId || user.companyId,
      userId: user.id,
      action: 'subscription_created',
      entityType: 'subscription',
      entityId: subscription.id,
      description: `Abbonamento creato: ${subscription.subscriptionCode}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.status(201).json(subscription);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/subscriptions/:id", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = patchSubscriptionSchema.parse(req.body);
    const subscription = await siaeStorage.updateSiaeSubscription(req.params.id, data);
    if (!subscription) {
      return res.status(404).json({ message: "Abbonamento non trovato" });
    }
    
    const user = req.user as any;
    await siaeStorage.createAuditLog({
      companyId: subscription.companyId || user.companyId,
      userId: user.id,
      action: 'subscription_updated',
      entityType: 'subscription',
      entityId: subscription.id,
      description: `Abbonamento aggiornato: ${subscription.subscriptionCode}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json(subscription);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// Valid SIAE cancellation reason codes (TAB.5)
const VALID_CANCELLATION_REASON_CODES = ['001', '002', '003', '004', '005', '006', '007', '009'];
const CANCELLATION_REASON_DESCRIPTIONS: Record<string, string> = {
  '001': 'Errore del cassiere',
  '002': 'Errore del cliente',
  '003': 'Evento annullato',
  '004': 'Reso autorizzato',
  '005': 'Duplicato',
  '006': 'Sostituzione',
  '007': 'Rimborso',
  '009': 'Annullamento fiscale',
};

// Cancel subscription with SIAE compliance
router.post("/api/siae/subscriptions/:id/cancel", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const user = req.user as any;
    const { reasonCode } = req.body;
    
    // Validate reasonCode is provided
    if (!reasonCode) {
      return res.status(400).json({ 
        message: "Causale annullamento obbligatoria (reasonCode)",
        validCodes: CANCELLATION_REASON_DESCRIPTIONS
      });
    }
    
    // Validate reasonCode is valid per SIAE TAB.5
    if (!VALID_CANCELLATION_REASON_CODES.includes(reasonCode)) {
      return res.status(400).json({ 
        message: `Causale annullamento non valida: ${reasonCode}`,
        validCodes: CANCELLATION_REASON_DESCRIPTIONS
      });
    }
    
    // Fetch subscription
    const [subscription] = await db.select()
      .from(siaeSubscriptions)
      .where(eq(siaeSubscriptions.id, id));
    
    if (!subscription) {
      return res.status(404).json({ message: "Abbonamento non trovato" });
    }
    
    // Check if already cancelled
    if (subscription.status === 'cancelled') {
      return res.status(400).json({ 
        message: "Abbonamento già annullato",
        cancellationDate: subscription.cancellationDate,
        cancellationReasonCode: subscription.cancellationReasonCode
      });
    }
    
    // Check user authorization (same company or super_admin)
    const isSuperAdmin = user.role === 'super_admin';
    if (!isSuperAdmin && user.companyId !== subscription.companyId) {
      return res.status(403).json({ message: "Non autorizzato ad annullare questo abbonamento" });
    }
    
    const cancellationDate = new Date();
    
    // Update subscription status
    const [updatedSubscription] = await db.update(siaeSubscriptions)
      .set({
        status: 'cancelled',
        cancellationDate,
        cancellationReasonCode: reasonCode,
        cancelledByUserId: user.id,
        updatedAt: new Date(),
      })
      .where(eq(siaeSubscriptions.id, id))
      .returning();
    
    // Create audit log entry
    await siaeStorage.createAuditLog({
      companyId: subscription.companyId,
      userId: user.id,
      action: 'subscription_cancelled',
      entityType: 'subscription',
      entityId: id,
      description: `Abbonamento ${subscription.subscriptionCode} annullato. Causale: ${reasonCode} - ${CANCELLATION_REASON_DESCRIPTIONS[reasonCode]}`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json({
      ...updatedSubscription,
      cancellationReasonDescription: CANCELLATION_REASON_DESCRIPTIONS[reasonCode],
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Print subscription to thermal printer
router.post("/api/siae/subscriptions/:id/print", requireAuth, async (req: Request, res: Response) => {
  console.log('[SubscriptionPrint] Endpoint hit! subscriptionId:', req.params.id);
  try {
    const user = req.user as any;
    const { id: subscriptionId } = req.params;
    const { agentId } = req.body;
    
    // Get the subscription
    const [subscription] = await db.select()
      .from(siaeSubscriptions)
      .where(eq(siaeSubscriptions.id, subscriptionId));
    
    if (!subscription) {
      return res.status(404).json({ message: "Abbonamento non trovato" });
    }
    
    // Verify company access
    if (user.role !== 'super_admin' && subscription.companyId !== user.companyId) {
      return res.status(403).json({ message: "Non autorizzato" });
    }
    
    // Get event details
    const event = subscription.ticketedEventId 
      ? await siaeStorage.getSiaeTicketedEvent(subscription.ticketedEventId)
      : null;
    
    // Get sector
    const sector = subscription.sectorId 
      ? await siaeStorage.getSiaeEventSector(subscription.sectorId)
      : null;
    
    // Get SIAE system config
    const systemConfig = await siaeStorage.getSiaeSystemConfig(subscription.companyId);
    
    // Get connected agents
    const connectedAgents = getConnectedAgents(subscription.companyId);
    
    if (connectedAgents.length === 0) {
      return res.status(503).json({ 
        message: "Nessun agente di stampa connesso. Avviare l'applicazione desktop Event4U.",
        errorCode: "NO_PRINT_AGENT"
      });
    }
    
    // Determine print agent
    let printerAgentId = agentId;
    if (!printerAgentId && connectedAgents.length === 1) {
      printerAgentId = connectedAgents[0].agentId;
    }
    
    if (!printerAgentId) {
      return res.status(400).json({
        message: "Selezionare un agente di stampa",
        errorCode: "AGENT_SELECTION_REQUIRED",
        availableAgents: connectedAgents.map(a => ({
          agentId: a.agentId,
          deviceName: a.deviceName
        }))
      });
    }
    
    // Verify agent is connected
    const selectedAgent = connectedAgents.find(a => a.agentId === printerAgentId);
    if (!selectedAgent) {
      return res.status(400).json({
        message: "Agente di stampa non connesso",
        errorCode: "AGENT_NOT_CONNECTED"
      });
    }
    
    // Prepare subscription data for template replacement
    const holderName = `${subscription.holderFirstName || ''} ${subscription.holderLastName || ''}`.trim();
    const validFromStr = subscription.validFrom ? new Date(subscription.validFrom).toLocaleDateString('it-IT') : '';
    const validToStr = subscription.validTo ? new Date(subscription.validTo).toLocaleDateString('it-IT') : '';
    const totalAmountStr = `€ ${Number(subscription.totalAmount || 0).toFixed(2).replace('.', ',')}`;
    const emissionDateStr = subscription.createdAt ? new Date(subscription.createdAt).toLocaleString('it-IT') : new Date().toLocaleString('it-IT');
    
    // Map subscription data to template field keys
    const subscriptionData: Record<string, string> = {
      subscription_code: subscription.subscriptionCode || '',
      subscriber_name: holderName || 'N/D',
      subscription_type: subscription.subscriptionTypeId || '',
      total_entries: String(subscription.eventsCount || 0),
      used_entries: String(subscription.eventsUsed || 0),
      remaining_entries: String((subscription.eventsCount || 0) - (subscription.eventsUsed || 0)),
      valid_from: validFromStr,
      valid_to: validToStr,
      price: totalAmountStr,
      venue_name: event?.eventName || '',
      custom_text: '',
      // SIAE required fields
      organizer_company: systemConfig?.businessName || '',
      ticketing_manager: systemConfig?.businessName || '',
      emission_datetime: emissionDateStr,
      fiscal_seal: subscription.fiscalSealCode || '',
      fiscal_counter: String(subscription.fiscalSealCounter || ''),
      card_code: subscription.cardCode || '',
      qr_code: subscription.subscriptionCode || '',
    };
    
    // Try to find a subscription template for this company
    let subscriptionHtml: string;
    let paperWidthMm = 80;
    let paperHeightMm = 120;
    let printOrientation = 'portrait';
    
    const [subscriptionTemplate] = await db.select()
      .from(ticketTemplates)
      .where(and(
        eq(ticketTemplates.templateType, 'subscription'),
        eq(ticketTemplates.isActive, true),
        or(
          eq(ticketTemplates.companyId, subscription.companyId),
          isNull(ticketTemplates.companyId)
        )
      ))
      .orderBy(desc(ticketTemplates.createdAt))
      .limit(1);
    
    if (subscriptionTemplate) {
      // Use template to generate HTML
      const templateElements = await db.select()
        .from(ticketTemplateElements)
        .where(eq(ticketTemplateElements.templateId, subscriptionTemplate.id))
        .orderBy(ticketTemplateElements.zIndex);
      
      const parsedElements = templateElements.map(el => ({
        type: el.type,
        x: parseFloat(el.x as any) || 0,
        y: parseFloat(el.y as any) || 0,
        width: parseFloat(el.width as any) || 20,
        height: parseFloat(el.height as any) || 5,
        content: el.fieldKey ? `{{${el.fieldKey}}}` : el.staticValue,
        fontSize: el.fontSize,
        fontFamily: el.fontFamily,
        fontWeight: el.fontWeight,
        fontColor: el.color,
        textAlign: el.textAlign,
        rotation: el.rotation,
      }));
      
      paperWidthMm = subscriptionTemplate.paperWidthMm || 80;
      paperHeightMm = subscriptionTemplate.paperHeightMm || 120;
      printOrientation = (subscriptionTemplate as any).printOrientation || 'auto';
      
      subscriptionHtml = generateTicketHtml(
        {
          paperWidthMm,
          paperHeightMm,
          backgroundImageUrl: subscriptionTemplate.backgroundImageUrl,
          dpi: subscriptionTemplate.dpi || 203,
          printOrientation,
        },
        parsedElements,
        subscriptionData,
        true // skipBackground for thermal printing
      );
      
      console.log('[SubscriptionPrint] Using template:', subscriptionTemplate.name);
    } else {
      // Fallback to hardcoded HTML
      console.log('[SubscriptionPrint] No template found, using fallback HTML');
      subscriptionHtml = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      width: ${paperWidthMm}mm; 
      font-family: Arial, sans-serif; 
      font-size: 10pt;
      padding: 3mm;
    }
    .header { text-align: center; margin-bottom: 4mm; }
    .title { font-size: 14pt; font-weight: bold; margin-bottom: 2mm; }
    .subtitle { font-size: 10pt; color: #666; }
    .divider { border-top: 1px dashed #000; margin: 3mm 0; }
    .row { display: flex; justify-content: space-between; margin: 1.5mm 0; }
    .label { color: #666; font-size: 9pt; }
    .value { font-weight: bold; text-align: right; }
    .holder { font-size: 12pt; font-weight: bold; text-align: center; margin: 3mm 0; }
    .code { font-family: monospace; font-size: 11pt; text-align: center; margin: 3mm 0; letter-spacing: 1px; }
    .fiscal { font-size: 8pt; color: #666; text-align: center; margin-top: 3mm; }
    .qr { text-align: center; margin: 3mm 0; }
    .usage { text-align: center; font-size: 11pt; margin: 2mm 0; }
    .events-box { border: 1px solid #000; padding: 2mm; text-align: center; margin: 2mm 0; }
  </style>
</head>
<body>
  <div class="header">
    <div class="title">ABBONAMENTO</div>
    <div class="subtitle">${event?.eventName || 'Evento'}</div>
  </div>
  
  <div class="divider"></div>
  
  <div class="holder">${holderName || 'Intestatario N/D'}</div>
  
  <div class="code">${subscription.subscriptionCode || ''}</div>
  
  <div class="divider"></div>
  
  <div class="row">
    <span class="label">Settore:</span>
    <span class="value">${sector?.name || '-'}</span>
  </div>
  
  <div class="row">
    <span class="label">Turno:</span>
    <span class="value">${subscription.turnType || '-'}</span>
  </div>
  
  <div class="row">
    <span class="label">Valido dal:</span>
    <span class="value">${validFromStr || '-'}</span>
  </div>
  
  <div class="row">
    <span class="label">Valido al:</span>
    <span class="value">${validToStr || '-'}</span>
  </div>
  
  <div class="divider"></div>
  
  <div class="events-box">
    <div class="label">INGRESSI</div>
    <div class="usage">${subscription.eventsUsed || 0} / ${subscription.eventsCount || 0}</div>
  </div>
  
  <div class="row">
    <span class="label">Importo:</span>
    <span class="value">${totalAmountStr}</span>
  </div>
  
  ${subscription.fiscalSealCode ? `
  <div class="row">
    <span class="label">Sigillo:</span>
    <span class="value" style="font-family: monospace;">${subscription.fiscalSealCode}</span>
  </div>
  ` : ''}
  
  <div class="divider"></div>
  
  <div class="fiscal">
    ${systemConfig?.businessName || ''}<br/>
    ${systemConfig?.vatNumber ? `P.IVA ${systemConfig.vatNumber}` : ''}
  </div>
</body>
</html>`;
    }
    
    // Determine effective orientation
    const naturalOrientation = paperWidthMm > paperHeightMm ? 'landscape' : 'portrait';
    const effectiveOrientation = printOrientation === 'auto' ? naturalOrientation : printOrientation;
    
    // Build print payload (use type 'ticket' for agent compatibility)
    const printPayload = {
      id: `subscription-${subscription.id}-${Date.now()}`,
      type: 'ticket',
      paperWidthMm,
      paperHeightMm,
      orientation: effectiveOrientation,
      html: subscriptionHtml,
      ticketId: subscription.id,
    };
    
    // Send to print agent
    const sent = sendPrintJobToAgent(printerAgentId, printPayload);
    
    if (!sent) {
      return res.status(503).json({
        message: "Impossibile inviare comando di stampa all'agente",
        errorCode: "PRINT_SEND_FAILED"
      });
    }
    
    // Update subscription updated timestamp
    await db.update(siaeSubscriptions)
      .set({ 
        updatedAt: new Date()
      })
      .where(eq(siaeSubscriptions.id, subscriptionId));
    
    // Audit log
    await siaeStorage.createAuditLog({
      companyId: subscription.companyId,
      userId: user.id,
      action: 'subscription_printed',
      entityType: 'subscription',
      entityId: subscriptionId,
      description: `Abbonamento ${subscription.subscriptionCode} stampato`,
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
    });
    
    res.json({
      success: true,
      subscriptionId,
      subscriptionCode: subscription.subscriptionCode,
      printedAt: new Date(),
      agentId: printerAgentId,
      deviceName: selectedAgent.deviceName
    });
  } catch (error: any) {
    console.error('[SubscriptionPrint] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

// Get subscription usage history
router.get("/api/siae/subscriptions/:id/usage", requireAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const user = req.user as any;
    
    // Fetch subscription
    const [subscription] = await db.select()
      .from(siaeSubscriptions)
      .where(eq(siaeSubscriptions.id, id));
    
    if (!subscription) {
      return res.status(404).json({ message: "Abbonamento non trovato" });
    }
    
    // Check user authorization (same company or super_admin)
    const isSuperAdmin = user.role === 'super_admin';
    if (!isSuperAdmin && user.companyId !== subscription.companyId) {
      return res.status(403).json({ message: "Non autorizzato a visualizzare questo abbonamento" });
    }
    
    // Get usage from audit logs (validate actions on subscriptions)
    const usageFromAudit = await db.select({
      id: siaeAuditLogs.id,
      action: siaeAuditLogs.action,
      description: siaeAuditLogs.description,
      accessDate: siaeAuditLogs.createdAt,
      ipAddress: siaeAuditLogs.ipAddress,
      userId: siaeAuditLogs.userId,
    })
    .from(siaeAuditLogs)
    .where(and(
      eq(siaeAuditLogs.entityType, 'subscription'),
      eq(siaeAuditLogs.entityId, id),
      eq(siaeAuditLogs.action, 'validate')
    ))
    .orderBy(desc(siaeAuditLogs.createdAt));
    
    // Get event info for the subscription
    let eventInfo = null;
    if (subscription.ticketedEventId) {
      const [ticketedEvent] = await db.select({
        ticketedEventId: siaeTicketedEvents.id,
        eventId: events.id,
        eventName: events.name,
        eventDate: events.startDatetime,
        locationId: events.locationId,
      })
      .from(siaeTicketedEvents)
      .leftJoin(events, eq(siaeTicketedEvents.eventId, events.id))
      .where(eq(siaeTicketedEvents.id, subscription.ticketedEventId));
      
      eventInfo = ticketedEvent;
    }
    
    res.json({
      subscription: {
        id: subscription.id,
        subscriptionCode: subscription.subscriptionCode,
        holderFirstName: subscription.holderFirstName,
        holderLastName: subscription.holderLastName,
        eventsCount: subscription.eventsCount,
        eventsUsed: subscription.eventsUsed,
        eventsRemaining: subscription.eventsCount - subscription.eventsUsed,
        validFrom: subscription.validFrom,
        validTo: subscription.validTo,
        status: subscription.status,
      },
      event: eventInfo,
      usageHistory: usageFromAudit.map(usage => ({
        id: usage.id,
        accessDate: usage.accessDate,
        action: usage.action,
        description: usage.description,
        ipAddress: usage.ipAddress,
        validatedBy: usage.userId,
      })),
      totalAccesses: usageFromAudit.length,
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Subscription Types ====================

router.get("/api/siae/ticketed-events/:eventId/subscription-types", requireAuth, async (req: Request, res: Response) => {
  try {
    const { eventId } = req.params;
    const subscriptionTypes = await db.select()
      .from(siaeSubscriptionTypes)
      .where(eq(siaeSubscriptionTypes.ticketedEventId, eventId));
    res.json(subscriptionTypes);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/ticketed-events/:eventId/subscription-types", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const { eventId } = req.params;
    const user = req.user as any;
    
    // Get companyId from the ticketed event (safer than relying on user.companyId which can be null for super_admin)
    const [ticketedEvent] = await db.select({ companyId: siaeTicketedEvents.companyId })
      .from(siaeTicketedEvents)
      .where(eq(siaeTicketedEvents.id, eventId));
    
    if (!ticketedEvent) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    const data = insertSiaeSubscriptionTypeSchema.parse({
      ...req.body,
      ticketedEventId: eventId,
      companyId: ticketedEvent.companyId,
    });
    
    const [subscriptionType] = await db.insert(siaeSubscriptionTypes)
      .values(data)
      .returning();
    res.status(201).json(subscriptionType);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/subscription-types/:id", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = patchSubscriptionTypeSchema.parse(req.body);
    const [subscriptionType] = await db.update(siaeSubscriptionTypes)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(siaeSubscriptionTypes.id, req.params.id))
      .returning();
    if (!subscriptionType) {
      return res.status(404).json({ message: "Tipo abbonamento non trovato" });
    }
    res.json(subscriptionType);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.delete("/api/siae/subscription-types/:id", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const [deleted] = await db.delete(siaeSubscriptionTypes)
      .where(eq(siaeSubscriptionTypes.id, req.params.id))
      .returning();
    if (!deleted) {
      return res.status(404).json({ message: "Tipo abbonamento non trovato" });
    }
    res.json({ message: "Tipo abbonamento eliminato", id: deleted.id });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Event Subscriptions ====================

router.get("/api/siae/ticketed-events/:eventId/subscriptions", requireAuth, async (req: Request, res: Response) => {
  try {
    const { eventId } = req.params;
    const subscriptions = await db.select()
      .from(siaeSubscriptions)
      .where(eq(siaeSubscriptions.ticketedEventId, eventId));
    res.json(subscriptions);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/ticketed-events/:eventId/subscriptions", requireAuth, async (req: Request, res: Response) => {
  try {
    const { eventId } = req.params;
    const user = req.user as any;
    
    let customerId = req.body.customerId;
    
    // Se customerId non è fornito, creare automaticamente un nuovo cliente SIAE
    if (!customerId && req.body.holderFirstName && req.body.holderLastName) {
      const uniqueId = crypto.randomUUID().replace(/-/g, '').substring(0, 12).toUpperCase();
      const newCustomer = await siaeStorage.createSiaeCustomer({
        firstName: req.body.holderFirstName,
        lastName: req.body.holderLastName,
        uniqueCode: `CLT${uniqueId}`,
        email: `auto_${uniqueId}@placeholder.local`,
        phone: `+39000${uniqueId.substring(0, 7)}`,
        isActive: true,
      });
      customerId = newCustomer.id;
    }
    
    if (!customerId) {
      return res.status(400).json({ 
        message: "customerId richiesto oppure fornire holderFirstName e holderLastName per creare un nuovo cliente" 
      });
    }
    
    const data = insertSiaeSubscriptionSchema.parse({
      ...req.body,
      customerId,
      ticketedEventId: eventId,
      companyId: user.companyId,
    });
    
    const subscription = await siaeStorage.createSiaeSubscription(data);
    res.status(201).json(subscription);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// ==================== Audit Logs ====================

router.get("/api/siae/companies/:companyId/audit-logs", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    // Verify company access for non-super-admin users
    if (user.role !== 'super_admin' && user.companyId !== req.params.companyId) {
      return res.status(403).json({ message: "Accesso negato" });
    }
    const logs = await siaeStorage.getSiaeAuditLogsByCompany(req.params.companyId);
    res.json(logs);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/audit-logs/entity/:entityType/:entityId", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const logs = await siaeStorage.getSiaeAuditLogsByEntity(req.params.entityType, req.params.entityId);
    res.json(logs);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/audit-logs", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeAuditLogSchema.parse(req.body);
    const log = await siaeStorage.createSiaeAuditLog(data);
    res.status(201).json(log);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

// ==================== Numbered Seats ====================

router.get("/api/siae/sectors/:sectorId/numbered-seats", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const seats = await siaeStorage.getSiaeNumberedSeatsBySector(req.params.sectorId);
    res.json(seats);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.get("/api/siae/numbered-seats/:id", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const seat = await siaeStorage.getSiaeNumberedSeat(req.params.id);
    if (!seat) {
      return res.status(404).json({ message: "Posto non trovato" });
    }
    res.json(seat);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

router.post("/api/siae/numbered-seats", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = insertSiaeNumberedSeatSchema.parse(req.body);
    const seat = await siaeStorage.createSiaeNumberedSeat(data);
    res.status(201).json(seat);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.patch("/api/siae/numbered-seats/:id", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const data = patchNumberedSeatSchema.parse(req.body);
    const seat = await siaeStorage.updateSiaeNumberedSeat(req.params.id, data);
    if (!seat) {
      return res.status(404).json({ message: "Posto non trovato" });
    }
    res.json(seat);
  } catch (error: any) {
    res.status(400).json({ message: error.message });
  }
});

router.delete("/api/siae/numbered-seats/:id", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    // SIAE Compliance: Check if any tickets reference this seat
    const [ticketCount] = await db
      .select({ count: sql<number>`count(*)` })
      .from(siaeTickets)
      .where(eq(siaeTickets.seatId, req.params.id));
    
    if (ticketCount && ticketCount.count > 0) {
      return res.status(400).json({ 
        message: "Eliminazione non consentita: questo posto ha biglietti associati. Per conformità SIAE, i dati devono essere conservati per almeno 60 giorni.",
        code: "SIAE_RETENTION_REQUIRED"
      });
    }
    
    const deleted = await siaeStorage.deleteSiaeNumberedSeat(req.params.id);
    if (!deleted) {
      return res.status(404).json({ message: "Posto non trovato" });
    }
    res.status(204).send();
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Seed Endpoint (Super Admin - one time) ====================

router.post("/api/siae/seed", requireAuth, requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    await siaeStorage.seedSiaeTables();
    res.json({ message: "Tabelle SIAE inizializzate con successo" });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Public seed endpoint for initial setup
router.post("/api/siae/seed-public", async (req: Request, res: Response) => {
  try {
    await siaeStorage.seedSiaeTables();
    res.json({ message: "Tabelle SIAE inizializzate con successo" });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== XML Report Generation (SIAE Transmission) ====================
// Conforme a Allegato B e C - Provvedimento Agenzia delle Entrate 04/03/2008
// NOTA 2026-01-16: generateRcaReportXml rimossa (codice morto). Usa generateRCAXml da siae-utils.ts

// ==================== generateRcaReportXml RIMOSSA ====================
// Questa funzione è stata rimossa perché:
// 1. Era codice morto (mai chiamata)
// 2. Aveva un errore di sintassi XML critico (doppio apice in <RiepilogoControlloAccessi">)
// 3. È sostituita da generateRCAXml in siae-utils.ts
// La funzione generateRCAXml centralizzata è usata da:
// - siae-scheduler.ts (linea 1135)
// - siae-routes.ts (linee 5391, 5883, 9649)

// ==================== C1 Report XML Generation Helper ====================
// Hydrate C1EventContext from filtered tickets (used to prepare data for generateC1Xml)
// Groups tickets by event and fetches all required context data
async function hydrateC1EventContextFromTickets(
  filteredTickets: any[],
  companyId: string,
  reportDate: Date,
  isMonthly: boolean
): Promise<{ events: C1EventContext[], subscriptions: C1SubscriptionData[] }> {
  const ticketsByEvent: Map<string, any[]> = new Map();
  for (const ticket of filteredTickets) {
    const eventId = ticket.ticketedEventId;
    if (!ticketsByEvent.has(eventId)) {
      ticketsByEvent.set(eventId, []);
    }
    ticketsByEvent.get(eventId)!.push(ticket);
  }
  
  const allSubscriptions = await siaeStorage.getSiaeSubscriptionsByCompany(companyId);
  const filteredSubscriptions = allSubscriptions.filter(sub => {
    const emDate = new Date(sub.emissionDate || sub.createdAt!);
    if (isMonthly) {
      return emDate.getFullYear() === reportDate.getFullYear() && 
             emDate.getMonth() === reportDate.getMonth();
    } else {
      return emDate.getFullYear() === reportDate.getFullYear() && 
             emDate.getMonth() === reportDate.getMonth() &&
             emDate.getDate() === reportDate.getDate();
    }
  });
  
  const allEventIds = new Set<string>([...ticketsByEvent.keys()]);
  for (const sub of filteredSubscriptions) {
    if (sub.ticketedEventId) allEventIds.add(sub.ticketedEventId);
  }
  
  const events: C1EventContext[] = [];
  
  for (const ticketedEventId of allEventIds) {
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(ticketedEventId);
    if (!ticketedEvent) continue;
    
    const eventDetails = await storage.getEvent(ticketedEvent.eventId);
    if (!eventDetails) continue;
    
    const location = await storage.getLocation(eventDetails.locationId);
    const allSectors = await siaeStorage.getSiaeEventSectors(ticketedEventId);
    const eventTickets = ticketsByEvent.get(ticketedEventId) || [];
    
    events.push({
      ticketedEvent: {
        id: ticketedEvent.id,
        companyId: ticketedEvent.companyId,
        eventId: ticketedEvent.eventId,
        siaeLocationCode: ticketedEvent.siaeLocationCode,
        capacity: ticketedEvent.capacity,
        taxType: ticketedEvent.taxType,
        entertainmentIncidence: ticketedEvent.entertainmentIncidence,
        genreCode: ticketedEvent.genreCode,
        genreIncidence: ticketedEvent.genreIncidence,
        author: ticketedEvent.author,
        performer: ticketedEvent.performer,
        organizerType: ticketedEvent.organizerType,
      },
      eventRecord: {
        id: eventDetails.id,
        name: eventDetails.name,
        startDatetime: eventDetails.startDatetime,
        locationId: eventDetails.locationId,
      },
      location: location ? {
        name: location.name,
        siaeLocationCode: location.siaeLocationCode,
      } : null,
      sectors: allSectors.map((s: any): C1SectorData => ({
        id: s.id,
        sectorCode: s.sectorCode,
        orderCode: s.sortOrder,
        capacity: s.capacity,
      })),
      tickets: eventTickets.map((t: any): C1TicketData => ({
        id: t.id,
        ticketedEventId: t.ticketedEventId,
        sectorId: t.sectorId,
        status: t.status,
        ticketTypeCode: t.ticketTypeCode,
        isComplimentary: t.isComplimentary,
        grossAmount: t.grossAmount,
        prevendita: t.prevendita,
        vatAmount: t.vatAmount,
        prevenditaVat: t.prevenditaVat,
        serviceAmount: t.serviceAmount,
        cancellationReasonCode: t.cancellationReasonCode,
        cancellationDate: t.cancellationDate,
      })),
    });
  }
  
  const subscriptions: C1SubscriptionData[] = filteredSubscriptions.map((s: any): C1SubscriptionData => ({
    id: s.id,
    subscriptionCode: s.subscriptionCode,
    ticketedEventId: s.ticketedEventId,
    sectorId: s.sectorId,
    validTo: s.validTo,
    createdAt: s.createdAt,
    taxType: s.taxType,
    turnType: s.turnType,
    ticketTypeCode: s.ticketTypeCode,
    isComplimentary: s.isComplimentary,
    status: s.status,
    totalAmount: s.totalAmount,
    rateoVat: s.rateoVat,
    eventsCount: s.eventsCount,
  }));
  
  return { events, subscriptions };
}

// NOTE: generateC1ReportXml has been replaced by the unified generateC1Xml from siae-utils.ts
// Use hydrateC1EventContextFromTickets to prepare data, then call generateC1Xml directly

// Funzioni formatSiaeDateCompact, formatSiaeTimeCompact, formatSiaeTimeHHMM
// importate da ./siae-utils.ts

/**
 * Mappa codice genere evento a codice SIAE (2 caratteri)
 * Secondo Allegato B - TAB.1
 */
function mapGenreToSiaeCode(genreCode: string | null): string {
  const genreMap: Record<string, string> = {
    '60': 'DI', // Discoteca/Disco
    '61': 'DI', // Disco/Club
    '10': 'TE', // Teatro
    '20': 'CI', // Cinema
    '30': 'CO', // Concerto
    '40': 'SP', // Sport
    '50': 'AL', // Altro
  };
  return genreMap[genreCode || '60'] || 'DI';
}

/**
 * Determina tipo SpettacoloIntrattenimento secondo specifiche SIAE
 * S=spettacolo, I=intrattenimento, P=spettacolo digitale, N=intrattenimento digitale
 */
function getSpettacoloIntrattenimentoCode(taxType: string | null, isDigital: boolean = false): string {
  if (taxType === 'S') return isDigital ? 'P' : 'S';
  return isDigital ? 'N' : 'I';
}

// Funzione generateSiaeFileName importata da ./siae-utils.ts

// Map internal ticket status to official SIAE status codes (Allegato A - Agenzia delle Entrate)
// VD = Valido digitale, ZD = Accesso automatizzato digitale, AD = Annullato digitale
// MD = Accesso manuale digitale, DD = Daspato digitale
function mapToSiaeStatus(internalStatus: string | null | undefined): string {
  if (!internalStatus) return 'VD';
  
  const statusLower = internalStatus.toLowerCase();
  switch (statusLower) {
    // Valid/Active states -> VD (Valido digitale)
    case 'active':
    case 'emesso':
    case 'emitted':
    case 'valid':
    case 'pending':
      return 'VD';
    
    // Used/Accessed states -> ZD (Accesso automatizzato digitale)
    case 'used':
    case 'utilizzato':
    case 'accessed':
    case 'checked_in':
    case 'scanned':
      return 'ZD';
    
    // Cancelled states -> AD (Annullato digitale)
    case 'cancelled':
    case 'annullato':
    case 'canceled':
    case 'refunded':
    case 'replaced':
      return 'AD';
    
    // Manual access -> MD (Accesso manuale digitale)
    case 'manual_access':
    case 'manual':
      return 'MD';
    
    // Expired/Blacklisted -> BD (Black list digitale)
    case 'expired':
    case 'blacklisted':
    case 'blocked':
      return 'BD';
    
    default:
      // Default to valid for unknown statuses
      return 'VD';
  }
}

// Generate XML for daily ticket report - uses RiepilogoMensile format (Provvedimento 04/03/2008)
router.get("/api/siae/companies/:companyId/reports/xml/daily", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { companyId } = req.params;
    const { date } = req.query;
    
    if (!date) {
      return res.status(400).json({ message: "Data obbligatoria (formato: YYYY-MM-DD)" });
    }
    
    const reportDate = new Date(date as string);
    
    // Get system config and company for fiscal code
    const systemConfig = await siaeStorage.getSiaeSystemConfig(companyId);
    const company = await storage.getCompany(companyId);
    
    // CONTROLLO OBBLIGATORIO: Codice Fiscale Emittente
    const taxId = systemConfig?.taxId || company?.fiscalCode || company?.taxId;
    if (!taxId) {
      return res.status(400).json({ 
        message: "Codice Fiscale Emittente non configurato. Vai su Impostazioni SIAE > Dati Aziendali per configurarlo prima di generare report.",
        code: "TAX_ID_REQUIRED"
      });
    }
    
    // Get all tickets for the date range
    const startOfDay = new Date(reportDate);
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date(reportDate);
    endOfDay.setHours(23, 59, 59, 999);
    
    // Get tickets issued on this date
    const allTickets = await siaeStorage.getSiaeTicketsByCompany(companyId);
    const dayTickets = allTickets.filter(t => {
      const ticketDate = new Date(t.emissionDate);
      return ticketDate >= startOfDay && ticketDate <= endOfDay;
    });
    
    // Generate OraGenerazione in HHMMSS format
    const now = new Date();
    const oraGen = String(now.getHours()).padStart(2, '0') + 
                   String(now.getMinutes()).padStart(2, '0') + 
                   String(now.getSeconds()).padStart(2, '0');
    
    // Calculate progressive sequence number for this transmission
    const existingTransmissions = await siaeStorage.getSiaeTransmissionsByCompany(companyId);
    const sameTypeTransmissions = existingTransmissions.filter(t => {
      const tDate = new Date(t.periodDate);
      return t.transmissionType === 'daily' &&
             tDate.getFullYear() === reportDate.getFullYear() &&
             tDate.getMonth() === reportDate.getMonth() &&
             tDate.getDate() === reportDate.getDate();
    });
    const sequenceNumber = sameTypeTransmissions.length + 1;
    
    // FIX 2026-01-14: Genera nome file PRIMA della generazione XML per attributo NomeFile obbligatorio
    // L'attributo NomeFile deve corrispondere esattamente al nome dell'allegato (errore SIAE 0600)
    // FIX 2026-01-18: TUTTI i report sono firmati S/MIME, usa resolveSystemCodeForSmime
    const { getCachedEfffData } = await import('./bridge-relay');
    const dailyEfffData = getCachedEfffData();
    const dailySmimeResult = resolveSystemCodeForSmime(dailyEfffData, systemConfig);
    if (!dailySmimeResult.success || !dailySmimeResult.systemCode) {
      return res.status(400).json({
        message: dailySmimeResult.error || 'Smart Card richiesta per preview report',
        code: 'SMARTCARD_REQUIRED_FOR_SMIME'
      });
    }
    const dailyResolvedSystemCode = dailySmimeResult.systemCode;
    const generatedFileName = generateSiaeFileName('giornaliero', reportDate, sequenceNumber, null, dailyResolvedSystemCode);
    
    // Generate RiepilogoGiornaliero XML using unified generateC1Xml
    const hydratedDailyData = await hydrateC1EventContextFromTickets(dayTickets, companyId, reportDate, false);
    
    const dailyC1Params: C1XmlParams = {
      reportKind: 'giornaliero',
      companyId,
      reportDate,
      resolvedSystemCode: dailyResolvedSystemCode,
      progressivo: sequenceNumber,
      taxId,
      businessName: company?.name || 'N/D',
      events: hydratedDailyData.events,
      subscriptions: hydratedDailyData.subscriptions,
    };
    
    const dailyC1Result = generateC1Xml(dailyC1Params);
    const xml = dailyC1Result.xml;
    const fileExtension = '.xsi';
    
    // Calculate transmission statistics for daily report
    const dailyStats = await calculateTransmissionStats(dayTickets, companyId);
    const dailyFileHash = calculateFileHash(xml);
    
    // Create transmission record
    // FIX 2026-01-15: Salva systemCode per garantire coerenza nei reinvii (errori SIAE 0600/0603)
    const transmission = await siaeStorage.createSiaeTransmission({
      companyId,
      transmissionType: 'daily',
      periodDate: reportDate,
      fileName: generatedFileName.replace(fileExtension, ''),
      fileExtension,
      fileContent: xml,
      status: 'pending',
      ticketsCount: dayTickets.length,
      totalAmount: dayTickets.reduce((sum, t) => sum + parseFloat(t.grossAmount || '0'), 0).toString(),
      progressivoInvio: sequenceNumber, // Progressivo invio per periodo fiscale
      systemCode: dailyResolvedSystemCode, // FIX: Salva codice per reinvii futuri
      fileHash: dailyFileHash,
      totalIva: dailyStats.totalIva.toFixed(2),
      totalEsenti: dailyStats.totalEsenti.toFixed(2),
      totalImpostaIntrattenimento: dailyStats.totalImpostaIntrattenimento.toFixed(2),
      cfOrganizzatore: systemConfig?.taxId || '',
      ticketsChanged: dailyStats.ticketsChanged,
      ticketsResold: dailyStats.ticketsResold,
    });
    
    // Format date for filename
    const dateStr = reportDate.getFullYear().toString() + 
                    String(reportDate.getMonth() + 1).padStart(2, '0') + 
                    String(reportDate.getDate()).padStart(2, '0');
    
    res.set('Content-Type', 'application/xml');
    res.set('Content-Disposition', `attachment; filename="SIAE_C1_${dateStr}_${transmission.id}.xml"`);
    res.send(xml);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Generate XML for event report (all tickets for a specific event)
// NOTE: This is an INTERNAL UTILITY endpoint for viewing/downloading event data.
// Uses custom internal format - NOT for official SIAE transmission.
// For official C1 transmissions, use /api/siae/companies/:companyId/transmissions/send-c1
router.get("/api/siae/ticketed-events/:eventId/reports/xml", requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const { eventId } = req.params;
    
    // Get ticketed event details
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(eventId);
    if (!ticketedEvent) {
      return res.status(404).json({ message: "Evento con biglietteria non trovato" });
    }
    
    // Get activation card
    const activationCards = await siaeStorage.getSiaeActivationCardsByCompany(ticketedEvent.companyId);
    const activeCard = activationCards.find(c => c.status === 'active');
    
    if (!activeCard) {
      return res.status(400).json({ message: "Nessuna carta di attivazione attiva trovata" });
    }
    
    // Get all sectors for this event
    const sectors = await siaeStorage.getSiaeEventSectors(eventId);
    
    // Get all tickets for all sectors
    const allTickets: any[] = [];
    for (const sector of sectors) {
      const sectorTickets = await siaeStorage.getSiaeTicketsBySector(sector.id);
      allTickets.push(...sectorTickets);
    }
    
    // Get system config and company for fiscal code
    const systemConfig = await siaeStorage.getSiaeSystemConfig(ticketedEvent.companyId);
    const company = await storage.getCompany(ticketedEvent.companyId);
    
    // CONTROLLO OBBLIGATORIO: Codice Fiscale Emittente
    const taxId = systemConfig?.taxId || company?.fiscalCode || company?.taxId;
    if (!taxId) {
      return res.status(400).json({ 
        message: "Codice Fiscale Emittente non configurato. Vai su Impostazioni SIAE > Dati Aziendali per configurarlo prima di generare report.",
        code: "TAX_ID_REQUIRED"
      });
    }
    
    // Build XML
    let xml = `<?xml version="1.0" encoding="UTF-8"?>
<ReportEvento xmlns="urn:siae:biglietteria:2025">
  <Intestazione>
    <CodiceFiscaleEmittente>${escapeXml(taxId)}</CodiceFiscaleEmittente>
    <NumeroCarta>${escapeXml(activeCard.cardCode)}</NumeroCarta>
    <DataOraGenerazione>${formatSiaeDateTime(new Date())}</DataOraGenerazione>
  </Intestazione>
  <DatiEvento>
    <CodiceEvento>${escapeXml(ticketedEvent.siaeEventCode || ticketedEvent.id)}</CodiceEvento>
    <Denominazione>${escapeXml(ticketedEvent.siaeEventCode || '')}</Denominazione>
    <CodiceGenere>${escapeXml(ticketedEvent.genreCode)}</CodiceGenere>
    <DataEvento>${formatSiaeDate(ticketedEvent.saleStartDate)}</DataEvento>
    <OraInizio></OraInizio>
    <Luogo>${escapeXml(ticketedEvent.siaeLocationCode || '')}</Luogo>
    <Indirizzo></Indirizzo>
    <Comune></Comune>
    <Provincia></Provincia>
  </DatiEvento>
  <ElencoSettori>`;
    
    for (const sector of sectors) {
      const sectorTickets = allTickets.filter(t => t.sectorId === sector.id);
      const soldTickets = sectorTickets.filter(t => !isCancelledStatus(t.status));
      
      xml += `
    <Settore>
      <CodiceSettore>${escapeXml(sector.sectorCode)}</CodiceSettore>
      <Denominazione>${escapeXml(sector.name)}</Denominazione>
      <CapienzaTotale>${sector.capacity}</CapienzaTotale>
      <PostiNumerati>${sector.isNumbered ? 'SI' : 'NO'}</PostiNumerati>
      <BigliettiEmessi>${sectorTickets.length}</BigliettiEmessi>
      <BigliettiValidi>${soldTickets.length}</BigliettiValidi>
      <ImportoTotale>${soldTickets.reduce((sum, t) => sum + parseFloat(t.grossAmount || '0'), 0).toFixed(2)}</ImportoTotale>
    </Settore>`;
    }
    
    xml += `
  </ElencoSettori>
  <Riepilogo>
    <TotaleBigliettiEmessi>${allTickets.length}</TotaleBigliettiEmessi>
    <TotaleBigliettiValidi>${allTickets.filter(t => !isCancelledStatus(t.status)).length}</TotaleBigliettiValidi>
    <TotaleBigliettiAnnullati>${allTickets.filter(t => isCancelledStatus(t.status)).length}</TotaleBigliettiAnnullati>
    <TotaleIncassoLordo>${allTickets.reduce((sum, t) => sum + parseFloat(t.grossAmount || '0'), 0).toFixed(2)}</TotaleIncassoLordo>
    <TotaleDiritti>0.00</TotaleDiritti>
    <TotaleIVA>${allTickets.reduce((sum, t) => sum + parseFloat(t.vatAmount || '0'), 0).toFixed(2)}</TotaleIVA>
  </Riepilogo>
</ReportEvento>`;
    
    res.set('Content-Type', 'application/xml');
    res.set('Content-Disposition', `attachment; filename="SIAE_Event_${eventId}.xml"`);
    res.send(xml);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Generate XML for cancellations report
// NOTE: This is an INTERNAL UTILITY endpoint for viewing/downloading cancellation data.
// Uses custom internal format - NOT for official SIAE transmission.
// For official C1 transmissions, use /api/siae/companies/:companyId/transmissions/send-c1
router.get("/api/siae/companies/:companyId/reports/xml/cancellations", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { companyId } = req.params;
    const { dateFrom, dateTo } = req.query;
    
    if (!dateFrom || !dateTo) {
      return res.status(400).json({ message: "Date di inizio e fine obbligatorie (formato: YYYY-MM-DD)" });
    }
    
    const startDate = new Date(dateFrom as string);
    const endDate = new Date(dateTo as string);
    endDate.setHours(23, 59, 59, 999);
    
    // Get activation card
    const activationCards = await siaeStorage.getSiaeActivationCardsByCompany(companyId);
    const activeCard = activationCards.find(c => c.status === 'active');
    
    if (!activeCard) {
      return res.status(400).json({ message: "Nessuna carta di attivazione attiva trovata" });
    }
    
    // Get cancelled tickets in date range
    const allTickets = await siaeStorage.getSiaeTicketsByCompany(companyId);
    const cancelledTickets = allTickets.filter(t => {
      if (t.status !== 'cancelled' || !t.cancellationDate) return false;
      const cancelDate = new Date(t.cancellationDate);
      return cancelDate >= startDate && cancelDate <= endDate;
    });
    
    // Get cancellation reasons
    const reasons = await siaeStorage.getSiaeCancellationReasons();
    
    // Get system config and company for fiscal code
    const systemConfig = await siaeStorage.getSiaeSystemConfig(companyId);
    const company = await storage.getCompany(companyId);
    
    // CONTROLLO OBBLIGATORIO: Codice Fiscale Emittente
    const taxId = systemConfig?.taxId || company?.fiscalCode || company?.taxId;
    if (!taxId) {
      return res.status(400).json({ 
        message: "Codice Fiscale Emittente non configurato. Vai su Impostazioni SIAE > Dati Aziendali per configurarlo prima di generare report.",
        code: "TAX_ID_REQUIRED"
      });
    }
    
    let xml = `<?xml version="1.0" encoding="UTF-8"?>
<ReportAnnullamenti xmlns="urn:siae:biglietteria:2025">
  <Intestazione>
    <CodiceFiscaleEmittente>${escapeXml(taxId)}</CodiceFiscaleEmittente>
    <NumeroCarta>${escapeXml(activeCard.cardCode)}</NumeroCarta>
    <PeriodoDa>${formatSiaeDate(startDate)}</PeriodoDa>
    <PeriodoA>${formatSiaeDate(endDate)}</PeriodoA>
    <DataOraGenerazione>${formatSiaeDateTime(new Date())}</DataOraGenerazione>
  </Intestazione>
  <ElencoAnnullamenti>`;
    
    for (const ticket of cancelledTickets) {
      const reason = reasons.find(r => r.code === ticket.cancellationReasonCode);
      
      xml += `
    <Annullamento>
      <NumeroProgressivo>${ticket.progressiveNumber || 0}</NumeroProgressivo>
      <SigilloFiscale>${escapeXml(ticket.fiscalSealCode)}</SigilloFiscale>
      <DataOraEmissione>${formatSiaeDateTime(ticket.emissionDate)}</DataOraEmissione>
      <DataOraAnnullamento>${formatSiaeDateTime(ticket.cancellationDate)}</DataOraAnnullamento>
      <CodiceCausale>${escapeXml(ticket.cancellationReasonCode || '')}</CodiceCausale>
      <DescrizioneCausale>${escapeXml(reason?.name || '')}</DescrizioneCausale>
      <ImportoRimborsato>${(ticket.refundAmount ? Number(ticket.refundAmount) / 100 : 0).toFixed(2)}</ImportoRimborsato>
    </Annullamento>`;
    }
    
    xml += `
  </ElencoAnnullamenti>
  <Riepilogo>
    <TotaleAnnullamenti>${cancelledTickets.length}</TotaleAnnullamenti>
    <TotaleRimborsi>${cancelledTickets.reduce((sum, t) => sum + (t.refundAmount ? Number(t.refundAmount) / 100 : 0), 0).toFixed(2)}</TotaleRimborsi>
  </Riepilogo>
</ReportAnnullamenti>`;
    
    res.set('Content-Type', 'application/xml');
    res.set('Content-Disposition', `attachment; filename="SIAE_Cancellations_${dateFrom}_${dateTo}.xml"`);
    res.send(xml);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== Smart Card Sessions API ====================

// Validation schemas for smart card operations
const smartCardSessionCreateSchema = z.object({
  readerId: z.string().min(1, "readerId è obbligatorio"),
  readerName: z.string().min(1, "readerName è obbligatorio"),
  readerModel: z.string().optional().default('MiniLector EVO V3'),
  readerVendor: z.string().optional().default('Bit4id'),
  cardAtr: z.string().nullable().optional(),
  cardType: z.string().nullable().optional(),
  cardSerialNumber: z.string().nullable().optional(),
  workstationId: z.string().nullable().optional()
});

const smartCardSessionUpdateSchema = z.object({
  cardAtr: z.string().nullable().optional(),
  cardType: z.string().nullable().optional(),
  cardSerialNumber: z.string().nullable().optional(),
  status: z.enum(['connected', 'disconnected', 'error', 'card_removed']).optional(),
  lastError: z.string().nullable().optional()
}).refine(obj => Object.keys(obj).length > 0, { message: "Payload vuoto non permesso" });

const smartCardSealLogSchema = z.object({
  sessionId: z.string().min(1, "sessionId è obbligatorio"),
  fiscalSealId: z.string().nullable().optional(),
  ticketId: z.string().nullable().optional(),
  sealCode: z.string().min(1, "sealCode è obbligatorio"),
  progressiveNumber: z.number().int().min(0).default(0),
  status: z.enum(['success', 'failed', 'cancelled']).default('success'),
  errorMessage: z.string().nullable().optional(),
  durationMs: z.number().int().nullable().optional()
});

// Get current smart card session status
router.get('/smart-card/status', requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = (req.user as any)?.id;
    if (!userId) {
      return res.status(401).json({ message: "Non autorizzato" });
    }
    
    // Get the most recent active session for this user
    const session = await siaeStorage.getActiveSmartCardSession(userId);
    
    if (!session) {
      return res.json({
        connected: false,
        readerDetected: false,
        cardInserted: false,
        readerName: null,
        canEmitTickets: false,
        message: "Nessuna sessione smart card attiva"
      });
    }
    
    // Verify session is still valid and connected
    const isConnected = session.status === 'connected';
    const hasCard = session.cardAtr !== null && session.cardAtr !== '';
    const canEmit = isConnected && hasCard;
    
    res.json({
      connected: isConnected,
      readerDetected: isConnected || session.status === 'card_removed',
      cardInserted: hasCard,
      readerName: session.readerName,
      cardType: session.cardType,
      cardAtr: session.cardAtr,
      ticketsEmitted: session.ticketsEmittedCount,
      sealsUsed: session.sealsUsedCount,
      connectedAt: session.connectedAt,
      lastActivity: session.lastActivityAt,
      canEmitTickets: canEmit,
      sessionId: session.id,
      status: session.status,
      errorCount: session.errorCount,
      lastError: session.lastError
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Register a new smart card session
router.post('/smart-card/sessions', requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = (req.user as any)?.id;
    if (!userId) {
      return res.status(401).json({ message: "Non autorizzato" });
    }
    
    // Validate request body
    const parseResult = smartCardSessionCreateSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json({ 
        message: "Dati non validi", 
        errors: parseResult.error.errors 
      });
    }
    
    const { readerId, readerName, readerModel, readerVendor, cardAtr, cardType, cardSerialNumber, workstationId } = parseResult.data;
    
    // Close any existing active sessions for this user
    await siaeStorage.closeActiveSmartCardSessions(userId);
    
    // Determine initial status
    const hasCard = cardAtr !== null && cardAtr !== undefined && cardAtr !== '';
    const initialStatus = hasCard ? 'connected' : 'card_removed';
    
    // Create new session
    const session = await siaeStorage.createSmartCardSession({
      readerId,
      readerName,
      readerModel: readerModel || 'MiniLector EVO V3',
      readerVendor: readerVendor || 'Bit4id',
      cardAtr: cardAtr || null,
      cardType: cardType || null,
      cardSerialNumber: cardSerialNumber || null,
      status: initialStatus,
      ticketsEmittedCount: 0,
      sealsUsedCount: 0,
      userId,
      workstationId: workstationId || null,
      ipAddress: (req.ip || '').substring(0, 45), // Normalize IP length
      userAgent: (req.get('user-agent') || '').substring(0, 500), // Limit user agent
      lastActivityAt: new Date(),
      errorCount: 0
    });
    
    // Log audit - reader connection
    await siaeStorage.createAuditLog({
      companyId: (req.user as any)?.companyId || '',
      userId,
      action: 'smart_card_connect',
      entityType: 'smart_card_session',
      entityId: session.id,
      description: `Connesso lettore smart card: ${readerName}`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    // Log audit - card insertion if present
    if (hasCard) {
      await siaeStorage.createAuditLog({
        companyId: (req.user as any)?.companyId || '',
        userId,
        action: 'smart_card_inserted',
        entityType: 'smart_card_session',
        entityId: session.id,
        description: `Smart Card inserita: ${cardType || 'Tipo sconosciuto'}`,
        ipAddress: (req.ip || '').substring(0, 45),
        userAgent: (req.get('user-agent') || '').substring(0, 500)
      });
    }
    
    res.status(201).json(session);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Update smart card session (card inserted/removed)
router.patch('/smart-card/sessions/:id', requireAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const userId = (req.user as any)?.id;
    
    if (!userId) {
      return res.status(401).json({ message: "Non autorizzato" });
    }
    
    // Validate request body
    const parseResult = smartCardSessionUpdateSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json({ 
        message: "Dati non validi", 
        errors: parseResult.error.errors 
      });
    }
    
    // Check session ownership
    const existingSession = await siaeStorage.getSmartCardSessionById(id);
    if (!existingSession) {
      return res.status(404).json({ message: "Sessione non trovata" });
    }
    
    if (existingSession.userId !== userId) {
      return res.status(403).json({ message: "Non autorizzato a modificare questa sessione" });
    }
    
    const updateData = parseResult.data;
    const previousCardAtr = existingSession.cardAtr;
    const newCardAtr = updateData.cardAtr;
    
    // Determine status based on card presence
    let newStatus = updateData.status;
    if (!newStatus) {
      if (newCardAtr !== undefined) {
        newStatus = (newCardAtr && newCardAtr !== '') ? 'connected' : 'card_removed';
      }
    }
    
    // Track errors
    let errorCount = existingSession.errorCount || 0;
    if (newStatus === 'error' || updateData.lastError) {
      errorCount++;
    }
    
    const session = await siaeStorage.updateSmartCardSession(id, {
      ...updateData,
      status: newStatus,
      errorCount,
      lastActivityAt: new Date()
    });
    
    // Log card insertion/removal
    const wasCardPresent = previousCardAtr !== null && previousCardAtr !== '';
    const isCardPresent = newCardAtr !== undefined ? (newCardAtr && newCardAtr !== '') : wasCardPresent;
    
    if (!wasCardPresent && isCardPresent) {
      await siaeStorage.createAuditLog({
        companyId: (req.user as any)?.companyId || '',
        userId,
        action: 'smart_card_inserted',
        entityType: 'smart_card_session',
        entityId: id,
        description: `Smart Card inserita: ${updateData.cardType || 'Tipo sconosciuto'}`,
        ipAddress: (req.ip || '').substring(0, 45),
        userAgent: (req.get('user-agent') || '').substring(0, 500)
      });
    } else if (wasCardPresent && !isCardPresent) {
      await siaeStorage.createAuditLog({
        companyId: (req.user as any)?.companyId || '',
        userId,
        action: 'smart_card_removed',
        entityType: 'smart_card_session',
        entityId: id,
        description: 'Smart Card rimossa',
        ipAddress: (req.ip || '').substring(0, 45),
        userAgent: (req.get('user-agent') || '').substring(0, 500)
      });
    }
    
    // Log errors
    if (updateData.lastError) {
      await siaeStorage.createAuditLog({
        companyId: (req.user as any)?.companyId || '',
        userId,
        action: 'smart_card_error',
        entityType: 'smart_card_session',
        entityId: id,
        description: `Errore smart card: ${updateData.lastError}`,
        ipAddress: (req.ip || '').substring(0, 45),
        userAgent: (req.get('user-agent') || '').substring(0, 500)
      });
    }
    
    res.json(session);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Close smart card session
router.delete('/smart-card/sessions/:id', requireAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const userId = (req.user as any)?.id;
    
    if (!userId) {
      return res.status(401).json({ message: "Non autorizzato" });
    }
    
    // Check session ownership
    const existingSession = await siaeStorage.getSmartCardSessionById(id);
    if (!existingSession) {
      return res.status(404).json({ message: "Sessione non trovata" });
    }
    
    if (existingSession.userId !== userId) {
      return res.status(403).json({ message: "Non autorizzato a chiudere questa sessione" });
    }
    
    await siaeStorage.closeSmartCardSession(id);
    
    // Log audit
    await siaeStorage.createAuditLog({
      companyId: (req.user as any)?.companyId || '',
      userId,
      action: 'smart_card_disconnect',
      entityType: 'smart_card_session',
      entityId: id,
      description: 'Disconnesso lettore smart card',
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    res.json({ success: true });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Verify smart card is ready for ticket emission - CRITICAL FOR SIAE COMPLIANCE
router.get('/smart-card/verify-emission', requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = (req.user as any)?.id;
    if (!userId) {
      return res.status(401).json({ message: "Non autorizzato" });
    }
    
    const session = await siaeStorage.getActiveSmartCardSession(userId);
    
    if (!session) {
      return res.status(403).json({
        canEmit: false,
        reason: "ERRORE FISCALE: Nessuna sessione smart card attiva. Collegare il lettore MiniLector EVO.",
        code: "NO_SESSION"
      });
    }
    
    if (session.status === 'disconnected') {
      return res.status(403).json({
        canEmit: false,
        reason: "ERRORE FISCALE: Lettore smart card disconnesso. Ricollegare il dispositivo.",
        code: "READER_DISCONNECTED"
      });
    }
    
    if (session.status === 'error') {
      return res.status(403).json({
        canEmit: false,
        reason: `ERRORE FISCALE: Errore lettore smart card. ${session.lastError || 'Verificare la connessione.'}`,
        code: "READER_ERROR"
      });
    }
    
    if (!session.cardAtr || session.cardAtr === '') {
      return res.status(403).json({
        canEmit: false,
        reason: "ERRORE FISCALE: Smart Card SIAE non inserita. Inserire la carta sigilli per emettere biglietti.",
        code: "NO_CARD"
      });
    }
    
    if (session.status !== 'connected') {
      return res.status(403).json({
        canEmit: false,
        reason: "ERRORE FISCALE: Stato lettore non valido. Verificare la connessione.",
        code: "INVALID_STATE"
      });
    }
    
    res.json({
      canEmit: true,
      sessionId: session.id,
      readerName: session.readerName,
      cardType: session.cardType,
      cardAtr: session.cardAtr,
      ticketsEmitted: session.ticketsEmittedCount,
      sealsUsed: session.sealsUsedCount
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== SIAE Reports ====================

// Helper function per costruire i dati del report C1 (Quadri A/B/C)
// Usata sia dall'endpoint GET che dall'endpoint POST per garantire consistenza
interface C1ReportOptions {
  reportType: 'giornaliero' | 'mensile';
  reportDate?: Date; // Data di riferimento (default: oggi)
}

function buildC1ReportData(
  event: any, 
  company: any, 
  siaeConfig: any,
  location: any,
  sectors: any[], 
  allTickets: any[],
  options: C1ReportOptions
) {
  const { reportType, reportDate } = options;
  const isMonthly = reportType === 'mensile';
  const refDate = reportDate || new Date();
  const today = refDate.toISOString().split('T')[0];
  
  // Helper function to get ticket price with fallback - SEMPRE usare il prezzo effettivo del ticket
  const getTicketPrice = (t: any) => Number(t.ticketPrice) || Number(t.grossAmount) || Number(t.priceAtPurchase) || 0;
  
  // Helper function to derive ticketType with fallback from ticketTypeCode
  const getTicketType = (t: any): 'intero' | 'ridotto' | 'omaggio' => {
    if (t.ticketType === 'intero' || t.ticketType === 'ridotto' || t.ticketType === 'omaggio') {
      return t.ticketType;
    }
    if (t.ticketTypeCode === 'INT') return 'intero';
    if (t.ticketTypeCode === 'RID') return 'ridotto';
    if (t.ticketTypeCode === 'OMG' || t.ticketTypeCode === 'OMA') return 'omaggio';
    return 'intero';
  };
  
  // Helper: determina se un biglietto è annullato (status O cancellationReasonCode/cancellationDate)
  const isTicketCancelled = (t: any): boolean => {
    if (isCancelledStatus(t.status)) return true;
    if (t.cancellationReasonCode || t.cancellationDate) return true;
    return false;
  };

  // For daily report: filter tickets by today's emission date
  // For monthly report: filter tickets by month of reportDate
  let tickets = allTickets;
  let cancelledTickets = allTickets.filter(t => isTicketCancelled(t));
  
  if (!isMonthly) {
    // Daily report: only tickets emitted today
    tickets = allTickets.filter(t => {
      if (!t.emissionDate) return false;
      const ticketDate = new Date(t.emissionDate).toISOString().split('T')[0];
      return ticketDate === today;
    });
    // Also filter cancelled tickets for today
    cancelledTickets = allTickets.filter(t => {
      if (!isTicketCancelled(t)) return false;
      if (t.cancellationDate) {
        const cancelDate = new Date(t.cancellationDate).toISOString().split('T')[0];
        return cancelDate === today;
      }
      return false;
    });
  } else {
    // Monthly report: filter tickets by month/year of reportDate
    const refMonth = refDate.getMonth();
    const refYear = refDate.getFullYear();
    tickets = allTickets.filter(t => {
      if (!t.emissionDate) return false;
      const ticketDate = new Date(t.emissionDate);
      return ticketDate.getMonth() === refMonth && ticketDate.getFullYear() === refYear;
    });
    cancelledTickets = allTickets.filter(t => {
      if (!isTicketCancelled(t)) return false;
      if (t.cancellationDate) {
        const cancelDate = new Date(t.cancellationDate);
        return cancelDate.getMonth() === refMonth && cancelDate.getFullYear() === refYear;
      }
      return false;
    });
  }
  
  // Filter only active/emitted tickets for sales calculations
  const activeTickets = tickets.filter(t => !isTicketCancelled(t));

  const salesByDate: Record<string, { 
    date: string; 
    ticketsSold: number; 
    totalAmount: number;
    byTicketType: Record<string, { name: string; quantity: number; amount: number }>;
    bySector: Record<string, { name: string; quantity: number; amount: number }>;
  }> = {};

  // Process ALL tickets (including those without transactions - cashier tickets)
  for (const ticket of activeTickets) {
    const dateStr = ticket.emissionDate 
      ? new Date(ticket.emissionDate).toISOString().split('T')[0] 
      : 'N/D';
    
    if (!salesByDate[dateStr]) {
      salesByDate[dateStr] = {
        date: dateStr,
        ticketsSold: 0,
        totalAmount: 0,
        byTicketType: {},
        bySector: {},
      };
    }
    
    const price = getTicketPrice(ticket);
    salesByDate[dateStr].ticketsSold += 1;
    salesByDate[dateStr].totalAmount += price;

    const ticketType = getTicketType(ticket);
    if (!salesByDate[dateStr].byTicketType[ticketType]) {
      salesByDate[dateStr].byTicketType[ticketType] = { 
        name: ticketType === 'intero' ? 'Intero' : ticketType === 'ridotto' ? 'Ridotto' : 'Omaggio', 
        quantity: 0, 
        amount: 0 
      };
    }
    salesByDate[dateStr].byTicketType[ticketType].quantity += 1;
    salesByDate[dateStr].byTicketType[ticketType].amount += price;

    const sector = sectors.find(s => s.id === ticket.sectorId);
    const sectorName = sector?.name || 'Sconosciuto';
    if (!salesByDate[dateStr].bySector[sectorName]) {
      salesByDate[dateStr].bySector[sectorName] = { name: sectorName, quantity: 0, amount: 0 };
    }
    salesByDate[dateStr].bySector[sectorName].quantity += 1;
    salesByDate[dateStr].bySector[sectorName].amount += price;
  }

  const dailySales = Object.values(salesByDate).sort((a, b) => a.date.localeCompare(b.date));
  
  // Calculate totals - TUTTI i totali monetari usano i prezzi effettivi dei ticket
  const totalTicketsSold = activeTickets.length;
  const totalRevenue = activeTickets.reduce((sum, t) => sum + getTicketPrice(t), 0);
  
  // Calculate VAT - legge event.vatRate o default 10%
  const vatRate = Number(event.vatRate) || 10;
  const vatAmount = totalRevenue * (vatRate / (100 + vatRate));
  const netRevenue = totalRevenue - vatAmount;

  // Calcola totali per tipologia biglietto
  const ticketsByType = {
    intero: activeTickets.filter(t => getTicketType(t) === 'intero'),
    ridotto: activeTickets.filter(t => getTicketType(t) === 'ridotto'),
    omaggio: activeTickets.filter(t => getTicketType(t) === 'omaggio')
  };

  // Calcola imposta intrattenimenti - legge event.entertainmentTaxRate o default 16.5%
  const isIntrattenimento = event.eventType === 'intrattenimento';
  const impostaIntrattenimentiRate = isIntrattenimento 
    ? (Number(event.entertainmentTaxRate) || 16.5) 
    : 0;
  const impostaIntrattenimenti = isIntrattenimento ? (netRevenue * impostaIntrattenimentiRate / 100) : 0;

  // Capienza totale
  const capienzaTotale = sectors.reduce((sum, s) => sum + (s.capacity || 0), 0);

  // QUADRO A - Dati Identificativi (conforme Allegato 3 G.U. n.188 12/08/2004)
  // Include: Organizzatore, Titolare Sistema Emissione, Dati Locale, Dati Evento
  const quadroA = {
    // === DATI ORGANIZZATORE ===
    // Mappa campi dalla tabella companies: taxId = P.IVA, fiscalCode = C.F.
    denominazioneOrganizzatore: company?.name || 'N/D',
    codiceFiscaleOrganizzatore: company?.fiscalCode || 'N/D',
    partitaIvaOrganizzatore: company?.taxId || 'N/D',
    indirizzoOrganizzatore: company?.address || 'N/D',
    comuneOrganizzatore: company?.city || 'N/D',
    provinciaOrganizzatore: company?.province || 'N/D',
    capOrganizzatore: company?.postalCode || 'N/D',
    
    // === TITOLARE SISTEMA DI EMISSIONE (Allegato 3 - campo obbligatorio) ===
    // Può essere diverso dall'organizzatore (es. società che gestisce biglietteria)
    // Usa dati da siaeSystemConfig se disponibile, altrimenti fallback su company
    titolareSistemaEmissione: siaeConfig?.businessName || company?.name || 'N/D',
    codiceFiscaleTitolareSistema: siaeConfig?.taxId || company?.fiscalCode || 'N/D',
    partitaIvaTitolareSistema: siaeConfig?.vatNumber || company?.taxId || 'N/D',
    indirizzoTitolareSistema: siaeConfig?.businessAddress || company?.address || 'N/D',
    comuneTitolareSistema: siaeConfig?.businessCity || company?.city || 'N/D',
    provinciaTitolareSistema: siaeConfig?.businessProvince || company?.province || 'N/D',
    capTitolareSistema: siaeConfig?.businessPostalCode || company?.postalCode || 'N/D',
    codiceSistemaEmissione: siaeConfig?.systemCode || event.emissionSystemCode || 'N/D',
    
    // === MANCATO FUNZIONAMENTO SISTEMA (Allegato 3 - sezione opzionale) ===
    // Da compilare solo in caso di malfunzionamento del sistema automatizzato
    sistemaFunzionante: true, // default: sistema funziona
    dataInizioMalfunzionamento: null as string | null,
    oraInizioMalfunzionamento: null as string | null,
    dataFineMalfunzionamento: null as string | null,
    oraFineMalfunzionamento: null as string | null,
    
    // === DATI LOCALE/VENUE ===
    // Usa dati da locations table se disponibile, altrimenti fallback su event
    codiceLocale: location?.siaeLocationCode || event.siaeLocationCode || 'N/D',
    denominazioneLocale: location?.name || event.venueName || 'N/D',
    indirizzoLocale: location?.address || event.venueAddress || 'N/D',
    comuneLocale: location?.city || event.venueCity || 'N/D',
    provinciaLocale: location?.province || event.venueProvince || 'N/D', 
    capLocale: location?.postalCode || location?.cap || event.venueCap || 'N/D',
    capienza: capienzaTotale,
    
    // === DATI EVENTO ===
    denominazioneEvento: event.eventName || event.name || 'N/D',
    codiceEvento: event.eventCode || event.code || 'N/D',
    genereEvento: event.genreCode || event.genre || 'N/D',
    dataEvento: event.eventDate,
    oraEvento: event.eventTime || 'N/D',
    oraFineEvento: event.eventEndTime || '06:00', // Ora fine evento (default 06:00 per discoteche)
    tipologiaEvento: event.eventType || 'spettacolo', // spettacolo o intrattenimento
    
    // === PERIODO DI RIFERIMENTO (per riepilogo giornaliero/mensile) ===
    periodoRiferimento: reportType,
    dataRiferimento: today,
  };

  // Progressivo emissione globale per questo report
  let progressivoGlobale = 0;

  // QUADRO B - Dettaglio Titoli di Accesso per Ordine/Settore
  const settori = sectors.map((s, index) => {
    const sectorActiveTickets = activeTickets.filter(t => t.sectorId === s.id);
    const sectorCancelledTickets = cancelledTickets.filter(t => t.sectorId === s.id);
    const sectorIntero = sectorActiveTickets.filter(t => getTicketType(t) === 'intero');
    const sectorRidotto = sectorActiveTickets.filter(t => getTicketType(t) === 'ridotto');
    const sectorOmaggio = sectorActiveTickets.filter(t => getTicketType(t) === 'omaggio');
    
    // Calcola totali usando SEMPRE i prezzi effettivi dei ticket
    const totaleInteri = sectorIntero.reduce((sum, t) => sum + getTicketPrice(t), 0);
    const totaleRidotti = sectorRidotto.reduce((sum, t) => sum + getTicketPrice(t), 0);
    const totaleSettore = sectorActiveTickets.reduce((sum, t) => sum + getTicketPrice(t), 0);
    
    // Calcola prezzoUnitario come media dei prezzi effettivi (non dal settore)
    const prezzoUnitarioInteri = sectorIntero.length > 0 
      ? totaleInteri / sectorIntero.length 
      : 0;
    const prezzoUnitarioRidotti = sectorRidotto.length > 0 
      ? totaleRidotti / sectorRidotto.length 
      : 0;
    
    // Incrementa progressivo per questo settore
    const progressivoSettore = progressivoGlobale + 1;
    progressivoGlobale += sectorActiveTickets.length;
    
    return {
      ordinePosto: index + 1, // 1°, 2°, 3° ordine progressivo
      codiceSettore: s.sectorCode || `SET${index + 1}`,
      denominazione: s.name,
      capienza: s.capacity || 0,
      
      // Dettaglio per tipologia - prezzi effettivi dai ticket
      interi: {
        quantita: sectorIntero.length,
        prezzoUnitario: Math.round(prezzoUnitarioInteri * 100) / 100,
        totale: totaleInteri
      },
      ridotti: {
        quantita: sectorRidotto.length,
        prezzoUnitario: Math.round(prezzoUnitarioRidotti * 100) / 100,
        totale: totaleRidotti
      },
      omaggi: {
        quantita: sectorOmaggio.length,
        prezzoUnitario: 0,
        totale: 0 // Omaggi non generano incasso
      },
      
      // Totali settore - calcolati dai ticket effettivi
      totaleVenduti: sectorActiveTickets.length,
      totaleAnnullati: sectorCancelledTickets.length,
      totaleIncasso: totaleSettore
    };
  });

  // Calcola riepilogo tipologie con prezzi effettivi
  const totaleInteriGlobale = ticketsByType.intero.reduce((s, t) => s + getTicketPrice(t), 0);
  const totaleRidottiGlobale = ticketsByType.ridotto.reduce((s, t) => s + getTicketPrice(t), 0);
  
  // QUADRO B - Struttura conforme Allegato 3 G.U. n.188 12/08/2004
  // Colonne: (1) Ordine del posto, (2) Settore, (3) Capienza, (4) Tipo titolo (TAB.3), 
  // (5) Prezzo unitario, N° titoli emessi, (6) Ricavo lordo, Imposta intratt., 
  // Imponibile IVA, N° titoli annullati, IVA lorda
  
  // Costruisci righe dettagliate per ogni combinazione settore/tipo titolo
  // secondo il formato ufficiale SIAE (ogni riga = 1 tipo titolo per settore)
  const righeDettaglio: Array<{
    ordinePosto: number;
    settore: string;
    capienza: number;
    tipoTitolo: string;           // Codice TAB.3: I1, RX, O1, etc.
    tipoTitoloDescrizione: string; // Descrizione: "Intero", "Ridotto generico", etc.
    prezzoUnitario: number;
    numeroTitoliEmessi: number;
    ricavoLordo: number;
    impostaIntrattenimenti: number;
    imponibileIva: number;
    numeroTitoliAnnullati: number;
    ivaLorda: number;
  }> = [];
  
  // Genera righe per ogni settore e tipo titolo
  let rigaOrdine = 1;
  for (const s of sectors) {
    const sectorActiveTickets = activeTickets.filter(t => t.sectorId === s.id);
    const sectorCancelledTickets = cancelledTickets.filter(t => t.sectorId === s.id);
    
    // Raggruppa ticket per tipo (usando codici TAB.3 ufficiali)
    const tipiTitolo = ['intero', 'ridotto', 'omaggio'] as const;
    const codiciTab3: Record<string, { codice: string; descrizione: string }> = {
      'intero': { codice: 'I1', descrizione: 'Intero' },
      'ridotto': { codice: 'RX', descrizione: 'Ridotto generico' },
      'omaggio': { codice: 'OX', descrizione: 'Omaggio generico' },
    };
    
    for (const tipo of tipiTitolo) {
      const ticketsTipo = sectorActiveTickets.filter(t => getTicketType(t) === tipo);
      const ticketsCancelledTipo = sectorCancelledTickets.filter(t => getTicketType(t) === tipo);
      
      if (ticketsTipo.length > 0 || ticketsCancelledTipo.length > 0) {
        const ricavoLordo = ticketsTipo.reduce((sum, t) => sum + getTicketPrice(t), 0);
        const prezzoUnitario = ticketsTipo.length > 0 
          ? ricavoLordo / ticketsTipo.length 
          : 0;
        
        // Calcola IVA su ricavo lordo
        const ivaLorda = ricavoLordo * (vatRate / (100 + vatRate));
        const imponibileIva = ricavoLordo - ivaLorda;
        
        // Imposta intrattenimenti (solo se evento è intrattenimento)
        const impostaIntratt = isIntrattenimento 
          ? imponibileIva * (impostaIntrattenimentiRate / 100) 
          : 0;
        
        righeDettaglio.push({
          ordinePosto: rigaOrdine,
          settore: s.name,
          capienza: s.capacity || 0,
          tipoTitolo: codiciTab3[tipo].codice,
          tipoTitoloDescrizione: codiciTab3[tipo].descrizione,
          prezzoUnitario: Math.round(prezzoUnitario * 100) / 100,
          numeroTitoliEmessi: ticketsTipo.length,
          ricavoLordo: Math.round(ricavoLordo * 100) / 100,
          impostaIntrattenimenti: Math.round(impostaIntratt * 100) / 100,
          imponibileIva: Math.round(imponibileIva * 100) / 100,
          numeroTitoliAnnullati: ticketsCancelledTipo.length,
          ivaLorda: Math.round(ivaLorda * 100) / 100,
        });
        
        rigaOrdine++;
      }
    }
  }
  
  const quadroB = {
    // Righe dettaglio conformi al modello ufficiale
    righeDettaglio,
    
    // Settori aggregati (legacy - per compatibilità)
    settori,
    
    // Riepilogo per tipologia biglietto (TAB.3 codici)
    riepilogoTipologie: {
      interi: {
        codice: 'I1',
        descrizione: 'Intero',
        quantita: ticketsByType.intero.length,
        prezzoUnitario: ticketsByType.intero.length > 0 
          ? Math.round((totaleInteriGlobale / ticketsByType.intero.length) * 100) / 100 
          : 0,
        totale: Math.round(totaleInteriGlobale * 100) / 100
      },
      ridotti: {
        codice: 'RX',
        descrizione: 'Ridotto generico',
        quantita: ticketsByType.ridotto.length,
        prezzoUnitario: ticketsByType.ridotto.length > 0 
          ? Math.round((totaleRidottiGlobale / ticketsByType.ridotto.length) * 100) / 100 
          : 0,
        totale: Math.round(totaleRidottiGlobale * 100) / 100
      },
      omaggi: {
        codice: 'OX',
        descrizione: 'Omaggio generico',
        quantita: ticketsByType.omaggio.length,
        prezzoUnitario: 0,
        totale: 0
      }
    },
    
    // Progressivo emissione totale per questo report
    progressivoEmissione: progressivoGlobale,
    
    // Totali generali QUADRO B (conformi al modello ufficiale)
    totaleBigliettiEmessi: totalTicketsSold,
    totaleBigliettiVenduti: totalTicketsSold, // alias
    totaleBigliettiAnnullati: cancelledTickets.length,
    totaleRicavoLordo: Math.round(totalRevenue * 100) / 100,
    totaleIncassoLordo: Math.round(totalRevenue * 100) / 100, // alias
    totaleImpostaIntrattenimenti: Math.round(impostaIntrattenimenti * 100) / 100,
    totaleImponibileIva: Math.round(netRevenue * 100) / 100,
    totaleIvaLorda: Math.round(vatAmount * 100) / 100,
  };

  // QUADRO C - Riepilogo Imposte e Contributi
  const quadroC = {
    // Base imponibile
    incassoLordo: totalRevenue,
    
    // IVA
    aliquotaIVA: vatRate,
    baseImponibileIVA: Math.round(netRevenue * 100) / 100,
    importoIVA: Math.round(vatAmount * 100) / 100,
    
    // Imposta Intrattenimenti (solo per attività di intrattenimento)
    isIntrattenimento: isIntrattenimento,
    aliquotaImpostaIntrattenimenti: impostaIntrattenimentiRate,
    baseImponibileIntrattenimenti: isIntrattenimento ? Math.round(netRevenue * 100) / 100 : 0,
    importoImpostaIntrattenimenti: Math.round(impostaIntrattenimenti * 100) / 100,
    
    // Diritto d'autore SIAE (se applicabile)
    dirittoAutore: Number(event.authorRights) || 0,
    
    // Totali
    totaleImposte: Math.round((vatAmount + impostaIntrattenimenti) * 100) / 100,
    incassoNetto: Math.round((netRevenue - impostaIntrattenimenti) * 100) / 100
  };

  return {
    // Tipo report esplicito
    reportType,
    reportDate: today,
    
    quadroA,
    quadroB,
    quadroC,
    dailySales,
    // Dati aggiuntivi per compatibilità
    activeTicketsCount: activeTickets.length,
    cancelledTicketsCount: cancelledTickets.length,
    totalRevenue,
    today
  };
}

// C1 Report - Modello conforme normativa SIAE
// STRUTTURA: QUADRO A (dati identificativi), QUADRO B (dettaglio biglietti), QUADRO C (imposte)
// Query param: type=giornaliero|daily (default) or type=mensile|monthly
router.get('/api/siae/ticketed-events/:id/reports/c1', requireAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const reportTypeParam = (req.query.type as string) || 'giornaliero';
    const reportType: 'giornaliero' | 'mensile' = (reportTypeParam === 'mensile' || reportTypeParam === 'monthly') ? 'mensile' : 'giornaliero';
    
    // Accetta parametro date per selezionare data/mese di riferimento
    const dateParam = req.query.date as string;
    const reportDate = dateParam ? new Date(dateParam) : new Date();
    
    const event = await siaeStorage.getSiaeTicketedEvent(id);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }

    // Ottieni dati company per QUADRO A - Organizzatore
    const company = event.companyId ? await storage.getCompany(event.companyId) : null;
    
    // Ottieni siaeSystemConfig per QUADRO A - Titolare Sistema Emissione
    // Usa getGlobalSiaeSystemConfig() perché la config viene salvata globalmente
    const siaeConfig = await siaeStorage.getGlobalSiaeSystemConfig() || null;
    
    // Ottieni location per QUADRO A - Dati Locale
    // Nota: getSiaeTicketedEvent restituisce eventLocation, non locationId
    const locationId = event.eventLocation || event.locationId;
    const location = locationId ? await storage.getLocation(locationId) : null;
    
    const sectors = await siaeStorage.getSiaeEventSectors(id);
    const allTickets = await siaeStorage.getSiaeTicketsByEvent(id);
    
    // Usa la funzione helper per costruire i dati del report
    const reportData = buildC1ReportData(event, company, siaeConfig, location, sectors, allTickets, { 
      reportType,
      reportDate: reportDate
    });

    // Risposta conforme al modello C1 SIAE - strutturata in Quadri
    res.json({
      // Metadata report
      reportType: reportData.reportType,
      reportName: reportType === 'mensile' ? 'MODELLO C.1 - Riepilogo Mensile Titoli di Accesso' : 'MODELLO C.1 - Registro Giornaliero Titoli di Accesso',
      generatedAt: new Date().toISOString(),

      // QUADRO A - Dati Identificativi (conforme normativa SIAE)
      quadroA: reportData.quadroA,

      // QUADRO B - Dettaglio Titoli di Accesso per Ordine/Settore
      quadroB: {
        ...reportData.quadroB,
        // Alias per backward compatibility
        totaleBigliettiEmessi: reportData.quadroB.totaleBigliettiVenduti,
      },

      // QUADRO C - Riepilogo Imposte e Contributi
      quadroC: reportData.quadroC,

      // Dati legacy per compatibilità
      eventId: id,
      dailySales: reportData.dailySales
    });
  } catch (error: any) {
    console.error('[C1 Report] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

// C1 Report - Send to SIAE Transmissions (Struttura Quadri A/B/C conforme normativa SIAE)
// Usa la stessa funzione helper buildC1ReportData per garantire consistenza con l'endpoint GET
// Usa requireOrganizer per permettere a gestore, organizer e super_admin di inviare report
router.post('/api/siae/ticketed-events/:id/reports/c1/send', requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { toEmail, reportType: reqReportType } = req.body;
    const reportType: 'giornaliero' | 'mensile' = (reqReportType === 'mensile' || reqReportType === 'monthly') ? 'mensile' : 'giornaliero';
    const isMonthly = reportType === 'mensile';
    
    // Get event data
    const event = await siaeStorage.getSiaeTicketedEvent(id);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }

    // Get company data for Quadro A - Organizzatore
    const company = await storage.getCompany(event.companyId);
    
    // Ottieni siaeSystemConfig per QUADRO A - Titolare Sistema Emissione
    // Usa getGlobalSiaeSystemConfig() perché la config viene salvata globalmente
    const siaeConfig = await siaeStorage.getGlobalSiaeSystemConfig() || null;
    
    // Ottieni location per QUADRO A - Dati Locale
    // Nota: getSiaeTicketedEvent restituisce eventLocation, non locationId
    const locationId = event.eventLocation || event.locationId;
    const location = locationId ? await storage.getLocation(locationId) : null;

    // Get tickets and sectors for C1 report data (usa stesse funzioni del GET)
    const allTickets = await siaeStorage.getSiaeTicketsByEvent(id);
    const sectors = await siaeStorage.getSiaeEventSectors(id);
    
    // Usa la funzione helper condivisa per costruire i dati del report
    // Questo garantisce che GET e POST usino gli stessi calcoli
    const reportData = buildC1ReportData(event, company, siaeConfig, location, sectors, allTickets, { 
      reportType,
      reportDate: new Date()
    });

    // ===== USA generateRCAXml - Formato RiepilogoControlloAccessi per RCA =====
    // Genera XML conforme SIAE DTD ControlloAccessi_v0001_20080626.dtd
    // RCA (C1 evento) genera risposta da SIAE
    // NOTA: NON usare generateC1LogXml che genera LogTransazione - causa errore SIAE 40605
    const eventDate = event.eventDate ? new Date(event.eventDate) : new Date();
    
    // Get progressive number for this transmission
    const transmissionCount = await siaeStorage.getSiaeTransmissionCount(event.companyId);
    const progressivoGenerazione = transmissionCount + 1;
    
    // Prepara i biglietti per generateRCAXml (formato SiaeTicketForLog)
    // IMPORTANTE: Determinare correttamente lo status per conformità SIAE
    // Se cancellationReasonCode o cancellationDate sono presenti, il biglietto è annullato
    const ticketsForLog: SiaeTicketForLog[] = allTickets.map(t => {
      // Determina lo status corretto: se ha motivo/data annullamento, è annullato
      let effectiveStatus = t.status || 'emitted';
      if (!isCancelledStatus(effectiveStatus) && (t.cancellationReasonCode || t.cancellationDate)) {
        effectiveStatus = 'cancelled'; // Forza status annullato se ha dati di annullamento
      }
      
      return {
        id: t.id,
        fiscalSealCode: t.fiscalSealCode || null,
        progressiveNumber: t.progressiveNumber || 0,
        cardCode: t.cardCode || null,
        emissionChannelCode: t.emissionChannelCode || null,
        emissionDate: t.emissionDate || new Date(),
        ticketTypeCode: t.ticketTypeCode || 'R1',
        sectorCode: t.sectorCode || 'P0',
        grossAmount: t.grossAmount || '0',
        netAmount: t.netAmount || null,
        vatAmount: t.vatAmount || null,
        prevendita: t.prevendita || null,
        prevenditaVat: t.prevenditaVat || null,
        status: effectiveStatus,
        cancellationReasonCode: t.cancellationReasonCode || null,
        cancellationDate: t.cancellationDate || null,
        isComplimentary: t.isComplimentary || false,
        row: t.row || null,
        seatNumber: t.seatNumber || null,
        participantFirstName: t.participantFirstName || null,
        participantLastName: t.participantLastName || null,
        originalTicketId: t.originalTicketId || null,
        replacedByTicketId: t.replacedByTicketId || null,
        originalProgressiveNumber: t.progressiveNumber || null,
      };
    });
    
    // Prepara evento per generateRCAXml (formato SiaeEventForLog)
    const eventForLog: SiaeEventForLog = {
      id: event.id,
      name: event.eventName || 'Evento',
      date: eventDate,
      time: event.eventTime ? new Date(event.eventTime) : eventDate,
      venueCode: location?.siaeLocationCode || event.siaeVenueCode || '0000000000001',
      genreCode: event.genreCode || '64',
      organizerTaxId: company?.fiscalCode || company?.taxId || siaeConfig?.taxId || '',
      organizerName: company?.name || siaeConfig?.businessName || 'Organizzatore',
      tipoTassazione: (event.taxationType as 'S' | 'I') || 'I',
      ivaPreassolta: (event.ivaPreassolta as 'N' | 'B' | 'F') || 'N',
    };
    
    // Prepara parametri per generateRCAXml - Formato RiepilogoControlloAccessi (Allegato B)
    // NOTA: Usa generateRCAXml invece di generateC1LogXml (deprecato - causa errore SIAE 40605)
    const companyTaxId = company?.fiscalCode || company?.taxId || siaeConfig?.taxId || '';
    const companyBusinessName = company?.name || siaeConfig?.businessName || 'Azienda';
    
    // FIX 2026-01-17: Per RCA (S/MIME), codice sistema DEVE provenire dalla Smart Card
    const rcaEfffData = getCachedEfffData();
    const rcaSmimeResult = resolveSystemCodeForSmime(rcaEfffData, siaeConfig);
    
    if (!rcaSmimeResult.success || !rcaSmimeResult.systemCode) {
      console.error(`[RCA] BLOCCO: ${rcaSmimeResult.error}`);
      return res.status(400).json({
        message: rcaSmimeResult.error || 'Smart Card richiesta per trasmissioni RCA',
        code: 'SMARTCARD_REQUIRED_FOR_RCA',
        source: rcaSmimeResult.source,
      });
    }
    
    const rcaResolvedSystemCode = rcaSmimeResult.systemCode;
    if (rcaSmimeResult.warning) {
      console.warn(`[RCA] Warning: ${rcaSmimeResult.warning}`);
    }
    console.log(`[RCA] System code from ${rcaSmimeResult.source}: ${rcaResolvedSystemCode}`);
    
    const rcaParams: RCAParams = {
      companyId: event.companyId,
      eventId: event.id,
      event: eventForLog,
      tickets: ticketsForLog,
      systemConfig: {
        systemCode: rcaResolvedSystemCode, // FIX: Usa codice risolto per coerenza
        taxId: siaeConfig?.taxId || companyTaxId,
        businessName: siaeConfig?.businessName || companyBusinessName,
      },
      companyName: companyBusinessName,
      taxId: companyTaxId,
      progressivo: progressivoGenerazione,
      venueName: location?.name || event.eventLocation || 'Locale',
    };
    
    // Genera XML RiepilogoControlloAccessi usando generateRCAXml
    const rcaResult = generateRCAXml(rcaParams);
    
    if (!rcaResult.success) {
      return res.status(400).json({
        message: `Generazione RiepilogoControlloAccessi fallita: ${rcaResult.errors.join('; ')}`,
        errors: rcaResult.errors,
        warnings: rcaResult.warnings
      });
    }
    
    let xmlContent = rcaResult.xml;
    
    // AUTO-CORREZIONE PREVENTIVA: Correggi automaticamente errori comuni prima dell'invio
    const autoCorrectionRcaEvent = autoCorrectSiaeXml(xmlContent, eventForLog.genreCode);
    if (autoCorrectionRcaEvent.corrections.length > 0) {
      console.log(`[SIAE-ROUTES] AUTO-CORREZIONE: Applicate ${autoCorrectionRcaEvent.corrections.length} correzioni automatiche per RCA evento:`);
      for (const corr of autoCorrectionRcaEvent.corrections) {
        console.log(`  - ${corr.field}: ${corr.reason} (previene errore SIAE ${corr.siaeErrorPrevented})`);
      }
      xmlContent = autoCorrectionRcaEvent.correctedXml;
    }
    if (autoCorrectionRcaEvent.uncorrectableErrors.length > 0) {
      console.log(`[SIAE-ROUTES] ERRORI NON CORREGGIBILI: ${autoCorrectionRcaEvent.uncorrectableErrors.map(e => e.message).join('; ')}`);
    }
    
    // Nome file conforme Allegato C SIAE (Provvedimento Agenzia Entrate 04/03/2008):
    // Formato: RCA_AAAA_MM_GG_SSSSSSSS_###_XSI_V.XX.YY.p7m
    // Usa generateSiaeFileName per garantire formato corretto
    // Riusa rcaResolvedSystemCode già calcolato per coerenza con XML (errori SIAE 0600/0603)
    // fileName will be updated to .p7m if signed, otherwise .xsi
    let fileName = generateSiaeFileName('rca', eventDate, progressivoGenerazione, null, rcaResolvedSystemCode);

    // Check if digital signature is requested via smart card
    const { signWithSmartCard } = req.body;
    let signedXmlContent: string | undefined;
    let p7mBase64: string | undefined;
    let signatureData: { signatureValue: string; certificateData: string; signedAt: string } | null = null;
    
    if (signWithSmartCard) {
      console.log('[C1 Send] Digital signature requested via smart card');
      
      try {
        // Check if bridge is connected
        if (!isBridgeConnected()) {
          return res.status(400).json({ 
            message: "App desktop Event4U non connessa. Impossibile firmare il report.",
            code: "BRIDGE_NOT_CONNECTED"
          });
        }
        
        // Check if card is ready
        const cardReady = isCardReadyForSeals();
        if (!cardReady.ready) {
          return res.status(400).json({ 
            message: cardReady.error || "Smart Card SIAE non pronta",
            code: "CARD_NOT_READY"
          });
        }
        
        // Request digital signature from smart card
        const signature = await requestXmlSignature(xmlContent);
        
        // Supporta sia CAdES-BES (nuovo) che XMLDSig (legacy)
        if (signature.p7mBase64) {
          // CAdES-BES: mantieni il P7M Base64 separato per l'allegato email
          p7mBase64 = signature.p7mBase64;
          console.log(`[C1 Send] CAdES-BES signature created at ${signature.signedAt} (${signature.algorithm || 'SHA-256'})`);
        } else if (signature.signedXml) {
          // Legacy XMLDSig (deprecato)
          signedXmlContent = signature.signedXml;
          console.log('[C1 Send] XMLDSig signature created at', signature.signedAt, '(DEPRECATO)');
        }
        
        signatureData = {
          signatureValue: signature.signatureValue || '',
          certificateData: signature.certificateData || '',
          signedAt: signature.signedAt
        };
        // Update filename to .p7m for signed files per Allegato C SIAE
        fileName = generateSiaeFileName('rca', eventDate, progressivoGenerazione, 'cades', rcaResolvedSystemCode);
        
      } catch (signError: any) {
        console.error('[C1 Send] Signature error:', signError.message);
        return res.status(400).json({ 
          message: `Errore firma digitale: ${signError.message}`,
          code: "SIGNATURE_ERROR"
        });
      }
    }

    // Create transmission record - pass periodDate as Date object
    // Include ticketedEventId to link transmission to event
    // IMPORTANTE: Per C1 evento (LogTransazione) usare 'rca' per generare risposta SIAE
    const effectiveSignatureFormat = p7mBase64 ? 'cades' : (signedXmlContent ? 'xmldsig' : null);
    const fileExtension = effectiveSignatureFormat === 'cades' ? '.p7m' : '.xsi';
    
    // Calculate transmission statistics for RCA report
    const rcaSendStats = await calculateTransmissionStats(
      reportData.tickets || [],
      event.companyId,
      id,
      event.tipoTassazione,
      event.entertainmentIncidence
    );
    const rcaSendFileHash = calculateFileHash(signedXmlContent || xmlContent);
    
    // FIX 2026-01-15: Salva systemCode per garantire coerenza nei reinvii (errori SIAE 0600/0603)
    const transmission = await siaeStorage.createSiaeTransmission({
      companyId: event.companyId,
      ticketedEventId: id, // Collegamento all'evento SIAE
      transmissionType: 'rca', // RCA = Riepilogo Controllo Accessi (C1 evento, genera risposta SIAE)
      periodDate: eventDate,
      fileName: fileName.replace(fileExtension, ''), // Nome senza estensione
      fileExtension,
      fileContent: signedXmlContent || xmlContent, // XMLDSig firmato o XML originale
      p7mContent: p7mBase64 || null, // CAdES-BES P7M per resend offline
      signatureFormat: effectiveSignatureFormat,
      signedAt: (p7mBase64 || signedXmlContent) ? new Date() : null,
      status: 'pending',
      ticketsCount: reportData.activeTicketsCount,
      ticketsCancelled: reportData.cancelledTicketsCount,
      totalAmount: reportData.totalRevenue.toFixed(2),
      progressivoInvio: progressivoGenerazione, // Progressivo invio per periodo fiscale
      systemCode: rcaResolvedSystemCode, // FIX: Salva codice per reinvii futuri
      fileHash: rcaSendFileHash,
      totalIva: rcaSendStats.totalIva.toFixed(2),
      totalEsenti: rcaSendStats.totalEsenti.toFixed(2),
      totalImpostaIntrattenimento: rcaSendStats.totalImpostaIntrattenimento.toFixed(2),
      cfOrganizzatore: siaeConfig?.taxId || '',
      ticketsChanged: rcaSendStats.ticketsChanged,
      ticketsResold: rcaSendStats.ticketsResold,
    });

    // Optionally send email
    if (toEmail) {
      const { sendSiaeTransmissionEmail } = await import('./email-service');
      
      // FIX 2026-01-15: Usa rcaResolvedSystemCode già calcolato per coerenza (errori SIAE 0600/0603, async per DTD validator)
      const preValidation = await validatePreTransmission(
        signedXmlContent || xmlContent,
        rcaResolvedSystemCode, // FIX: Usa codice risolto, non variabile inesistente
        'rca',
        eventDate
      );
      
      if (!preValidation.canTransmit) {
        await siaeStorage.updateSiaeTransmission(transmission.id, {
          status: 'error',
          errorMessage: preValidation.errors.map(e => `[${e.siaeErrorCode || 'ERR'}] ${e.message}`).join('; '),
        });
        return res.status(400).json({
          success: false,
          error: 'Validazione pre-trasmissione fallita',
          errors: preValidation.errors,
          warnings: preValidation.warnings,
          details: preValidation.details
        });
      }
      
      const emailResult = await sendSiaeTransmissionEmail({
        to: toEmail,
        companyName: company?.name || 'N/A',
        transmissionType: 'rca', // RCA = Riepilogo Controllo Accessi (C1 evento, genera risposta SIAE)
        periodDate: eventDate,
        ticketsCount: reportData.activeTicketsCount,
        totalAmount: reportData.totalRevenue.toFixed(2),
        xmlContent: signedXmlContent || xmlContent, // XML originale o XMLDSig firmato
        transmissionId: transmission.id,
        systemCode: rcaResolvedSystemCode, // FIX: Usa codice risolto per coerenza Allegato C
        signWithSmime: true, // Per Allegato C SIAE 1.6.2 - firma S/MIME obbligatoria
        requireSignature: true,
        p7mBase64: p7mBase64, // CAdES-BES P7M per allegato email
        signatureFormat: p7mBase64 ? 'cades' : (signedXmlContent ? 'xmldsig' : undefined),
      });

      // Controlla se l'invio è fallito (firma S/MIME non disponibile)
      if (!emailResult.success) {
        await siaeStorage.updateSiaeTransmission(transmission.id, {
          status: 'failed',
          error: emailResult.error || 'Invio email fallito',
        });
        return res.status(400).json({ 
          success: false, 
          message: emailResult.error || 'Invio email fallito - Firma S/MIME richiesta',
          transmissionId: transmission.id,
        });
      }

      await siaeStorage.updateSiaeTransmission(transmission.id, {
        status: 'sent',
        sentAt: new Date(),
        sentToPec: toEmail,
        smimeSigned: emailResult.smimeSigned || false,
        smimeSignerEmail: emailResult.signerEmail || null,
        smimeSignerName: emailResult.signerName || null,
        smimeSignedAt: emailResult.signedAt ? new Date(emailResult.signedAt) : null,
      });
    }

    res.status(201).json({ 
      success: true, 
      transmissionId: transmission.id,
      signed: signWithSmartCard && signatureData ? true : false,
      signedAt: signatureData?.signedAt || null,
      message: signWithSmartCard && signatureData 
        ? "Report C1 firmato digitalmente e salvato con successo"
        : toEmail 
          ? "Report C1 inviato con successo" 
          : "Report C1 salvato come trasmissione"
    });
  } catch (error: any) {
    console.error('[C1 Send] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET /api/siae/ticketed-events/:id/validate-prerequisites - Validazione prerequisiti SIAE per trasmissione
router.get('/api/siae/ticketed-events/:id/validate-prerequisites', requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const eventId = req.params.id;
    const user = req.user as any;
    
    // Ottieni evento SIAE
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(eventId);
    if (!ticketedEvent) {
      return res.status(404).json({ message: "Evento SIAE non trovato" });
    }
    
    // Verifica accesso
    if (user.role !== 'super_admin' && ticketedEvent.companyId !== user.companyId) {
      return res.status(403).json({ message: "Accesso non autorizzato" });
    }
    
    // Ottieni dati correlati
    const company = ticketedEvent.companyId ? await storage.getCompany(ticketedEvent.companyId) : null;
    const baseEvent = await storage.getEvent(ticketedEvent.eventId);
    const sectors = await siaeStorage.getSiaeEventSectors(eventId);
    const systemConfig = await siaeStorage.getGlobalSiaeSystemConfig();
    
    // Ottieni dati Smart Card dal bridge (se connesso)
    const bridgeConnected = isBridgeConnected();
    const efffData = getCachedEfffData();
    
    // Costruisci dati per validazione
    const prerequisiteData: SiaePrerequisiteData = {
      company: {
        id: company?.id || '',
        name: company?.name || '',
        taxId: company?.taxId || null,
        fiscalCode: company?.fiscalCode || null,
        regimeFiscale: company?.regimeFiscale || null,
      },
      ticketedEvent: {
        id: ticketedEvent.id,
        siaeLocationCode: ticketedEvent.siaeLocationCode || null,
        genreCode: ticketedEvent.genreCode || '61',
        taxType: ticketedEvent.taxType || 'I',
        entertainmentIncidence: ticketedEvent.entertainmentIncidence ?? null,
        organizerType: ticketedEvent.organizerType || 'G',
        author: ticketedEvent.author || null,
        performer: ticketedEvent.performer || null,
        filmNationality: ticketedEvent.filmNationality || null,
        totalCapacity: ticketedEvent.totalCapacity || 0,
      },
      event: {
        id: baseEvent?.id || '',
        name: baseEvent?.name || ticketedEvent.eventName || '',
        startDatetime: baseEvent?.startDatetime || ticketedEvent.startDate || null,
        endDatetime: baseEvent?.endDatetime || ticketedEvent.endDate || null,
      },
      sectors: sectors.map(s => ({
        id: s.id,
        orderCode: s.sortOrder || null,
        capacity: s.capacity || null,
      })),
      systemConfig: systemConfig ? {
        systemCode: systemConfig.systemCode || null,
      } : null,
      smartCardData: efffData ? {
        systemId: efffData.systemId,
        partnerCodFis: efffData.partnerCodFis,
        partnerName: efffData.partnerName,
      } : null,
      bridgeConnected,
    };
    
    // Esegui validazione
    const validation = validateSiaeReportPrerequisites(prerequisiteData);
    
    res.json(validation);
  } catch (error: any) {
    console.error('[Validate Prerequisites] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET /api/siae/ticketed-events/:id/transmissions - Storico trasmissioni per evento
router.get('/api/siae/ticketed-events/:id/transmissions', requireAuth, requireOrganizer, async (req: Request, res: Response) => {
  try {
    const eventId = req.params.id;
    const user = req.user as any;
    
    // Verifica che l'evento esista e appartenga all'utente
    const event = await siaeStorage.getSiaeTicketedEvent(eventId);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    // Per super_admin mostra tutte le trasmissioni, altrimenti filtra per companyId
    const companyId = user.role === 'super_admin' ? event.companyId : user.companyId;
    
    // Verifica accesso all'evento
    if (user.role !== 'super_admin' && event.companyId !== companyId) {
      return res.status(403).json({ message: "Accesso non autorizzato a questo evento" });
    }
    
    const transmissions = await db.select()
      .from(siaeTransmissions)
      .where(and(
        eq(siaeTransmissions.ticketedEventId, eventId),
        eq(siaeTransmissions.companyId, event.companyId)
      ))
      .orderBy(desc(siaeTransmissions.createdAt));
      
    res.json(transmissions);
  } catch (error: any) {
    console.error('[Transmissions History] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

// C2 Report - Riepilogo Abbonamenti (conforme Allegato 4 G.U. n.188 12/08/2004)
router.get('/api/siae/ticketed-events/:id/reports/c2', requireAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const event = await siaeStorage.getSiaeTicketedEvent(id);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }

    // Ottieni dati company per QUADRO A - Organizzatore
    const company = event.companyId ? await storage.getCompany(event.companyId) : null;
    
    // Ottieni siaeSystemConfig per QUADRO A - Titolare Sistema Emissione
    // Usa getGlobalSiaeSystemConfig() perché la config viene salvata globalmente
    const siaeConfig = await siaeStorage.getGlobalSiaeSystemConfig() || null;
    
    // Ottieni location per QUADRO A - Dati Locale
    // Nota: getSiaeTicketedEvent restituisce eventLocation, non locationId
    const locationId = event.eventLocation || event.locationId;
    const location = locationId ? await storage.getLocation(locationId) : null;
    
    const sectors = await siaeStorage.getSiaeEventSectors(id);
    const transactions = await siaeStorage.getSiaeTransactionsByEvent(id);
    
    // Recupera abbonamenti per questo evento
    const subscriptions = await db.select()
      .from(siaeSubscriptions)
      .where(eq(siaeSubscriptions.ticketedEventId, id));
    
    const completedTransactions = transactions.filter(tx => tx.status === 'completed');
    const totalRevenue = completedTransactions.reduce((sum, tx) => sum + (Number(tx.totalAmount) || 0), 0);
    const ticketsSold = completedTransactions.reduce((sum, tx) => sum + (tx.ticketsCount || 0), 0);

    const vatRate = event.vatRate || 10;
    const vatAmount = totalRevenue * (vatRate / (100 + vatRate));
    const netRevenue = totalRevenue - vatAmount;

    const paymentBreakdown: Record<string, { method: string; count: number; amount: number }> = {};
    for (const tx of completedTransactions) {
      const method = tx.paymentMethod || 'other';
      if (!paymentBreakdown[method]) {
        paymentBreakdown[method] = { method, count: 0, amount: 0 };
      }
      paymentBreakdown[method].count += 1;
      paymentBreakdown[method].amount += Number(tx.totalAmount) || 0;
    }

    const sectorBreakdown = sectors.map(s => {
      const soldCount = s.capacity - s.availableSeats;
      const sectorRevenue = soldCount * (Number(s.priceIntero) || 0);
      const sectorVat = sectorRevenue * (vatRate / (100 + vatRate));
      return {
        id: s.id,
        name: s.name,
        sectorCode: s.sectorCode,
        ticketTypeCode: s.sectorCode,
        capacity: s.capacity,
        ticketsSold: soldCount,
        availableSeats: s.availableSeats,
        priceIntero: Number(s.priceIntero) || 0,
        grossRevenue: sectorRevenue,
        vatAmount: sectorVat,
        netRevenue: sectorRevenue - sectorVat,
      };
    });

    // Calcola totali abbonamenti (includi sia 'active' che 'issued')
    const soldSubscriptions = subscriptions.filter(s => s.status === 'active' || s.status === 'issued');
    const cancelledSubscriptions = subscriptions.filter(s => s.status === 'cancelled');
    const subscriptionRevenue = soldSubscriptions.reduce((sum, s) => sum + (Number(s.totalAmount) || 0), 0);
    const cancelledAmount = cancelledSubscriptions.reduce((sum, s) => sum + (Number(s.totalAmount) || 0), 0);

    // Capienza totale
    const capienzaTotale = sectors.reduce((sum, s) => sum + (s.capacity || 0), 0);
    const today = new Date().toISOString().split('T')[0];
    const isIntrattenimento = event.eventType === 'intrattenimento';

    // QUADRO A - Dati Identificativi (conforme Allegato 4 G.U. n.188 12/08/2004)
    const quadroA = {
      // Dati Organizzatore
      denominazioneOrganizzatore: company?.name || 'N/D',
      codiceFiscaleOrganizzatore: company?.fiscalCode || company?.taxId || 'N/D',
      partitaIvaOrganizzatore: company?.taxId || 'N/D',
      indirizzoOrganizzatore: company?.address || 'N/D',
      comuneOrganizzatore: company?.city || 'N/D',
      provinciaOrganizzatore: company?.province || 'N/D',
      capOrganizzatore: company?.postalCode || 'N/D',
      
      // Titolare Sistema di Emissione
      // Usa dati da siaeSystemConfig se disponibile, altrimenti fallback su company
      titolareSistemaEmissione: siaeConfig?.businessName || company?.name || 'N/D',
      codiceFiscaleTitolareSistema: siaeConfig?.taxId || 'N/D',
      partitaIvaTitolareSistema: siaeConfig?.vatNumber || 'N/D',
      indirizzoTitolareSistema: siaeConfig?.businessAddress || 'N/D',
      comuneTitolareSistema: siaeConfig?.businessCity || 'N/D',
      provinciaTitolareSistema: siaeConfig?.businessProvince || 'N/D',
      capTitolareSistema: siaeConfig?.businessPostalCode || 'N/D',
      codiceSistemaEmissione: siaeConfig?.systemCode || event.emissionSystemCode || 'N/D',
      
      // Dati Locale
      // Usa dati da locations table se disponibile, altrimenti fallback su event
      codiceLocale: location?.siaeLocationCode || event.siaeLocationCode || 'N/D',
      denominazioneLocale: location?.name || event.venueName || 'N/D',
      indirizzoLocale: location?.address || event.venueAddress || 'N/D',
      comuneLocale: location?.city || event.venueCity || 'N/D',
      provinciaLocale: 'N/D', // locations table non ha provincia
      capLocale: 'N/D', // locations table non ha CAP
      capienza: capienzaTotale,
      
      // Periodo riferimento
      periodoRiferimento: 'mensile',
      dataRiferimento: today,
    };

    // Raggruppa abbonamenti per tipo per QUADRO B
    const subscriptionsByType = soldSubscriptions.reduce((acc, sub) => {
      const key = `${sub.turnType || 'F'}-${sub.eventsCount || 1}`;
      if (!acc[key]) {
        acc[key] = {
          turnType: sub.turnType || 'F',
          eventsCount: sub.eventsCount || 1,
          count: 0,
          totalAmount: 0,
          cancelled: 0,
        };
      }
      acc[key].count += 1;
      acc[key].totalAmount += Number(sub.totalAmount) || 0;
      return acc;
    }, {} as Record<string, any>);

    // Conta annullamenti per tipo
    cancelledSubscriptions.forEach(sub => {
      const key = `${sub.turnType || 'F'}-${sub.eventsCount || 1}`;
      if (subscriptionsByType[key]) {
        subscriptionsByType[key].cancelled += 1;
      }
    });

    // QUADRO B - Dettaglio Abbonamenti (conforme Allegato 4)
    // Colonne: Tipo titolo (TAB.3), Codice abb., I/S, F/L, Venduti, Importo lordo, Annullati, N° eventi
    const righeDettaglio = Object.values(subscriptionsByType).map((s: any) => ({
      tipoTitolo: 'A1', // Codice TAB.3 per abbonamento
      tipoTitoloDescrizione: 'Abbonamento',
      codiceAbbonamento: `ABB-${s.turnType}${s.eventsCount}`,
      tipoSpettacolo: isIntrattenimento ? 'I' : 'S', // I = Intrattenimento, S = Spettacolo
      turnoAbbonamento: s.turnType, // F = Fisso, L = Libero
      numeroVenduti: s.count,
      importoLordoIncassato: Math.round(s.totalAmount * 100) / 100,
      numeroAnnullati: s.cancelled,
      numeroEventi: s.eventsCount,
    }));

    const quadroB = {
      righeDettaglio,
      totaleAbbonamenti: soldSubscriptions.length,
      totaleAnnullati: cancelledSubscriptions.length,
      totaleImportoLordo: Math.round(subscriptionRevenue * 100) / 100,
    };

    res.json({
      reportType: 'C2',
      reportName: 'MODELLO C.2 - Riepilogo Abbonamenti',
      eventId: id,
      eventName: event.eventName,
      eventDate: event.eventDate,
      eventGenre: event.eventGenre,
      eventLocation: event.eventLocation,
      generatedAt: new Date().toISOString(),
      
      // QUADRO A e B conformi al modello ufficiale
      quadroA,
      quadroB,
      
      summary: {
        totalCapacity: event.totalCapacity || capienzaTotale,
        ticketsSold,
        ticketsCancelled: event.ticketsCancelled || 0,
        occupancyRate: event.totalCapacity ? ((ticketsSold / event.totalCapacity) * 100).toFixed(2) : 0,
        subscriptionsSold: soldSubscriptions.length,
        subscriptionsCancelled: cancelledSubscriptions.length,
        subscriptionRevenue,
        cancelledAmount,
      },
      financials: {
        grossRevenue: totalRevenue,
        vatRate,
        vatAmount,
        netRevenue,
        transactionCount: completedTransactions.length,
      },
      paymentBreakdown: Object.values(paymentBreakdown),
      sectorBreakdown,
      subscriptions: [...soldSubscriptions, ...cancelledSubscriptions].map(s => ({
        id: s.id,
        subscriptionCode: s.subscriptionCode,
        turnType: s.turnType,
        eventsCount: s.eventsCount,
        eventsUsed: s.eventsUsed,
        totalAmount: Number(s.totalAmount) || 0,
        holderName: `${s.holderFirstName} ${s.holderLastName}`,
        status: s.status,
        validFrom: s.validFrom,
        validTo: s.validTo,
      })),
      subscriptionSummary: Object.values(subscriptionsByType).map((s: any) => ({
        ...s,
        tipoTitolo: 'A1',
        tipoSpettacolo: isIntrattenimento ? 'I' : 'S',
      })),
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// XML Report - SIAE Transmission Format
router.get('/api/siae/ticketed-events/:id/reports/xml', requireAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const event = await siaeStorage.getSiaeTicketedEvent(id);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }

    const sectors = await siaeStorage.getSiaeEventSectors(id);
    const tickets = await siaeStorage.getSiaeTicketsByEvent(id);

    const eventDateStr = event.eventDate ? new Date(event.eventDate).toISOString().split('T')[0] : '';
    const generatedAt = new Date().toISOString();
    
    let xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<SIAETransmission xmlns="http://www.siae.it/biglietteria">
  <Header>
    <VersioneSchema>1.0</VersioneSchema>
    <DataOraCreazione>${generatedAt}</DataOraCreazione>
    <TipoTrasmissione>RENDICONTO</TipoTrasmissione>
  </Header>
  <Evento>
    <CodiceEvento>${event.id}</CodiceEvento>
    <NomeEvento><![CDATA[${event.eventName || ''}]]></NomeEvento>
    <DataEvento>${eventDateStr}</DataEvento>
    <LuogoEvento><![CDATA[${event.eventLocation || ''}]]></LuogoEvento>
    <GenereEvento>${event.eventGenre || ''}</GenereEvento>
    <CapienzaTotale>${event.totalCapacity || 0}</CapienzaTotale>
    <BigliettiVenduti>${event.ticketsSold || 0}</BigliettiVenduti>
    <BigliettiAnnullati>${event.ticketsCancelled || 0}</BigliettiAnnullati>
    <IncassoTotale>${Number(event.totalRevenue || 0).toFixed(2)}</IncassoTotale>
    <AliquotaIVA>${event.vatRate || 10}</AliquotaIVA>
  </Evento>
  <Settori>
${sectors.map(s => `    <Settore>
      <CodiceSettore>${s.sectorCode || ''}</CodiceSettore>
      <NomeSettore><![CDATA[${s.name || ''}]]></NomeSettore>
      <TipoBiglietto>${s.sectorCode || ''}</TipoBiglietto>
      <Capienza>${s.capacity || 0}</Capienza>
      <BigliettiVenduti>${s.capacity - s.availableSeats}</BigliettiVenduti>
      <PostiDisponibili>${s.availableSeats || 0}</PostiDisponibili>
      <Prezzo>${Number(s.priceIntero || 0).toFixed(2)}</Prezzo>
      <Incasso>${((s.capacity - s.availableSeats) * Number(s.priceIntero || 0)).toFixed(2)}</Incasso>
    </Settore>`).join('\n')}
  </Settori>
  <Biglietti>
${tickets.slice(0, 1000).map(t => `    <Biglietto>
      <CodiceBiglietto>${t.ticketCode || ''}</CodiceBiglietto>
      <NumeroProgressivo>${t.progressiveNumber || ''}</NumeroProgressivo>
      <SigilloFiscale>${t.fiscalSealId || ''}</SigilloFiscale>
      <Stato>${t.status || ''}</Stato>
      <Prezzo>${Number(t.ticketPrice || 0).toFixed(2)}</Prezzo>
      <DataEmissione>${t.emissionDate ? new Date(t.emissionDate).toISOString() : ''}</DataEmissione>
    </Biglietto>`).join('\n')}
  </Biglietti>
</SIAETransmission>`;

    res.setHeader('Content-Type', 'application/xml');
    res.setHeader('Content-Disposition', `attachment; filename="SIAE_${event.eventName?.replace(/[^a-zA-Z0-9]/g, '_')}_${eventDateStr}.xml"`);
    res.send(xmlContent);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// PDF Report data - Returns data for frontend PDF generation
router.get('/api/siae/ticketed-events/:id/reports/pdf', requireAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const event = await siaeStorage.getSiaeTicketedEvent(id);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }

    const sectors = await siaeStorage.getSiaeEventSectors(id);
    const transactions = await siaeStorage.getSiaeTransactionsByEvent(id);
    const tickets = await siaeStorage.getSiaeTicketsByEvent(id);

    const completedTransactions = transactions.filter(tx => tx.status === 'completed');
    const totalRevenue = completedTransactions.reduce((sum, tx) => sum + (Number(tx.totalAmount) || 0), 0);

    const salesByDate: Record<string, { 
      date: string; 
      ticketsSold: number; 
      totalAmount: number;
    }> = {};

    for (const tx of completedTransactions) {
      const dateStr = tx.createdAt ? new Date(tx.createdAt).toISOString().split('T')[0] : 'N/D';
      if (!salesByDate[dateStr]) {
        salesByDate[dateStr] = { date: dateStr, ticketsSold: 0, totalAmount: 0 };
      }
      salesByDate[dateStr].ticketsSold += tx.ticketsCount || 0;
      salesByDate[dateStr].totalAmount += Number(tx.totalAmount) || 0;
    }

    res.json({
      reportType: 'PDF',
      reportName: 'Registro SIAE - Stampa',
      eventId: id,
      eventName: event.eventName,
      eventDate: event.eventDate,
      eventLocation: event.eventLocation,
      eventGenre: event.eventGenre,
      generatedAt: new Date().toISOString(),
      summary: {
        totalCapacity: event.totalCapacity || 0,
        ticketsSold: event.ticketsSold || 0,
        ticketsCancelled: event.ticketsCancelled || 0,
        totalRevenue,
        vatRate: event.vatRate || 10,
      },
      dailySales: Object.values(salesByDate).sort((a, b) => a.date.localeCompare(b.date)),
      sectors: sectors.map(s => ({
        name: s.name,
        sectorCode: s.sectorCode,
        ticketTypeCode: s.sectorCode,
        capacity: s.capacity,
        soldCount: s.capacity - s.availableSeats,
        availableSeats: s.availableSeats,
        price: Number(s.priceIntero) || 0,
        revenue: (s.capacity - s.availableSeats) * (Number(s.priceIntero) || 0),
      })),
      ticketsSample: tickets.slice(0, 50).map(t => ({
        ticketCode: t.ticketCode,
        progressiveNumber: t.progressiveNumber,
        status: t.status,
        price: Number(t.ticketPrice) || 0,
        emissionDate: t.emissionDate,
      })),
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// Log seal generation
router.post('/smart-card/seal-log', requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = (req.user as any)?.id;
    if (!userId) {
      return res.status(401).json({ message: "Non autorizzato" });
    }
    
    // Validate request body
    const parseResult = smartCardSealLogSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json({ 
        message: "Dati non validi", 
        errors: parseResult.error.errors 
      });
    }
    
    const { sessionId, fiscalSealId, ticketId, sealCode, progressiveNumber, status, errorMessage, durationMs } = parseResult.data;
    
    // Verify session ownership
    const session = await siaeStorage.getSmartCardSessionById(sessionId);
    if (!session) {
      return res.status(404).json({ message: "Sessione non trovata" });
    }
    
    if (session.userId !== userId) {
      return res.status(403).json({ message: "Non autorizzato a registrare log per questa sessione" });
    }
    
    const log = await siaeStorage.createSmartCardSealLog({
      sessionId,
      fiscalSealId: fiscalSealId || null,
      ticketId: ticketId || null,
      sealCode,
      progressiveNumber,
      status,
      errorMessage: errorMessage || null,
      completedAt: new Date(),
      durationMs: durationMs || null
    });
    
    // Update session counters only on success
    if (status === 'success') {
      await siaeStorage.incrementSmartCardSessionCounters(sessionId);
    } else {
      // Update error count on failure
      await siaeStorage.updateSmartCardSession(sessionId, {
        errorCount: (session.errorCount || 0) + 1,
        lastError: errorMessage || 'Errore generazione sigillo',
        lastActivityAt: new Date()
      });
      
      // Log failure
      await siaeStorage.createAuditLog({
        companyId: (req.user as any)?.companyId || '',
        userId,
        action: 'seal_generation_failed',
        entityType: 'smart_card_seal_log',
        entityId: log.id,
        description: `Errore generazione sigillo: ${errorMessage || 'Errore sconosciuto'}`,
        fiscalSealCode: sealCode,
        ipAddress: (req.ip || '').substring(0, 45),
        userAgent: (req.get('user-agent') || '').substring(0, 500)
      });
    }
    
    res.status(201).json(log);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== CLIENT WALLET API ====================

// GET /api/siae/tickets/my - Get current user's purchased SIAE tickets
router.get("/api/siae/tickets/my", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    
    if (!user.phone && !user.email) {
      return res.json([]);
    }
    
    // Get all tickets for the user via customer association (by phone or email)
    // Import required tables
    const { siaeTickets, siaeCustomers, siaeTicketedEvents, siaeEventSectors } = await import("@shared/schema");
    const { db } = await import("./db");
    const { eq, or, desc, sql } = await import("drizzle-orm");
    
    const tickets = await db.select({
      ticket: siaeTickets,
      event: siaeTicketedEvents,
      sector: siaeEventSectors,
    })
      .from(siaeTickets)
      .innerJoin(siaeCustomers, eq(siaeTickets.customerId, siaeCustomers.id))
      .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
      .innerJoin(siaeEventSectors, eq(siaeTickets.sectorId, siaeEventSectors.id))
      .where(
        user.phone && user.email
          ? sql`(${siaeCustomers.phone} = ${user.phone} OR ${siaeCustomers.email} = ${user.email})`
          : user.phone
            ? eq(siaeCustomers.phone, user.phone)
            : eq(siaeCustomers.email, user.email)
      )
      .orderBy(desc(siaeTicketedEvents.createdAt));
    
    res.json(tickets);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== CASSA BIGLIETTI API ====================

// GET /api/cashiers/events/:eventId/allocation - Get current user's allocation for event
router.get("/api/cashiers/events/:eventId/allocation", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { eventId } = req.params;
    
    // Usa helper per supportare sia nuove che vecchie sessioni cassiere
    const cashierId = getSiaeCashierId(user);
    if (!cashierId) {
      return res.status(400).json({ message: "ID cassiere non trovato nella sessione" });
    }
    const allocation = await siaeStorage.getCashierAllocationByCashierAndEvent(cashierId, eventId);
    
    if (!allocation) {
      return res.status(404).json({ message: "Nessuna allocazione trovata per questo evento" });
    }
    
    res.json(allocation);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// GET /api/cashiers/events/:eventId/allocations - Get all allocations for event (gestore only)
router.get("/api/cashiers/events/:eventId/allocations", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const { eventId } = req.params;
    
    const allocations = await siaeStorage.getCashierAllocationsByEvent(eventId);
    
    res.json(allocations);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// POST /api/cashiers/allocations - Create cashier allocation (gestore only)
router.post("/api/cashiers/allocations", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    // Accetta sia cashierId (nuovo) che userId (legacy) per compatibilità
    const { eventId, cashierId, userId, sectorId, quotaQuantity } = req.body;
    const finalCashierId = cashierId || userId;
    
    if (!eventId || !finalCashierId || quotaQuantity === undefined) {
      return res.status(400).json({ message: "Dati mancanti: eventId, cashierId e quotaQuantity sono richiesti" });
    }
    
    // Check if allocation already exists
    const existing = await siaeStorage.getCashierAllocationByCashierAndEvent(finalCashierId, eventId);
    if (existing) {
      return res.status(409).json({ message: "Esiste già un'allocazione per questo cassiere per l'evento" });
    }
    
    const allocation = await siaeStorage.createCashierAllocation({
      companyId: user.companyId,
      eventId,
      cashierId: finalCashierId,
      sectorId: sectorId || null,
      quotaQuantity: Number(quotaQuantity),
      quotaUsed: 0,
      isActive: true
    });
    
    // Audit log
    await siaeStorage.createAuditLog({
      companyId: user.companyId,
      userId: user.id,
      action: 'cashier_allocation_created',
      entityType: 'cashier_allocation',
      entityId: allocation.id,
      description: `Creata allocazione per cassiere con quota ${quotaQuantity}`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    res.status(201).json(allocation);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// PATCH /api/cashiers/allocations/:id - Update cashier allocation (gestore only)
router.patch("/api/cashiers/allocations/:id", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { id } = req.params;
    const { quotaQuantity, sectorId, isActive } = req.body;
    
    const allocation = await siaeStorage.getCashierAllocation(id);
    if (!allocation) {
      return res.status(404).json({ message: "Allocazione non trovata" });
    }
    
    const updateData: any = {};
    if (quotaQuantity !== undefined) updateData.quotaQuantity = Number(quotaQuantity);
    if (sectorId !== undefined) updateData.sectorId = sectorId;
    if (isActive !== undefined) updateData.isActive = isActive;
    
    const updated = await siaeStorage.updateCashierAllocation(id, updateData);
    
    // Audit log
    await siaeStorage.createAuditLog({
      companyId: user.companyId,
      userId: user.id,
      action: 'cashier_allocation_updated',
      entityType: 'cashier_allocation',
      entityId: id,
      description: `Aggiornata allocazione cassiere`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    res.json(updated);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// POST /api/cashiers/events/:eventId/tickets - Emit ticket from cashier
// Uses atomic transaction to prevent race conditions on quota
// REQUIRES: Bridge SIAE connected for fiscal seal generation
// Supports quantity parameter for emitting multiple anonymous tickets at once
router.post("/api/cashiers/events/:eventId/tickets", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { eventId } = req.params;
    const { sectorId, ticketType, price, participantFirstName, participantLastName, participantPhone, participantEmail, paymentMethod, skipFiscalSeal, quantity = 1, customText } = req.body;
    
    // Validate quantity (max 50 at once for safety)
    const ticketQuantity = Math.min(Math.max(1, parseInt(quantity) || 1), 50);
    
    // Check if bridge is connected (REQUIRED for fiscal seal emission)
    // Super admin can skip fiscal seal for testing purposes
    const canSkipSeal = user.role === 'super_admin' && skipFiscalSeal === true;
    
    // Debug logging
    const bridgeStatus = getCachedBridgeStatus();
    const bridgeConnected = isBridgeConnected();
    console.log(`[CashierTicket] Bridge check: connected=${bridgeConnected}, status=`, JSON.stringify(bridgeStatus));
    
    if (!canSkipSeal) {
      if (!bridgeConnected) {
        console.log(`[CashierTicket] Rejecting: bridge not connected`);
        return res.status(503).json({ 
          message: "Bridge SIAE non connesso. Avviare l'applicazione desktop Event4U per emettere biglietti con sigillo fiscale.",
          errorCode: "BRIDGE_NOT_CONNECTED"
        });
      }
      
      // Check if card is ready for seal emission
      const cardReady = isCardReadyForSeals();
      console.log(`[CashierTicket] Card check: ready=${cardReady.ready}, error=${cardReady.error}`);
      if (!cardReady.ready) {
        return res.status(503).json({ 
          message: cardReady.error || "Smart Card SIAE non pronta. Verificare che la carta sia inserita nel lettore.",
          errorCode: "CARD_NOT_READY"
        });
      }
    }
    
    // Session check removed - all authorized users can emit tickets directly
    // The quota and allocation system already provides sufficient access control
    
    // Usa helper per supportare sia nuove che vecchie sessioni cassiere
    const cashierId = getSiaeCashierId(user);
    const allocation = cashierId ? await siaeStorage.getCashierAllocationByCashierAndEvent(cashierId, eventId) : null;
    if (!allocation) {
      return res.status(403).json({ 
        message: "Non sei autorizzato a emettere biglietti per questo evento",
        errorCode: "NO_ALLOCATION"
      });
    }
    
    // Get sector if specified, otherwise use allocation's sector
    const finalSectorId = sectorId || allocation.sectorId;
    if (!finalSectorId) {
      return res.status(400).json({ message: "Settore non specificato" });
    }
    
    const sector = await siaeStorage.getSiaeEventSector(finalSectorId);
    if (!sector) {
      return res.status(404).json({ message: "Settore non trovato" });
    }
    
    // Check sector availability for requested quantity
    if (sector.availableSeats < ticketQuantity) {
      return res.status(400).json({ 
        message: `Posti insufficienti: disponibili ${sector.availableSeats}, richiesti ${ticketQuantity}`,
        errorCode: "NO_SEATS_AVAILABLE"
      });
    }
    
    // Check quota for requested quantity
    const quotaRemaining = allocation.quotaQuantity - allocation.quotaUsed;
    if (quotaRemaining < ticketQuantity) {
      return res.status(400).json({ 
        message: `Quota insufficiente: disponibili ${quotaRemaining}, richiesti ${ticketQuantity}`,
        errorCode: "QUOTA_EXCEEDED"
      });
    }
    
    // Get event
    const event = await siaeStorage.getSiaeTicketedEvent(eventId);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    // Check if event is approved for ticket sales
    if ((event as any).approvalStatus !== 'approved') {
      return res.status(403).json({ 
        message: "Non è possibile emettere biglietti per un evento non ancora approvato",
        errorCode: "EVENT_NOT_APPROVED"
      });
    }
    
    // CONTROLLO OBBLIGATORIO: Codice Fiscale Emittente configurato
    const systemConfig = await siaeStorage.getSiaeSystemConfig(event.companyId);
    const company = await storage.getCompany(event.companyId);
    const emitterTaxId = systemConfig?.taxId || company?.fiscalCode || company?.taxId;
    
    if (!emitterTaxId) {
      return res.status(400).json({ 
        message: "Codice Fiscale Emittente non configurato. Contattare l'amministratore per configurare le Impostazioni SIAE.",
        errorCode: "TAX_ID_REQUIRED"
      });
    }
    
    // Calculate ticket price before requesting seal (use appropriate price based on ticket type)
    let sectorPrice = Number(sector.priceIntero) || 0;
    if (ticketType === 'ridotto' && sector.priceRidotto) {
      sectorPrice = Number(sector.priceRidotto);
    } else if (ticketType === 'omaggio' && sector.priceOmaggio) {
      sectorPrice = Number(sector.priceOmaggio);
    }
    const ticketPrice = price || sectorPrice;
    const priceInCents = Math.round(ticketPrice * 100);
    
    // Get or create customer if participant data provided (only for nominative tickets)
    let customerId: string | null = null;
    if (participantPhone || participantEmail) {
      let customer = participantPhone 
        ? await siaeStorage.getSiaeCustomerByPhone(participantPhone)
        : participantEmail 
          ? await siaeStorage.getSiaeCustomerByEmail(participantEmail)
          : undefined;
      
      if (!customer && (participantFirstName || participantLastName)) {
        // Generate a unique code for the customer
        const uniqueCode = `C${Date.now().toString(36).toUpperCase()}${Math.random().toString(36).substring(2, 6).toUpperCase()}`;
        customer = await siaeStorage.createSiaeCustomer({
          firstName: participantFirstName || '',
          lastName: participantLastName || '',
          phone: participantPhone || null,
          email: participantEmail || null,
          uniqueCode
        });
      }
      if (customer) {
        customerId = customer.id;
      }
    }
    
    // For multiple tickets, emit them in a loop
    const emittedTickets: any[] = [];
    let currentTicketsSold = event.ticketsSold || 0;
    let currentTotalRevenue = Number(event.totalRevenue) || 0;
    let currentAvailableSeats = sector.availableSeats;
    
    for (let i = 0; i < ticketQuantity; i++) {
      // Request fiscal seal from bridge BEFORE creating ticket (only if not skipped)
      let fiscalSealData: any = null;
      if (!canSkipSeal) {
        try {
          console.log(`[CashierTicket] Requesting fiscal seal ${i + 1}/${ticketQuantity} for €${ticketPrice}...`);
          fiscalSealData = await requestFiscalSeal(priceInCents);
          console.log(`[CashierTicket] Fiscal seal obtained: counter=${fiscalSealData.counter}, sealNumber=${fiscalSealData.sealNumber}`);
        } catch (sealError: any) {
          console.error(`[CashierTicket] Failed to obtain fiscal seal:`, sealError.message);
          
          // If we already emitted some tickets, return partial success
          if (emittedTickets.length > 0) {
            return res.status(207).json({
              message: `Emessi ${emittedTickets.length}/${ticketQuantity} biglietti. Errore sigillo fiscale al biglietto ${i + 1}: ${sealError.message}`,
              emittedCount: emittedTickets.length,
              requestedCount: ticketQuantity,
              tickets: emittedTickets,
              errorCode: "PARTIAL_EMISSION"
            });
          }
          
          // Audit log per tentativo fallito (solo per utenti, non cassieri - hanno tabella separata)
          if (user.role !== 'cassiere') {
            try {
              await siaeStorage.createAuditLog({
                companyId: user.companyId,
                userId: user.id,
                action: 'ticket_emission_failed',
                entityType: 'ticket',
                entityId: eventId,
                description: `Tentativo emissione biglietto fallito - Sigillo fiscale non ottenuto: ${sealError.message}`,
                ipAddress: (req.ip || '').substring(0, 45),
                userAgent: (req.get('user-agent') || '').substring(0, 500)
              });
            } catch (auditError: any) {
              console.warn(`[CashierTicket] Failed to create audit log for failed emission:`, auditError.message);
            }
          }
          
          return res.status(503).json({ 
            message: `Impossibile ottenere sigillo fiscale: ${sealError.message}`,
            errorCode: "SEAL_GENERATION_FAILED"
          });
        }
      }
      
      // Generate unique ticket code for each ticket
      const sealSuffix = fiscalSealData ? `-${fiscalSealData.counter}` : '';
      const ticketCode = `${event.eventCode || 'TK'}-${Date.now().toString(36).toUpperCase()}-${Math.random().toString(36).substring(2, 6).toUpperCase()}${sealSuffix}`;
      
      // Map ticketType to SIAE ticketTypeCode
      const finalTicketType = ticketType || 'intero';
      const ticketTypeCodeMap: Record<string, string> = {
        'intero': 'INT',
        'ridotto': 'RID',
        'omaggio': 'OMG',
        'abbonamento': 'ABB'
      };
      const ticketTypeCode = ticketTypeCodeMap[finalTicketType] || 'INT';
      
      const result = await siaeStorage.emitTicketWithAtomicQuota({
        allocationId: allocation.id,
        eventId,
        sectorId: finalSectorId,
        sectorCode: (sector.sectorCode || 'XX').slice(0, 2),
        ticketCode,
        ticketType: finalTicketType,
        ticketTypeCode,
        ticketPrice,
        customerId: ticketQuantity === 1 ? customerId : null, // Only link customer for single ticket
        issuedByUserId: user.id,
        participantFirstName: ticketQuantity === 1 ? (participantFirstName || null) : null,
        participantLastName: ticketQuantity === 1 ? (participantLastName || null) : null,
        isComplimentary: finalTicketType === 'omaggio',
        paymentMethod: paymentMethod || 'cash',
        customText: customText || null,
        currentTicketsSold,
        currentTotalRevenue,
        currentAvailableSeats
      });
      
      if (!result.success) {
        // If we already emitted some tickets, return partial success
        if (emittedTickets.length > 0) {
          return res.status(207).json({
            message: `Emessi ${emittedTickets.length}/${ticketQuantity} biglietti. Quota esaurita.`,
            emittedCount: emittedTickets.length,
            requestedCount: ticketQuantity,
            tickets: emittedTickets,
            errorCode: "PARTIAL_EMISSION"
          });
        }
        return res.status(400).json({ 
          message: result.error || "Quota biglietti esaurita. Contatta il gestore per aumentare la quota.",
          errorCode: "QUOTA_EXCEEDED"
        });
      }
      
      // Update ticket with fiscal seal data if available
      if (fiscalSealData?.sealCode && result.ticket) {
        await siaeStorage.updateSiaeTicket(result.ticket.id, {
          fiscalSealCode: fiscalSealData.sealCode,
          fiscalSealCounter: fiscalSealData.counter,
          cardCode: fiscalSealData.serialNumber,
        });
        // Update result.ticket for response
        result.ticket.fiscalSealCode = fiscalSealData.sealCode;
        (result.ticket as any).fiscalSealCounter = fiscalSealData.counter;
        (result.ticket as any).cardCode = fiscalSealData.serialNumber;
      }
      
      // Update counters for next iteration
      currentTicketsSold++;
      currentTotalRevenue += ticketPrice;
      currentAvailableSeats--;
      
      // Create ticket audit entry (outside transaction, not critical)
      // Skip for cassiere role - their ID is in siaeCashiers table, not users (FK constraint)
      if (user.role !== 'cassiere') {
        await siaeStorage.createTicketAudit({
          companyId: user.companyId,
          ticketId: result.ticket!.id,
          operationType: 'emission',
          performedBy: user.id,
          reason: null,
          metadata: { 
            paymentMethod, 
            ticketType, 
            price: ticketPrice,
            batchIndex: ticketQuantity > 1 ? i + 1 : undefined,
            batchTotal: ticketQuantity > 1 ? ticketQuantity : undefined,
            fiscalSeal: fiscalSealData ? {
              sealNumber: fiscalSealData.sealNumber,
              sealCode: fiscalSealData.sealCode,
              serialNumber: fiscalSealData.serialNumber,
              counter: fiscalSealData.counter,
              mac: fiscalSealData.mac,
              dateTime: fiscalSealData.dateTime
            } : null
          }
        });
      }
      
      // General audit log (skip for cassiere role - they have separate table, not in users FK)
      const sealInfo = fiscalSealData ? ` (Sigillo: ${fiscalSealData.counter})` : '';
      const batchInfo = ticketQuantity > 1 ? ` [${i + 1}/${ticketQuantity}]` : '';
      if (user.role !== 'cassiere') {
        await siaeStorage.createAuditLog({
          companyId: user.companyId,
          userId: user.id,
          action: 'ticket_emitted',
          entityType: 'ticket',
          entityId: result.ticket!.id,
          description: `Emesso biglietto ${ticketCode} - €${ticketPrice}${sealInfo}${batchInfo}`,
          ipAddress: (req.ip || '').substring(0, 45),
          userAgent: (req.get('user-agent') || '').substring(0, 500)
        });
      } else {
        console.log(`[CashierTicket] Skipping audit log for cassiere (separate table): ${ticketCode}${sealInfo}${batchInfo}`);
      }
      
      emittedTickets.push({
        ...result.ticket,
        fiscalSeal: fiscalSealData || null
      });
    }
    
    // Return results - single ticket or array for multiple
    if (ticketQuantity === 1) {
      res.status(201).json(emittedTickets[0]);
    } else {
      res.status(201).json(emittedTickets);
    }
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// GET /api/cashiers/events/:eventId/today-tickets - Get today's tickets for current cashier
router.get("/api/cashiers/events/:eventId/today-tickets", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { eventId } = req.params;
    
    // Per cassieri SIAE usa cashierId, per altri utenti usa user.id
    const userId = user.role === 'cassiere' ? (getSiaeCashierId(user) || user.id) : user.id;
    console.log(`[TodayTickets] Fetching for userId=${userId}, eventId=${eventId}, role=${user.role}`);
    const tickets = await siaeStorage.getTodayTicketsByUser(userId, eventId);
    console.log(`[TodayTickets] Found ${tickets.length} tickets`);
    
    res.json(tickets);
  } catch (error: any) {
    console.error(`[TodayTickets] Error:`, error);
    res.status(500).json({ message: error.message });
  }
});

// PATCH /api/siae/tickets/:id/cancel - Cancel a ticket
// Uses atomic transaction to prevent race conditions on quota restoration
// Registers fiscal cancellation via bridge if available
// Request body: { reasonCode: string (SIAE code 01-12, 99), note?: string }
router.patch("/api/siae/tickets/:id/cancel", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { id } = req.params;
    const { reasonCode, note } = req.body;
    
    // Validate reasonCode (SIAE TAB.5 codes: 01-12, 99)
    if (!reasonCode) {
      return res.status(400).json({ message: "Il codice causale di annullamento è richiesto (reasonCode)" });
    }
    
    // Validate reasonCode format
    const validReasonCodes = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '99'];
    if (!validReasonCodes.includes(reasonCode)) {
      return res.status(400).json({ 
        message: `Codice causale non valido. Valori ammessi: ${validReasonCodes.join(', ')}`,
        errorCode: "INVALID_REASON_CODE"
      });
    }
    
    // Combine reasonCode and note for the cancellation reason text
    const reason = note ? `${reasonCode}: ${note}` : reasonCode;
    
    const ticket = await siaeStorage.getSiaeTicket(id);
    if (!ticket) {
      return res.status(404).json({ message: "Biglietto non trovato" });
    }
    
    // Get the ticketed event to retrieve the companyId
    const ticketedEvent = await siaeStorage.getSiaeTicketedEvent(ticket.ticketedEventId);
    if (!ticketedEvent) {
      return res.status(404).json({ message: "Evento associato al biglietto non trovato" });
    }
    const eventCompanyId = ticketedEvent.companyId;
    
    // Verify ticket is not already cancelled
    if (ticket.status === 'cancelled') {
      return res.status(400).json({ 
        message: "Il biglietto è già stato annullato",
        errorCode: "ALREADY_CANCELLED"
      });
    }
    
    // Check authorization: cassiere can only cancel own tickets, gestore/admin/super_admin can cancel any
    const isGestoreOrHigher = ['gestore', 'admin', 'super_admin'].includes(user.role);
    // Per cassieri SIAE usa cashierId per il controllo
    const userIdForCheck = user.role === 'cassiere' ? (getSiaeCashierId(user) || user.id) : user.id;
    if (!isGestoreOrHigher && ticket.issuedByUserId !== userIdForCheck) {
      return res.status(403).json({ 
        message: "Non sei autorizzato ad annullare questo biglietto. Solo il cassiere che ha emesso il biglietto può annullarlo.",
        errorCode: "UNAUTHORIZED_CANCELLATION"
      });
    }
    
    // HARD STOP: Bridge SIAE OBBLIGATORIO per annullamento fiscale
    // L'annullamento fiscale è OBBLIGATORIO, non opzionale
    // Super admin può bypassare solo se esplicitamente richiesto
    const canBypassBridge = user.role === 'super_admin' && req.body.skipFiscalCancellation === true;
    
    if (!canBypassBridge) {
      if (!isBridgeConnected()) {
        // Audit log per tentativo di annullamento senza bridge
        try {
          await siaeStorage.createAuditLog({
            companyId: eventCompanyId,
            userId: userIdForCheck,
            action: 'ticket_cancellation_blocked',
            entityType: 'ticket',
            entityId: id,
            description: `Tentativo annullamento biglietto ${ticket.ticketCode} bloccato - Bridge SIAE non connesso`,
            ipAddress: (req.ip || '').substring(0, 45),
            userAgent: (req.get('user-agent') || '').substring(0, 500)
          });
        } catch (auditError: any) {
          console.warn(`[TicketCancel] Failed to create audit log for blocked cancellation:`, auditError.message);
        }
        
        return res.status(503).json({ 
          message: "Bridge SIAE richiesto per annullamento fiscale. Avviare l'applicazione desktop Event4U prima di procedere.",
          errorCode: "BRIDGE_REQUIRED_FOR_CANCELLATION"
        });
      }
      
      const cardReady = isCardReadyForSeals();
      if (!cardReady.ready) {
        return res.status(503).json({ 
          message: cardReady.error || "Smart Card SIAE non pronta. Verificare che la carta sia inserita nel lettore.",
          errorCode: "CARD_NOT_READY_FOR_CANCELLATION"
        });
      }
    }
    
    // Register fiscal cancellation via bridge (OBBLIGATORIO se bridge richiesto)
    let fiscalCancellationRegistered = false;
    let fiscalCancellationData: any = null;
    
    if (!canBypassBridge) {
      try {
        console.log(`[TicketCancel] Registering fiscal cancellation for ticket ${ticket.ticketCode}...`);
        // Request a cancellation seal (price 0 to indicate cancellation)
        fiscalCancellationData = await requestFiscalSeal(0);
        fiscalCancellationRegistered = true;
        console.log(`[TicketCancel] Fiscal cancellation registered: counter=${fiscalCancellationData.counter}`);
      } catch (sealError: any) {
        console.error(`[TicketCancel] Failed to register fiscal cancellation:`, sealError.message);
        
        // Audit log per tentativo fallito
        try {
          await siaeStorage.createAuditLog({
            companyId: eventCompanyId,
            userId: userIdForCheck,
            action: 'ticket_cancellation_failed',
            entityType: 'ticket',
            entityId: id,
            description: `Annullamento biglietto ${ticket.ticketCode} fallito - Errore sigillo fiscale: ${sealError.message}`,
            ipAddress: (req.ip || '').substring(0, 45),
            userAgent: (req.get('user-agent') || '').substring(0, 500)
          });
        } catch (auditError: any) {
          console.warn(`[TicketCancel] Failed to create audit log for failed cancellation:`, auditError.message);
        }
        
        return res.status(503).json({ 
          message: `Impossibile registrare annullamento fiscale: ${sealError.message}`,
          errorCode: "FISCAL_CANCELLATION_FAILED"
        });
      }
    } else {
      console.log(`[TicketCancel] Super admin bypassing fiscal cancellation for ticket ${ticket.ticketCode}`);
    }
    
    // Per cassieri SIAE usa cashierId, per altri utenti usa user.id
    const userIdForCancellation = user.role === 'cassiere' ? (getSiaeCashierId(user) || user.id) : user.id;
    
    // ATOMIC TRANSACTION: Cancel ticket and restore quota
    const result = await siaeStorage.cancelTicketWithAtomicQuotaRestore({
      ticketId: id,
      cancelledByUserId: userIdForCancellation,
      cancellationReason: reason,
      issuedByUserId: ticket.issuedByUserId,
      ticketedEventId: ticket.ticketedEventId,
      sectorId: ticket.sectorId,
      ticketPrice: Number(ticket.ticketPrice || 0)
    });
    
    if (!result.success) {
      return res.status(400).json({ 
        message: result.error || "Errore durante l'annullamento del biglietto",
        errorCode: "CANCELLATION_FAILED"
      });
    }
    
    // Create ticket audit entry (outside transaction, not critical)
    await siaeStorage.createTicketAudit({
      companyId: eventCompanyId,
      ticketId: id,
      operationType: 'cancellation',
      performedBy: userIdForCancellation,
      reason,
      metadata: { 
        originalPrice: ticket.ticketPrice, 
        cancelledBy: user.fullName || user.username || user.claims?.username || 'Utente',
        originalTicketCode: ticket.ticketCode,
        fiscalCancellation: fiscalCancellationData ? {
          registered: true,
          sealNumber: fiscalCancellationData.sealNumber,
          counter: fiscalCancellationData.counter,
          serialNumber: fiscalCancellationData.serialNumber,
          dateTime: fiscalCancellationData.dateTime
        } : { registered: false }
      }
    });
    
    // General audit log
    const fiscalInfo = fiscalCancellationRegistered ? ' (Registrato fiscalmente)' : '';
    await siaeStorage.createAuditLog({
      companyId: eventCompanyId,
      userId: userIdForCancellation,
      action: 'ticket_cancelled',
      entityType: 'ticket',
      entityId: id,
      description: `Annullato biglietto ${ticket.ticketCode} - Motivo: ${reason}${fiscalInfo}`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    res.json({
      ...result.ticket,
      fiscalCancellationRegistered
    });
  } catch (error: any) {
    console.error(`[TicketCancel] Error in cancel endpoint:`, error);
    res.status(500).json({ message: error.message });
  }
});

// POST /api/siae/tickets/cancel-range - Bulk cancel tickets by progressive number range
// Request body: { ticketedEventId: string, fromNumber: number, toNumber: number, reasonCode: string, note?: string }
router.post("/api/siae/tickets/cancel-range", requireAuth, requireOrganizerOrCashier, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { ticketedEventId, fromNumber, toNumber, reasonCode, note } = req.body;
    
    // Determine user ID for cancellation (supports both regular users and cashiers)
    const userIdForCancellation = user.role === 'cassiere' 
      ? (user.siaeCashierId || user.id) 
      : user.id;
    
    // Validate required fields
    if (!ticketedEventId) {
      return res.status(400).json({ message: "ticketedEventId è richiesto" });
    }
    if (fromNumber === undefined || toNumber === undefined) {
      return res.status(400).json({ message: "fromNumber e toNumber sono richiesti" });
    }
    if (typeof fromNumber !== 'number' || typeof toNumber !== 'number') {
      return res.status(400).json({ message: "fromNumber e toNumber devono essere numeri" });
    }
    if (fromNumber > toNumber) {
      return res.status(400).json({ message: "fromNumber deve essere minore o uguale a toNumber" });
    }
    if (!reasonCode) {
      return res.status(400).json({ message: "reasonCode è richiesto" });
    }
    
    // Validate reasonCode format
    const validReasonCodes = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '99'];
    if (!validReasonCodes.includes(reasonCode)) {
      return res.status(400).json({ 
        message: `Codice causale non valido. Valori ammessi: ${validReasonCodes.join(', ')}`,
        errorCode: "INVALID_REASON_CODE"
      });
    }
    
    // Verify event exists
    const event = await siaeStorage.getSiaeTicketedEvent(ticketedEventId);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    // Check company access (super_admin can access all)
    if (user.role !== 'super_admin' && event.companyId !== user.companyId) {
      return res.status(403).json({ message: "Non autorizzato ad accedere a questo evento" });
    }
    
    // Get all tickets for the event in the range
    const allTickets = await siaeStorage.getSiaeTicketsByEvent(ticketedEventId);
    const ticketsInRange = allTickets.filter(t => 
      t.progressiveNumber >= fromNumber && 
      t.progressiveNumber <= toNumber &&
      t.status !== 'cancelled'
    );
    
    if (ticketsInRange.length === 0) {
      return res.json({
        cancelledCount: 0,
        errors: [],
        message: "Nessun biglietto valido trovato nell'intervallo specificato"
      });
    }
    
    const cancellationReason = note ? `${reasonCode}: ${note}` : reasonCode;
    const cancelledTickets: string[] = [];
    const errors: { ticketId: string; ticketCode: string; error: string }[] = [];
    
    // Cancel each ticket in the range
    for (const ticket of ticketsInRange) {
      try {
        const result = await siaeStorage.cancelTicketWithAtomicQuotaRestore({
          ticketId: ticket.id,
          cancelledByUserId: userIdForCancellation,
          cancellationReason: cancellationReason,
          issuedByUserId: ticket.issuedByUserId,
          ticketedEventId: ticket.ticketedEventId,
          sectorId: ticket.sectorId,
          ticketPrice: Number(ticket.ticketPrice || 0)
        });
        
        if (result.success) {
          cancelledTickets.push(ticket.id);
        } else {
          errors.push({
            ticketId: ticket.id,
            ticketCode: ticket.ticketCode || '',
            error: result.error || 'Errore sconosciuto'
          });
        }
      } catch (err: any) {
        errors.push({
          ticketId: ticket.id,
          ticketCode: ticket.ticketCode || '',
          error: err.message
        });
      }
    }
    
    // Create audit log for bulk cancellation
    await siaeStorage.createAuditLog({
      companyId: user.companyId,
      userId: userIdForCancellation,
      action: 'bulk_tickets_cancelled',
      entityType: 'ticketed_event',
      entityId: ticketedEventId,
      description: `Annullamento massivo biglietti ${fromNumber}-${toNumber}: ${cancelledTickets.length} annullati, ${errors.length} errori`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    res.json({
      cancelledCount: cancelledTickets.length,
      totalInRange: ticketsInRange.length,
      errors,
      message: errors.length === 0 
        ? `Annullati ${cancelledTickets.length} biglietti con successo`
        : `Annullati ${cancelledTickets.length} biglietti, ${errors.length} errori`
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== MODULO CASSA BIGLIETTI ====================

// Helper per ottenere l'ID del cassiere SIAE (supporta sia nuove che vecchie sessioni)
function getSiaeCashierId(user: any): string | undefined {
  // Nuove sessioni: id = siaeCashiers.id
  // Vecchie sessioni: cashierId = siaeCashiers.id
  return user?.id || user?.cashierId;
}

// Middleware to check if user is a cashier
function requireCashier(req: Request, res: Response, next: NextFunction) {
  const user = req.user as any;
  if (!user || user.role !== 'cassiere') {
    return res.status(403).json({ message: "Accesso riservato ai Cassieri" });
  }
  next();
}

// ==================== CASHIER MANAGEMENT (Gestore Only) ====================

// GET /api/cashiers - List all cashiers for company
router.get("/api/cashiers", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    if (!user.companyId) {
      return res.status(400).json({ message: "Utente non associato a nessuna azienda" });
    }
    const cashiers = await db.select().from(siaeCashiers)
      .where(eq(siaeCashiers.companyId, user.companyId));
    
    const cashiersWithoutPassword = cashiers.map(({ passwordHash, ...rest }) => rest);
    res.json(cashiersWithoutPassword);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// POST /api/cashiers - Create cashier with username/password
router.post("/api/cashiers", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    if (!user.companyId) {
      return res.status(400).json({ message: "Utente non associato a nessuna azienda" });
    }
    
    const { username, password, name, defaultPrinterAgentId } = req.body;
    
    if (!username || !password || !name) {
      return res.status(400).json({ message: "Username, password e nome sono obbligatori" });
    }
    
    const existing = await db.select().from(siaeCashiers)
      .where(and(
        eq(siaeCashiers.companyId, user.companyId),
        eq(siaeCashiers.username, username)
      ));
    
    if (existing.length > 0) {
      return res.status(400).json({ message: "Username già in uso" });
    }
    
    const passwordHash = await bcrypt.hash(password, 10);
    
    // Normalize "none" sentinel value to null for printer
    const normalizedPrinterId = defaultPrinterAgentId && defaultPrinterAgentId !== "none" 
      ? defaultPrinterAgentId 
      : null;
    
    const [cashier] = await db.insert(siaeCashiers).values({
      companyId: user.companyId,
      username,
      passwordHash,
      name,
      defaultPrinterAgentId: normalizedPrinterId,
      isActive: true,
    }).returning();
    
    await siaeStorage.createAuditLog({
      companyId: user.companyId,
      userId: user.id,
      action: 'cashier_created',
      entityType: 'siae_cashier',
      entityId: cashier.id,
      description: `Creato cassiere: ${name} (${username})`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    const { passwordHash: _, ...cashierData } = cashier;
    res.status(201).json(cashierData);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// PATCH /api/cashiers/:id - Update cashier
router.patch("/api/cashiers/:id", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { id } = req.params;
    
    const [cashier] = await db.select().from(siaeCashiers).where(eq(siaeCashiers.id, id));
    if (!cashier) {
      return res.status(404).json({ message: "Cassiere non trovato" });
    }
    
    if (cashier.companyId !== user.companyId && user.role !== 'super_admin') {
      return res.status(403).json({ message: "Non autorizzato a modificare questo cassiere" });
    }
    
    const { name, username, defaultPrinterAgentId, isActive, password } = req.body;
    
    const updateData: any = { updatedAt: new Date() };
    if (name !== undefined) updateData.name = name;
    if (username !== undefined) updateData.username = username;
    // Normalize "none" sentinel value to null for printer
    if (defaultPrinterAgentId !== undefined) {
      updateData.defaultPrinterAgentId = defaultPrinterAgentId && defaultPrinterAgentId !== "none" 
        ? defaultPrinterAgentId 
        : null;
    }
    if (isActive !== undefined) updateData.isActive = isActive;
    
    if (password) {
      updateData.passwordHash = await bcrypt.hash(password, 10);
    }
    
    const [updated] = await db.update(siaeCashiers)
      .set(updateData)
      .where(eq(siaeCashiers.id, id))
      .returning();
    
    // Use cashier's companyId for audit log (more reliable than user's for super_admin)
    await siaeStorage.createAuditLog({
      companyId: cashier.companyId,
      userId: user.id,
      action: 'cashier_updated',
      entityType: 'siae_cashier',
      entityId: id,
      description: `Modificato cassiere: ${cashier.name}`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    if (updated) {
      const { passwordHash: _, ...cashierData } = updated;
      res.json(cashierData);
    } else {
      res.status(500).json({ message: "Errore durante l'aggiornamento" });
    }
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// DELETE /api/cashiers/:id - Deactivate cashier
router.delete("/api/cashiers/:id", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { id } = req.params;
    
    const [cashier] = await db.select().from(siaeCashiers).where(eq(siaeCashiers.id, id));
    if (!cashier) {
      return res.status(404).json({ message: "Cassiere non trovato" });
    }
    
    if (cashier.companyId !== user.companyId && user.role !== 'super_admin') {
      return res.status(403).json({ message: "Non autorizzato a disattivare questo cassiere" });
    }
    
    await db.update(siaeCashiers)
      .set({ isActive: false, updatedAt: new Date() })
      .where(eq(siaeCashiers.id, id));
    
    // Use cashier's companyId for audit log (more reliable than user's for super_admin)
    await siaeStorage.createAuditLog({
      companyId: cashier.companyId,
      userId: user.id,
      action: 'cashier_deactivated',
      entityType: 'siae_cashier',
      entityId: id,
      description: `Disattivato cassiere: ${cashier.name}`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    res.json({ success: true, message: "Cassiere disattivato" });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// POST /api/cashiers/login - Cashier login with username/password
router.post("/api/cashiers/login", async (req: Request, res: Response) => {
  try {
    const { username, password } = req.body;
    
    if (!username || !password) {
      return res.status(400).json({ message: "Username e password sono obbligatori" });
    }
    
    // Search for cashier by username only (global search)
    const [cashier] = await db.select().from(siaeCashiers)
      .where(eq(siaeCashiers.username, username));
    
    if (!cashier) {
      return res.status(401).json({ message: "Credenziali non valide" });
    }
    
    if (!cashier.isActive) {
      return res.status(403).json({ message: "Account disattivato" });
    }
    
    const isValidPassword = await bcrypt.compare(password, cashier.passwordHash);
    if (!isValidPassword) {
      return res.status(401).json({ message: "Credenziali non valide" });
    }
    
    // Create session for cashier
    // id = cashier.id per garantire che req.user.id corrisponda a siaeCashiers.id
    (req as any).login({ 
      id: cashier.id,
      claims: { sub: cashier.id, username: cashier.username },
      role: 'cassiere',
      companyId: cashier.companyId,
      cashierId: cashier.id,
      cashierType: 'siae'
    }, (err: any) => {
      if (err) {
        console.error("Cashier session creation error:", err);
        return res.status(500).json({ message: "Login failed" });
      }
      
      const { passwordHash: _, ...cashierData } = cashier;
      res.json({ 
        message: "Login successful",
        cashier: cashierData
      });
    });
  } catch (error: any) {
    console.error("Cashier login error:", error);
    res.status(500).json({ message: error.message });
  }
});

// ==================== EVENT CASHIER ALLOCATIONS (Gestore Only) ====================

// GET /api/events/:eventId/cashier-allocations - List all allocations for event
router.get("/api/events/:eventId/cashier-allocations", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { eventId } = req.params;
    
    const event = await siaeStorage.getSiaeTicketedEvent(eventId);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    if (event.companyId !== user.companyId && user.role !== 'super_admin') {
      return res.status(403).json({ message: "Non autorizzato ad accedere a questo evento" });
    }
    
    const allocations = await siaeStorage.getCashierAllocationsByEvent(eventId);
    
    // Enrich with cashier info from siaeCashiers table
    const enrichedAllocations = await Promise.all(allocations.map(async (alloc) => {
      const [cashier] = await db.select().from(siaeCashiers)
        .where(eq(siaeCashiers.id, alloc.cashierId));
      const sector = alloc.sectorId ? await siaeStorage.getSiaeEventSector(alloc.sectorId) : null;
      return {
        ...alloc,
        cashierName: cashier?.name || 'N/A',
        cashierUsername: cashier?.username || 'N/A',
        sectorName: sector?.name || 'Tutti i settori',
        quotaRemaining: alloc.quotaQuantity - alloc.quotaUsed
      };
    }));
    
    res.json(enrichedAllocations);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// POST /api/events/:eventId/cashier-allocations - Assign cashier to event
router.post("/api/events/:eventId/cashier-allocations", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { eventId } = req.params;
    // Accept both cashierId (new) and userId (legacy) for backwards compatibility
    const cashierId = req.body.cashierId || req.body.userId;
    const { sectorId, quotaQuantity } = req.body;
    
    if (!cashierId || quotaQuantity === undefined) {
      return res.status(400).json({ message: "cashierId e quotaQuantity sono obbligatori" });
    }
    
    const event = await siaeStorage.getSiaeTicketedEvent(eventId);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    if (event.companyId !== user.companyId && user.role !== 'super_admin') {
      return res.status(403).json({ message: "Non autorizzato ad accedere a questo evento" });
    }
    
    // Check if cashier exists and belongs to company (from siaeCashiers table)
    const [cashier] = await db.select().from(siaeCashiers)
      .where(and(
        eq(siaeCashiers.id, cashierId),
        eq(siaeCashiers.isActive, true)
      ));
    
    if (!cashier) {
      return res.status(400).json({ message: "Cassiere non trovato" });
    }
    
    if (cashier.companyId !== user.companyId && user.role !== 'super_admin') {
      return res.status(403).json({ message: "Cassiere non appartiene alla tua azienda" });
    }
    
    // Check if allocation already exists
    const existingAllocation = await siaeStorage.getCashierAllocationByCashierAndEvent(cashierId, eventId);
    if (existingAllocation) {
      return res.status(400).json({ message: "Allocazione già esistente per questo cassiere/evento" });
    }
    
    const allocation = await siaeStorage.createCashierAllocation({
      companyId: user.companyId,
      eventId,
      cashierId,
      sectorId: sectorId || null,
      quotaQuantity: parseInt(quotaQuantity),
      quotaUsed: 0,
      isActive: true
    });
    
    // Audit log
    await siaeStorage.createAuditLog({
      companyId: user.companyId,
      userId: user.id,
      action: 'cashier_allocation_created',
      entityType: 'cashier_allocation',
      entityId: allocation.id,
      description: `Assegnato cassiere ${cashier.name} a evento ${event.eventName} con quota ${quotaQuantity}`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    res.status(201).json(allocation);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// PATCH /api/cashier-allocations/:id - Update quota
router.patch("/api/cashier-allocations/:id", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { id } = req.params;
    const { quotaQuantity, isActive } = req.body;
    
    const allocation = await siaeStorage.getCashierAllocation(id);
    if (!allocation) {
      return res.status(404).json({ message: "Allocazione non trovata" });
    }
    
    if (allocation.companyId !== user.companyId && user.role !== 'super_admin') {
      return res.status(403).json({ message: "Non autorizzato a modificare questa allocazione" });
    }
    
    const updateData: any = {};
    if (quotaQuantity !== undefined) {
      if (parseInt(quotaQuantity) < allocation.quotaUsed) {
        return res.status(400).json({ 
          message: `La quota non può essere inferiore ai biglietti già emessi (${allocation.quotaUsed})` 
        });
      }
      updateData.quotaQuantity = parseInt(quotaQuantity);
    }
    if (isActive !== undefined) updateData.isActive = isActive;
    
    const updated = await siaeStorage.updateCashierAllocation(id, updateData);
    
    // Audit log
    await siaeStorage.createAuditLog({
      companyId: user.companyId,
      userId: user.id,
      action: 'cashier_allocation_updated',
      entityType: 'cashier_allocation',
      entityId: id,
      description: `Modificata allocazione cassiere: quota ${quotaQuantity || 'invariata'}`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    res.json(updated);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// DELETE /api/cashier-allocations/:id - Remove allocation
router.delete("/api/cashier-allocations/:id", requireAuth, requireGestore, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { id } = req.params;
    
    const allocation = await siaeStorage.getCashierAllocation(id);
    if (!allocation) {
      return res.status(404).json({ message: "Allocazione non trovata" });
    }
    
    if (allocation.companyId !== user.companyId && user.role !== 'super_admin') {
      return res.status(403).json({ message: "Non autorizzato a eliminare questa allocazione" });
    }
    
    if (allocation.quotaUsed > 0) {
      return res.status(400).json({ 
        message: `Impossibile eliminare allocazione con biglietti già emessi (${allocation.quotaUsed}). Disattivarla invece.` 
      });
    }
    
    await siaeStorage.deleteCashierAllocation(id);
    
    // Audit log
    await siaeStorage.createAuditLog({
      companyId: user.companyId,
      userId: user.id,
      action: 'cashier_allocation_deleted',
      entityType: 'cashier_allocation',
      entityId: id,
      description: `Eliminata allocazione cassiere`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    res.json({ success: true, message: "Allocazione eliminata" });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// ==================== CASHIER OPERATIONS (Cassiere Role) ====================

// GET /api/cashier/dashboard - Get cashier dashboard data with real stats
router.get("/api/cashier/dashboard", requireAuth, requireCashier, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    
    const cashierId = getSiaeCashierId(user);
    if (!cashierId) {
      return res.status(400).json({ message: "ID cassiere non trovato nella sessione" });
    }
    
    // Get all allocations for this cashier
    const allocations = await siaeStorage.getCashierAllocationsByCashier(cashierId);
    
    // Find current/active event (in progress or scheduled for today)
    let currentEvent = null;
    let currentAllocation = null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    for (const alloc of allocations) {
      if (!alloc.isActive) continue;
      const event = await siaeStorage.getSiaeTicketedEvent(alloc.eventId);
      if (!event) continue;
      
      const eventDate = event.eventDate ? new Date(event.eventDate) : null;
      if (eventDate) {
        eventDate.setHours(0, 0, 0, 0);
      }
      
      // Check if event is today or ongoing
      if (eventDate && eventDate.getTime() === today.getTime()) {
        currentEvent = event;
        currentAllocation = alloc;
        break;
      }
      if (event.status === 'ongoing' || event.status === 'active') {
        currentEvent = event;
        currentAllocation = alloc;
        break;
      }
    }
    
    // Get today's tickets for all events assigned to this cashier
    let allTodayTickets: any[] = [];
    for (const alloc of allocations) {
      const tickets = await siaeStorage.getTodayTicketsByUser(cashierId, alloc.eventId);
      allTodayTickets = allTodayTickets.concat(tickets);
    }
    
    // Filter only active tickets (not cancelled - includes annullato_rivendita, etc.)
    const activeTickets = allTodayTickets.filter(t => !isCancelledStatus(t.status));
    
    // Calculate stats
    const totalRevenue = activeTickets.reduce((sum, t) => sum + Number(t.ticketPrice || 0), 0);
    const ticketsSold = activeTickets.length;
    const cashTickets = activeTickets.filter(t => t.paymentMethod === 'cash' || t.paymentMethod === 'contanti');
    const cardTickets = activeTickets.filter(t => t.paymentMethod === 'card' || t.paymentMethod === 'carta' || t.paymentMethod === 'pos');
    const cashRevenue = cashTickets.reduce((sum, t) => sum + Number(t.ticketPrice || 0), 0);
    const cardRevenue = cardTickets.reduce((sum, t) => sum + Number(t.ticketPrice || 0), 0);
    
    // Recent transactions (last 10 tickets)
    const sortedTickets = allTodayTickets.sort((a, b) => 
      new Date(b.emissionDate || 0).getTime() - new Date(a.emissionDate || 0).getTime()
    );
    const recentTransactions = sortedTickets.slice(0, 10).map(ticket => ({
      id: ticket.id,
      type: 'ticket' as const,
      title: `${ticket.ticketType === 'omaggio' ? 'Omaggio' : ticket.ticketType === 'ridotto' ? 'Ridotto' : 'Intero'} - ${ticket.participantFirstName || ''} ${ticket.participantLastName || ''}`.trim() || `Biglietto ${ticket.ticketCode || ''}`,
      amount: Number(ticket.ticketPrice || 0),
      time: ticket.emissionDate ? new Date(ticket.emissionDate).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' }) : '',
      ticketType: ticket.ticketType,
    }));
    
    res.json({
      stats: {
        totalRevenue,
        ticketsSold,
        transactionsCount: ticketsSold,
        cashRevenue,
        cardRevenue,
      },
      currentEvent: currentEvent ? {
        id: currentEvent.id,
        name: currentEvent.eventName,
        date: currentEvent.eventDate ? new Date(currentEvent.eventDate).toLocaleDateString('it-IT') : '',
        startTime: currentEvent.eventTime || '',
        endTime: '',
        status: currentEvent.status === 'ongoing' ? 'in_progress' : currentEvent.status === 'scheduled' ? 'scheduled' : 'ended',
      } : null,
      recentTransactions,
    });
  } catch (error: any) {
    console.error('[CashierDashboard] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET /api/cashier/my-events - Get events assigned to logged-in cashier
router.get("/api/cashier/my-events", requireAuth, requireCashier, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    
    // Usa helper per supportare sia nuove che vecchie sessioni cassiere
    const cashierId = getSiaeCashierId(user);
    if (!cashierId) {
      return res.status(400).json({ message: "ID cassiere non trovato nella sessione" });
    }
    const allocations = await siaeStorage.getCashierAllocationsByCashier(cashierId);
    
    const events = await Promise.all(allocations.map(async (alloc) => {
      const event = await siaeStorage.getSiaeTicketedEvent(alloc.eventId);
      const sector = alloc.sectorId ? await siaeStorage.getSiaeEventSector(alloc.sectorId) : null;
      return {
        allocationId: alloc.id,
        eventId: alloc.eventId,
        eventName: event?.eventName || 'N/A',
        eventDate: event?.eventDate,
        eventTime: event?.eventTime,
        venueName: event?.venueName,
        sectorId: alloc.sectorId,
        sectorName: sector?.name || 'Tutti i settori',
        quotaQuantity: alloc.quotaQuantity,
        quotaUsed: alloc.quotaUsed,
        quotaRemaining: alloc.quotaQuantity - alloc.quotaUsed,
        isActive: alloc.isActive
      };
    }));
    
    // Filter only active allocations with active events
    const activeEvents = events.filter(e => e.isActive && e.eventName !== 'N/A');
    
    res.json(activeEvents);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// GET /api/cashier/events/:eventId/quotas - Get remaining quotas for event
router.get("/api/cashier/events/:eventId/quotas", requireAuth, requireCashier, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { eventId } = req.params;
    
    // Usa helper per supportare sia nuove che vecchie sessioni cassiere
    const cashierId = getSiaeCashierId(user);
    if (!cashierId) {
      return res.status(400).json({ message: "ID cassiere non trovato nella sessione" });
    }
    const allocation = await siaeStorage.getCashierAllocationByCashierAndEvent(cashierId, eventId);
    if (!allocation) {
      return res.status(404).json({ message: "Non hai allocazione per questo evento" });
    }
    
    const event = await siaeStorage.getSiaeTicketedEvent(eventId);
    const sectors = await siaeStorage.getSiaeEventSectors(eventId);
    const sector = allocation.sectorId ? await siaeStorage.getSiaeEventSector(allocation.sectorId) : null;
    
    // Get today's tickets by this cashier (issuedByUserId = cashier.id for SIAE cashiers)
    const todayTickets = await siaeStorage.getTodayTicketsByUser(cashierId, eventId);
    
    res.json({
      eventId,
      eventName: event?.eventName,
      eventDate: event?.eventDate,
      sectorId: allocation.sectorId,
      sectorName: sector?.name || 'Tutti i settori',
      quotaQuantity: allocation.quotaQuantity,
      quotaUsed: allocation.quotaUsed,
      quotaRemaining: allocation.quotaQuantity - allocation.quotaUsed,
      todayEmissions: todayTickets.length,
      todayRevenue: todayTickets.reduce((sum, t) => sum + Number(t.ticketPrice || 0), 0),
      availableSectors: sectors.map(s => ({
        id: s.id,
        name: s.name,
        availableSeats: s.availableSeats,
        ticketPrice: s.priceIntero
      }))
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// POST /api/cashier/events/:eventId/emit-ticket - Emit ticket with fiscal seal
router.post("/api/cashier/events/:eventId/emit-ticket", requireAuth, requireCashier, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { eventId } = req.params;
    const { sectorId, ticketType, ticketPrice, participantFirstName, participantLastName, paymentMethod, isComplimentary, customText } = req.body;
    
    if (!sectorId || !ticketType || ticketPrice === undefined) {
      return res.status(400).json({ message: "sectorId, ticketType e ticketPrice sono obbligatori" });
    }
    
    // Usa helper per supportare sia nuove che vecchie sessioni cassiere
    const cashierId = getSiaeCashierId(user);
    if (!cashierId) {
      return res.status(400).json({ message: "ID cassiere non trovato nella sessione" });
    }
    const allocation = await siaeStorage.getCashierAllocationByCashierAndEvent(cashierId, eventId);
    if (!allocation) {
      return res.status(403).json({ message: "Non hai allocazione per questo evento" });
    }
    
    if (!allocation.isActive) {
      return res.status(403).json({ message: "La tua allocazione per questo evento è stata disattivata" });
    }
    
    // Check sector restriction
    if (allocation.sectorId && allocation.sectorId !== sectorId) {
      return res.status(403).json({ message: "Non sei autorizzato a emettere biglietti per questo settore" });
    }
    
    // Check quota
    if (allocation.quotaUsed >= allocation.quotaQuantity) {
      return res.status(403).json({ 
        message: "Quota biglietti esaurita",
        errorCode: "QUOTA_EXCEEDED",
        quotaUsed: allocation.quotaUsed,
        quotaQuantity: allocation.quotaQuantity
      });
    }
    
    const event = await siaeStorage.getSiaeTicketedEvent(eventId);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    const sector = await siaeStorage.getSiaeEventSector(sectorId);
    if (!sector) {
      return res.status(404).json({ message: "Settore non trovato" });
    }
    
    // Check seat availability
    if (sector.availableSeats !== null && sector.availableSeats <= 0) {
      return res.status(400).json({ message: "Nessun posto disponibile in questo settore" });
    }
    
    // Generate ticket code
    const ticketCode = `${event.eventCode || 'TKT'}-${Date.now().toString(36).toUpperCase()}`;
    
    // Try to get fiscal seal from bridge (optional - box office can work offline)
    let fiscalSeal = null;
    let fiscalSealCode = null;
    
    try {
      if (isBridgeConnected() && isCardReadyForSeals().ready) {
        const priceInCents = Math.round(Number(ticketPrice) * 100);
        const sealData = await requestFiscalSeal(priceInCents);
        fiscalSeal = sealData;
        fiscalSealCode = sealData?.sealCode;
      }
    } catch (sealError: any) {
      console.log(`[Cashier] Fiscal seal not available: ${sealError.message}`);
      // Continue without fiscal seal - will be registered later
    }
    
    // Atomic ticket emission with quota management
    const result = await siaeStorage.emitTicketWithAtomicQuota({
      allocationId: allocation.id,
      eventId,
      sectorId,
      sectorCode: (sector.sectorCode || 'XX').slice(0, 2),
      ticketCode,
      ticketType,
      ticketTypeCode: ticketType.substring(0, 2).toUpperCase(),
      ticketPrice: Number(ticketPrice),
      customerId: null,
      issuedByUserId: cashierId,
      participantFirstName: participantFirstName || null,
      participantLastName: participantLastName || null,
      isComplimentary: isComplimentary || false,
      paymentMethod: paymentMethod || 'cash',
      customText: customText || null,
      currentTicketsSold: event.ticketsSold || 0,
      currentTotalRevenue: Number(event.totalRevenue || 0),
      currentAvailableSeats: sector.availableSeats || 0
    });
    
    if (!result.success) {
      return res.status(400).json({ 
        message: result.error || "Errore durante l'emissione del biglietto",
        errorCode: "EMISSION_FAILED"
      });
    }
    
    // Update ticket with fiscal seal data if available
    if (fiscalSeal && result.ticket) {
      await siaeStorage.updateSiaeTicket(result.ticket.id, {
        fiscalSealCode: fiscalSeal.sealCode,
        fiscalSealCounter: fiscalSeal.counter,
        cardCode: fiscalSeal.serialNumber,
      });
    }
    
    // Create ticket audit
    await siaeStorage.createTicketAudit({
      companyId: user.companyId,
      ticketId: result.ticket!.id,
      operationType: 'emission',
      performedBy: cashierId,
      reason: null,
      metadata: {
        ticketCode,
        ticketType,
        ticketPrice,
        sectorName: sector.name,
        eventName: event.eventName,
        fiscalSealCode,
        paymentMethod: paymentMethod || 'cash',
        emittedBy: user.username || user.claims?.username || 'Cassiere'
      }
    });
    
    // Audit log
    await siaeStorage.createAuditLog({
      companyId: user.companyId,
      userId: cashierId,
      action: 'ticket_emitted',
      entityType: 'ticket',
      entityId: result.ticket!.id,
      description: `Emesso biglietto ${ticketCode} - ${ticketType} - €${ticketPrice}`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    res.status(201).json({
      ...result.ticket,
      fiscalSealCode,
      sectorName: sector.name,
      eventName: event.eventName,
      quotaRemaining: allocation.quotaQuantity - allocation.quotaUsed - 1
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// POST /api/cashier/tickets/:ticketId/annul - Annul ticket (SIAE fiscal annulment)
router.post("/api/cashier/tickets/:ticketId/annul", requireAuth, requireCashier, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { ticketId } = req.params;
    const { reason } = req.body;
    
    if (!reason) {
      return res.status(400).json({ message: "Motivo annullamento obbligatorio" });
    }
    
    const ticket = await siaeStorage.getSiaeTicket(ticketId);
    if (!ticket) {
      return res.status(404).json({ message: "Biglietto non trovato" });
    }
    
    if (ticket.status === 'cancelled') {
      return res.status(400).json({ message: "Biglietto già annullato" });
    }
    
    if (ticket.status === 'used') {
      return res.status(400).json({ message: "Impossibile annullare un biglietto già utilizzato" });
    }
    
    // Usa helper per supportare sia nuove che vecchie sessioni cassiere
    const cashierId = getSiaeCashierId(user);
    if (!cashierId) {
      return res.status(400).json({ message: "ID cassiere non trovato nella sessione" });
    }
    const allocation = await siaeStorage.getCashierAllocationByCashierAndEvent(cashierId, ticket.ticketedEventId);
    if (!allocation) {
      return res.status(403).json({ message: "Non hai allocazione per questo evento" });
    }
    
    // Verify ticket was issued by this cashier (for security)
    if (ticket.issuedByUserId !== cashierId) {
      // Allow annulment if cashier has same sector or all-sector allocation
      if (allocation.sectorId && allocation.sectorId !== ticket.sectorId) {
        return res.status(403).json({ message: "Non sei autorizzato ad annullare questo biglietto" });
      }
    }
    
    // Atomic cancellation with quota restore
    const result = await siaeStorage.cancelTicketWithAtomicQuotaRestore({
      ticketId,
      cancelledByUserId: cashierId,
      cancellationReason: reason,
      issuedByUserId: ticket.issuedByUserId,
      ticketedEventId: ticket.ticketedEventId,
      sectorId: ticket.sectorId,
      ticketPrice: Number(ticket.ticketPrice || 0)
    });
    
    if (!result.success) {
      return res.status(400).json({ 
        message: result.error || "Errore durante l'annullamento",
        errorCode: "ANNULMENT_FAILED"
      });
    }
    
    // Create ticket audit
    await siaeStorage.createTicketAudit({
      companyId: user.companyId,
      ticketId,
      operationType: 'cancellation',
      performedBy: cashierId,
      reason,
      metadata: {
        ticketCode: ticket.ticketCode,
        originalPrice: ticket.ticketPrice,
        cancelledBy: user.username || user.claims?.username || 'Cassiere'
      }
    });
    
    // Audit log
    await siaeStorage.createAuditLog({
      companyId: user.companyId,
      userId: cashierId,
      action: 'ticket_annulled_by_cashier',
      entityType: 'ticket',
      entityId: ticketId,
      description: `Annullato biglietto ${ticket.ticketCode} - Motivo: ${reason}`,
      ipAddress: (req.ip || '').substring(0, 45),
      userAgent: (req.get('user-agent') || '').substring(0, 500)
    });
    
    // Get updated quota
    const updatedAllocation = await siaeStorage.getCashierAllocation(allocation.id);
    
    res.json({
      ...result.ticket,
      quotaRemaining: updatedAllocation ? updatedAllocation.quotaQuantity - updatedAllocation.quotaUsed : null
    });
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// GET /api/cashier/events/:eventId/c1-report - Generate C1 report for cashier session
router.get("/api/cashier/events/:eventId/c1-report", requireAuth, requireCashier, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { eventId } = req.params;
    
    // Usa helper per supportare sia nuove che vecchie sessioni cassiere
    const cashierId = getSiaeCashierId(user);
    if (!cashierId) {
      return res.status(400).json({ message: "ID cassiere non trovato nella sessione" });
    }
    const allocation = await siaeStorage.getCashierAllocationByCashierAndEvent(cashierId, eventId);
    if (!allocation) {
      return res.status(404).json({ message: "Non hai allocazione per questo evento" });
    }
    
    const event = await siaeStorage.getSiaeTicketedEvent(eventId);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    // Get today's tickets by this cashier for this event
    const todayTickets = await siaeStorage.getTodayTicketsByUser(cashierId, eventId);
    
    // Aggregate by ticket type
    const byType = new Map<string, { count: number; amount: number }>();
    for (const ticket of todayTickets) {
      const type = ticket.ticketType || 'intero';
      const current = byType.get(type) || { count: 0, amount: 0 };
      current.count++;
      current.amount += Number(ticket.ticketPrice || 0);
      byType.set(type, current);
    }
    
    const activeTickets = todayTickets.filter(t => !isCancelledStatus(t.status));
    const cancelledTickets = todayTickets.filter(t => isCancelledStatus(t.status));
    
    const totalRevenue = activeTickets.reduce((sum, t) => sum + Number(t.ticketPrice || 0), 0);
    
    const report = {
      eventId,
      eventName: event.eventName,
      eventDate: event.eventDate,
      cashierName: `${user.firstName} ${user.lastName}`,
      cashierEmail: user.email,
      reportDate: new Date(),
      allocation: {
        quotaQuantity: allocation.quotaQuantity,
        quotaUsed: allocation.quotaUsed,
        quotaRemaining: allocation.quotaQuantity - allocation.quotaUsed
      },
      session: {
        totalEmitted: todayTickets.length,
        activeTickets: activeTickets.length,
        cancelledTickets: cancelledTickets.length,
        totalRevenue,
        byTicketType: Object.fromEntries(byType),
        paymentBreakdown: {
          cash: activeTickets.filter(t => t.paymentMethod === 'cash').reduce((sum, t) => sum + Number(t.ticketPrice || 0), 0),
          card: activeTickets.filter(t => t.paymentMethod === 'card').reduce((sum, t) => sum + Number(t.ticketPrice || 0), 0),
          other: activeTickets.filter(t => !['cash', 'card'].includes(t.paymentMethod || '')).reduce((sum, t) => sum + Number(t.ticketPrice || 0), 0)
        }
      },
      tickets: todayTickets.map(t => ({
        id: t.id,
        ticketCode: t.ticketCode,
        ticketType: t.ticketType,
        ticketPrice: t.ticketPrice,
        status: t.status,
        emissionDate: t.emissionDate,
        fiscalSealCode: t.fiscalSealCode,
        paymentMethod: t.paymentMethod
      }))
    };
    
    res.json(report);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
});

// GET /api/siae/events/:eventId/report-c1 - Generate C1 fiscal report
// Accessible by gestore, organizer, admin, super_admin, and cassiere (only for allocated events)
router.get("/api/siae/events/:eventId/report-c1", requireAuth, async (req: Request, res: Response) => {
  try {
    const user = req.user as any;
    const { eventId } = req.params;
    
    const event = await siaeStorage.getSiaeTicketedEvent(eventId);
    if (!event) {
      return res.status(404).json({ message: "Evento non trovato" });
    }
    
    // Check authorization based on role
    const isGestoreOrHigher = ['gestore', 'organizer', 'admin', 'super_admin'].includes(user.role);
    const isCashier = user.role === 'cassiere';
    
    if (!isGestoreOrHigher && !isCashier) {
      return res.status(403).json({ message: "Non autorizzato ad accedere a questo report" });
    }
    
    // For cashiers, verify they are allocated to this event
    if (isCashier) {
      const cashierId = getSiaeCashierId(user);
      if (!cashierId) {
        return res.status(403).json({ message: "Impossibile identificare il cassiere" });
      }
      
      // Check if cashier is allocated to this event
      const allocations = await db.select()
        .from(siaeCashierAllocations)
        .where(and(
          eq(siaeCashierAllocations.eventId, eventId),
          eq(siaeCashierAllocations.cashierId, cashierId),
          eq(siaeCashierAllocations.isActive, true)
        ));
      
      if (allocations.length === 0) {
        return res.status(403).json({ 
          message: "Non sei allocato a questo evento. Puoi accedere solo ai report degli eventi a cui sei stato assegnato.",
          errorCode: "NOT_ALLOCATED_TO_EVENT"
        });
      }
    }
    
    // For gestore/organizer/admin, verify company access (super_admin can access all)
    if (isGestoreOrHigher && user.role !== 'super_admin' && event.companyId !== user.companyId) {
      return res.status(403).json({ message: "Non autorizzato ad accedere a questo evento" });
    }
    
    // Get all tickets for event
    const tickets = await siaeStorage.getSiaeTicketsByEvent(eventId);
    const sectors = await siaeStorage.getSiaeEventSectors(eventId);
    
    // Aggregate by sector and ticket type
    const sectorStats = new Map<string, {
      sectorName: string;
      sectorCode: string;
      interoCount: number;
      interoAmount: number;
      ridottoCount: number;
      ridottoAmount: number;
      omaggioCount: number;
      cancelledCount: number;
    }>();
    
    for (const sector of sectors) {
      sectorStats.set(sector.id, {
        sectorName: sector.name,
        sectorCode: sector.sectorCode || '',
        interoCount: 0,
        interoAmount: 0,
        ridottoCount: 0,
        ridottoAmount: 0,
        omaggioCount: 0,
        cancelledCount: 0
      });
    }
    
    for (const ticket of tickets) {
      const stats = sectorStats.get(ticket.sectorId);
      if (!stats) continue;
      
      if (ticket.status === 'cancelled') {
        stats.cancelledCount++;
        continue;
      }
      
      const price = Number(ticket.ticketPrice) || Number(ticket.grossAmount) || 0;
      
      // Usa ticketType se disponibile, altrimenti deriva da ticketTypeCode
      let effectiveTicketType = ticket.ticketType;
      if (!effectiveTicketType && ticket.ticketTypeCode) {
        switch (ticket.ticketTypeCode) {
          case 'INT':
            effectiveTicketType = 'intero';
            break;
          case 'RID':
            effectiveTicketType = 'ridotto';
            break;
          case 'OMG':
            effectiveTicketType = 'omaggio';
            break;
          default:
            effectiveTicketType = 'intero'; // Default fallback
        }
      }
      
      switch (effectiveTicketType) {
        case 'intero':
          stats.interoCount++;
          stats.interoAmount += price;
          break;
        case 'ridotto':
          stats.ridottoCount++;
          stats.ridottoAmount += price;
          break;
        case 'omaggio':
          stats.omaggioCount++;
          break;
        default:
          // Fallback: conta come intero se non riconosciuto
          stats.interoCount++;
          stats.interoAmount += price;
      }
    }
    
    const activeTickets = tickets.filter(t => !isCancelledStatus(t.status));
    const totalRevenue = activeTickets.reduce((sum, t) => sum + (Number(t.ticketPrice) || Number(t.grossAmount) || 0), 0);
    const vatRate = event.vatRate || 10;
    const vatAmount = totalRevenue * vatRate / (100 + vatRate);
    const netRevenue = totalRevenue - vatAmount;
    
    const report = {
      eventId: event.id,
      eventName: event.eventName,
      eventCode: event.eventCode,
      eventDate: event.eventDate,
      eventTime: event.eventTime,
      venueName: event.venueName,
      venueCapacity: event.venueCapacity,
      generatedAt: new Date(),
      generatedBy: user.fullName || user.username,
      summary: {
        totalTicketsSold: activeTickets.length,
        totalTicketsCancelled: tickets.filter(t => isCancelledStatus(t.status)).length,
        totalRevenue,
        vatRate,
        vatAmount,
        netRevenue
      },
      sectors: Array.from(sectorStats.values()),
      ticketTypes: {
        intero: {
          count: activeTickets.filter(t => {
            const tt = t.ticketType || (t.ticketTypeCode === 'INT' ? 'intero' : (t.ticketTypeCode === 'RID' ? 'ridotto' : (t.ticketTypeCode === 'OMG' ? 'omaggio' : 'intero')));
            return tt === 'intero';
          }).length,
          amount: activeTickets.filter(t => {
            const tt = t.ticketType || (t.ticketTypeCode === 'INT' ? 'intero' : (t.ticketTypeCode === 'RID' ? 'ridotto' : (t.ticketTypeCode === 'OMG' ? 'omaggio' : 'intero')));
            return tt === 'intero';
          }).reduce((s, t) => s + (Number(t.ticketPrice) || Number(t.grossAmount) || 0), 0)
        },
        ridotto: {
          count: activeTickets.filter(t => {
            const tt = t.ticketType || (t.ticketTypeCode === 'INT' ? 'intero' : (t.ticketTypeCode === 'RID' ? 'ridotto' : (t.ticketTypeCode === 'OMG' ? 'omaggio' : 'intero')));
            return tt === 'ridotto';
          }).length,
          amount: activeTickets.filter(t => {
            const tt = t.ticketType || (t.ticketTypeCode === 'INT' ? 'intero' : (t.ticketTypeCode === 'RID' ? 'ridotto' : (t.ticketTypeCode === 'OMG' ? 'omaggio' : 'intero')));
            return tt === 'ridotto';
          }).reduce((s, t) => s + (Number(t.ticketPrice) || Number(t.grossAmount) || 0), 0)
        },
        omaggio: {
          count: activeTickets.filter(t => {
            const tt = t.ticketType || (t.ticketTypeCode === 'INT' ? 'intero' : (t.ticketTypeCode === 'RID' ? 'ridotto' : (t.ticketTypeCode === 'OMG' ? 'omaggio' : 'intero')));
            return tt === 'omaggio';
          }).length,
          amount: 0
        }
      }
    };
    
    res.json(report);
  } catch (error: any) {
    console.error('[ReportC1] Error generating report:', error);
    res.status(500).json({ message: error.message || 'Errore nella generazione del report' });
  }
});

// POST /api/siae/tickets/:id/print - Print a ticket to thermal printer
// Requires: printer agent connected, ticket template configured for event
router.post("/api/siae/tickets/:id/print", requireAuth, async (req: Request, res: Response) => {
  console.log('[TicketPrint] Endpoint hit! ticketId:', req.params.id, 'user:', (req.user as any)?.role);
  try {
    const user = req.user as any;
    const { id: ticketId } = req.params;
    const { agentId, skipBackground = true } = req.body;
    
    console.log('[TicketPrint] Looking up ticket:', ticketId);
    
    // Get the ticket
    const ticket = await siaeStorage.getSiaeTicket(ticketId);
    if (!ticket) {
      console.log('[TicketPrint] Ticket NOT FOUND:', ticketId);
      return res.status(404).json({ message: "Biglietto non trovato" });
    }
    console.log('[TicketPrint] Ticket found, ticketedEventId:', ticket.ticketedEventId);
    
    // SIAE Compliance: Check if ticket has already been printed (no reprints allowed)
    // First, check if non-admin is trying to force reprint - reject immediately with 403
    if (req.body.forceReprint === true && user.role !== 'super_admin') {
      console.log('[TicketPrint] REPRINT OVERRIDE DENIED - user is not super_admin');
      return res.status(403).json({ 
        message: "Solo i Super Admin possono forzare la ristampa.",
        errorCode: "REPRINT_OVERRIDE_DENIED"
      });
    }
    
    // Then check if already printed (unless super_admin with forceReprint)
    const forceReprint = req.body.forceReprint === true && user.role === 'super_admin';
    if ((ticket as any).printedAt && !forceReprint) {
      console.log('[TicketPrint] REPRINT BLOCKED - ticket already printed at:', (ticket as any).printedAt);
      return res.status(409).json({ 
        message: "Biglietto già stampato. La ristampa non è consentita per conformità SIAE.",
        errorCode: "ALREADY_PRINTED",
        printedAt: (ticket as any).printedAt
      });
    }
    
    // Get event details
    const event = await siaeStorage.getSiaeTicketedEvent(ticket.ticketedEventId);
    if (!event) {
      console.log('[TicketPrint] Event NOT FOUND:', ticket.ticketedEventId);
      return res.status(404).json({ message: "Evento non trovato" });
    }
    console.log('[TicketPrint] Event found:', event.eventName);
    
    // Verify company access
    if (user.role !== 'super_admin' && event.companyId !== user.companyId) {
      return res.status(403).json({ message: "Non autorizzato" });
    }
    
    // Get sector
    const sector = ticket.sectorId ? await siaeStorage.getSiaeEventSector(ticket.sectorId) : null;
    
    // Get SIAE system config for ticketing_manager (businessName)
    const systemConfig = await siaeStorage.getSiaeSystemConfig(event.companyId);
    
    // Get list of currently connected agents for this company
    const connectedAgents = getConnectedAgents(event.companyId);
    const connectedAgentIds = new Set(connectedAgents.map(a => a.agentId));
    
    console.log('[TicketPrint] Connected agents:', connectedAgents.map(a => `${a.agentId} (${a.deviceName})`).join(', ') || 'NONE');
    
    // No agents connected at all
    if (connectedAgents.length === 0) {
      return res.status(503).json({ 
        message: "Nessun agente di stampa connesso. Avviare l'applicazione desktop Event4U.",
        errorCode: "NO_PRINT_AGENT"
      });
    }
    
    // Determine print agent ID with smart fallback
    let printerAgentId = agentId;
    let cashierId: string | null = null;
    
    // Get cashier info if applicable
    if (user.role === 'cassiere') {
      cashierId = getSiaeCashierId(user) || null;
    }
    
    // Verify the specified agent is actually connected
    if (printerAgentId && !connectedAgentIds.has(printerAgentId)) {
      console.log(`[TicketPrint] Specified agent ${printerAgentId} is not connected, will try fallback`);
      printerAgentId = null;
    }
    
    // If no valid agent specified, try cashier's default printer (if connected)
    if (!printerAgentId && cashierId) {
      const [cashier] = await db.select().from(siaeCashiers).where(eq(siaeCashiers.id, cashierId));
      if (cashier?.defaultPrinterAgentId && connectedAgentIds.has(cashier.defaultPrinterAgentId)) {
        printerAgentId = cashier.defaultPrinterAgentId;
        console.log(`[TicketPrint] Using cashier's default agent: ${printerAgentId}`);
      } else if (cashier?.defaultPrinterAgentId) {
        console.log(`[TicketPrint] Cashier's default agent ${cashier.defaultPrinterAgentId} is not connected`);
      }
    }
    
    // Smart fallback: if exactly one agent is connected, use it automatically
    if (!printerAgentId) {
      if (connectedAgents.length === 1) {
        printerAgentId = connectedAgents[0].agentId;
        console.log(`[TicketPrint] Only one agent connected, using: ${printerAgentId} (${connectedAgents[0].deviceName})`);
        
        // Auto-update cashier's default for future prints
        if (cashierId) {
          await db.update(siaeCashiers)
            .set({ defaultPrinterAgentId: printerAgentId })
            .where(eq(siaeCashiers.id, cashierId));
          console.log(`[TicketPrint] Auto-updated cashier's default printer to: ${printerAgentId}`);
        }
      } else {
        // Multiple agents connected but none specified - require explicit selection
        console.log(`[TicketPrint] Multiple agents connected but none specified. Agents:`, connectedAgents);
        return res.status(400).json({ 
          message: "Più agenti di stampa connessi. Selezionare un agente nelle impostazioni stampante.",
          errorCode: "MULTIPLE_AGENTS",
          connectedAgents: connectedAgents.map(a => ({ agentId: a.agentId, deviceName: a.deviceName }))
        });
      }
    }
    
    // Get event's ticket template
    const [template] = await db.select().from(ticketTemplates)
      .where(and(
        eq(ticketTemplates.companyId, event.companyId),
        eq(ticketTemplates.isActive, true)
      ))
      .limit(1);
    
    if (!template) {
      console.log('[TicketPrint] Template NOT FOUND for companyId:', event.companyId);
      return res.status(404).json({ 
        message: "Nessun template di stampa configurato per questa azienda",
        errorCode: "NO_TEMPLATE"
      });
    }
    console.log('[TicketPrint] Template found:', template.name);
    
    // Get template elements
    const elements = await db.select().from(ticketTemplateElements)
      .where(eq(ticketTemplateElements.templateId, template.id))
      .orderBy(ticketTemplateElements.zIndex);
    
    // Parse elements for HTML generation
    const parsedElements = elements.map(el => {
      let content = el.staticValue;
      if (el.fieldKey && !el.staticValue) {
        content = `{{${el.fieldKey}}}`;
      } else if (el.fieldKey && el.staticValue) {
        content = el.staticValue;
      }
      
      return {
        type: el.type,
        x: parseFloat(el.x as any),
        y: parseFloat(el.y as any),
        width: parseFloat(el.width as any),
        height: parseFloat(el.height as any),
        content,
        fontSize: el.fontSize,
        fontFamily: el.fontFamily,
        fontWeight: el.fontWeight,
        fontColor: el.color,
        textAlign: el.textAlign,
        rotation: el.rotation,
      };
    });
    
    // Map ticket type to Italian label
    const ticketTypeLabels: Record<string, string> = {
      'intero': 'Intero',
      'ridotto': 'Ridotto',
      'omaggio': 'Omaggio',
    };
    
    // Build ticket data for template
    const ticketData: Record<string, string> = {
      event_name: event.eventName || '',
      event_date: event.eventDate ? new Date(event.eventDate).toLocaleDateString('it-IT') : '',
      event_time: event.eventTime || '',
      venue_name: event.venueName || '',
      price: `€ ${Number(ticket.ticketPrice || 0).toFixed(2).replace('.', ',')}`,
      ticket_number: ticket.ticketCode || '',
      progressive_number: String(ticket.progressiveNumber || ''),
      ticket_type: ticketTypeLabels[ticket.ticketType || ''] || ticket.ticketType || '',
      sector: sector?.name || '',
      row: ticket.row || '',
      seat: ticket.seatNumber || '',
      buyer_name: ticket.participantFirstName && ticket.participantLastName 
        ? `${ticket.participantFirstName} ${ticket.participantLastName}` 
        : '',
      organizer_company: event.organizerName || event.companyName || '',
      ticketing_manager: (() => {
        if (!systemConfig) return event.companyName || '';
        const parts: string[] = [];
        if (systemConfig.businessName) parts.push(systemConfig.businessName);
        if (systemConfig.vatNumber) parts.push(`P.IVA ${systemConfig.vatNumber}`);
        if (systemConfig.businessAddress) {
          let address = systemConfig.businessAddress;
          if (systemConfig.businessPostalCode) address += ` - ${systemConfig.businessPostalCode}`;
          if (systemConfig.businessCity) address += ` ${systemConfig.businessCity}`;
          if (systemConfig.businessProvince) address += ` (${systemConfig.businessProvince})`;
          parts.push(address);
        }
        return parts.length > 0 ? parts.join(' - ') : event.companyName || '';
      })(),
      emission_datetime: ticket.emissionDate ? new Date(ticket.emissionDate).toLocaleString('it-IT') : '',
      fiscal_seal: ticket.fiscalSealCode || '',
      qr_code: `https://manage.eventfouryou.com/verify/${ticket.ticketCode}`,
      custom_text: ticket.customText || '',
    };
    
    // Generate HTML
    const ticketHtml = generateTicketHtml(
      {
        paperWidthMm: template.paperWidthMm,
        paperHeightMm: template.paperHeightMm,
        backgroundImageUrl: template.backgroundImageUrl,
        dpi: template.dpi || 203,
        printOrientation: (template as any).printOrientation || 'auto',
      },
      parsedElements,
      ticketData,
      skipBackground
    );
    
    // Determine orientation
    const naturalOrientation = template.paperWidthMm > template.paperHeightMm ? 'landscape' : 'portrait';
    const effectiveOrientation = (template as any).printOrientation === 'auto' || !(template as any).printOrientation
      ? naturalOrientation
      : (template as any).printOrientation;
    
    // Build print payload
    const printPayload = {
      id: `ticket-${ticketId}-${Date.now()}`,
      type: 'ticket',
      paperWidthMm: template.paperWidthMm,
      paperHeightMm: template.paperHeightMm,
      orientation: effectiveOrientation,
      html: ticketHtml,
      ticketId: ticketId,
    };
    
    // Send to print agent
    const sent = sendPrintJobToAgent(printerAgentId, printPayload);
    
    if (!sent) {
      return res.status(503).json({ 
        message: "Agente di stampa non raggiungibile",
        errorCode: "AGENT_UNREACHABLE"
      });
    }
    
    console.log(`[TicketPrint] Sent ticket ${ticketId} to print agent ${printerAgentId}`);
    
    // SIAE Compliance: Mark ticket as printed to prevent reprints (ISO string for consistency)
    await siaeStorage.updateSiaeTicket(ticketId, { 
      printedAt: new Date().toISOString() 
    } as any);
    console.log(`[TicketPrint] Marked ticket ${ticketId} as printed`);
    
    res.json({ success: true, message: "Stampa inviata", agentId: printerAgentId });
  } catch (error: any) {
    console.error('[TicketPrint] Error:', error);
    res.status(500).json({ message: error.message });
  }
});

console.log('[SIAE Routes] All routes registered including /api/siae/tickets/:id/print');

export default router;


================================================================================
FILE: server/siae-utils.ts
================================================================================
/**
 * SIAE Utilities - Funzioni condivise per la generazione di report SIAE
 * Conforme a Allegato B e C - Provvedimento Agenzia delle Entrate 04/03/2008
 */

// ==================== System Code Consistency Validation ====================

export interface SystemCodeValidationResult {
  valid: boolean;
  xmlSystemCode: string | null;
  filenameSystemCode: string;
  error?: string;
}

// ==================== SIAE Error Codes Table ====================

/**
 * Tabella completa degli errori SIAE
 * Basata su risposte reali da SIAE e Allegato B/C Provvedimento 04/03/2008
 * 
 * Severità:
 * - success: Operazione completata con successo
 * - warning: Operazione completata con anomalie
 * - error: Operazione fallita (bloccante)
 */
export const SIAE_ERROR_CODES = {
  '0000': { 
    severity: 'success', 
    description: 'Il riepilogo è stato elaborato correttamente' 
  },
  '0100': { 
    severity: 'warning', 
    description: 'Il riepilogo risulta già elaborato' 
  },
  '0600': { 
    severity: 'error', 
    description: 'Nome del file contenente il riepilogo sbagliato', 
    prevention: 'Verificare coerenza codice sistema tra XML e nome file' 
  },
  '0601': { 
    severity: 'error', 
    description: 'Oggetto del messaggio contenente il riepilogo sbagliato', 
    prevention: 'Verificare formato oggetto email' 
  },
  '0603': { 
    severity: 'error', 
    description: 'Le date dell\'oggetto, del nome file, e del contenuto del riepilogo non sono coerenti', 
    prevention: 'Verificare che DataGenerazione, data nel filename e data nell\'oggetto email coincidano' 
  },
  '2101': { 
    severity: 'error', 
    description: 'Tipo evento diverso da quelli previsti nella tabella 1 all.A provv. 23/7/2001', 
    prevention: 'Usare codice genere valido (01-99) dalla tabella SIAE' 
  },
  '2108': { 
    severity: 'error', 
    description: 'Autore non previsto per il Tipo Evento', 
    prevention: 'Rimuovere autore per eventi che non lo richiedono' 
  },
  '2110': { 
    severity: 'error', 
    description: 'Esecutore non indicato per il Tipo Evento', 
    prevention: 'Aggiungere esecutore per eventi che lo richiedono' 
  },
  '2111': { 
    severity: 'error', 
    description: 'Esecutore non previsto per il Tipo Evento', 
    prevention: 'Rimuovere esecutore per eventi che non lo richiedono' 
  },
  '2112': { 
    severity: 'error', 
    description: 'Nazionalità del Film non prevista nella codifica ISO 3166', 
    prevention: 'Usare codice ISO 3166 valido (IT, US, FR, etc.)' 
  },
  '2114': { 
    severity: 'error', 
    description: 'Nazionalità del Film non prevista per il Tipo Evento', 
    prevention: 'Rimuovere nazionalità film per eventi non cinematografici' 
  },
  '2606': { 
    severity: 'warning', 
    description: 'La denominazione del titolare è diversa da quella presente sulla smart-card associata al sistema', 
    prevention: 'Usare denominazione esatta dalla Smart Card' 
  },
  '3111': { 
    severity: 'error', 
    description: 'Il titolare del sistema non è presente nell\'anagrafica SIAE', 
    prevention: 'Verificare CF Titolare registrato presso SIAE' 
  },
  '3203': { 
    severity: 'error', 
    description: 'Codice del locale non presente nell\'anagrafica centralizzata SIAE', 
    prevention: 'Verificare codice locale SIAE (13 cifre)' 
  },
  '3706': { 
    severity: 'error', 
    description: 'Il prefisso o la lunghezza del nome del subject è sbagliato', 
    prevention: 'Verificare formato oggetto email S/MIME' 
  },
  '40601': { 
    severity: 'error', 
    description: 'Il riepilogo risulta illeggibile - formato errato', 
    prevention: 'Verificare struttura XML conforme DTD' 
  },
  '40603': { 
    severity: 'error', 
    description: 'Il riepilogo risulta illeggibile - encoding', 
    prevention: 'Verificare encoding UTF-8' 
  },
  '40604': { 
    severity: 'error', 
    description: 'Il riepilogo risulta illeggibile - firma non valida', 
    prevention: 'Verificare firma CAdES-BES' 
  },
  '40605': { 
    severity: 'error', 
    description: 'Il riepilogo risulta illeggibile, impossibile estrarre le informazioni', 
    prevention: 'Verificare XML, encoding, firma e formato complessivo' 
  },
  '42605': { 
    severity: 'error', 
    description: 'Errore validazione XML avanzata', 
    prevention: 'Verificare elementi obbligatori XML' 
  },
  '9999': { 
    severity: 'error', 
    description: 'Riepilogo Rifiutato: Eventi/Abbonamenti errati', 
    prevention: 'Controllare dettagli errori specifici nel corpo risposta' 
  },
} as const;

/**
 * Valida la coerenza del codice sistema tra XML e nome file.
 * Previene errori SIAE 0600 ("Nome del file contenente il riepilogo sbagliato")
 * e 0603 ("Le date dell'oggetto, del nome file, e del contenuto del riepilogo non sono coerenti").
 * 
 * Verifica tre elementi:
 * 1. Elementi SistemaEmissione/CodiceSistemaCA/CodiceSistemaEmissione
 * 2. Attributo NomeFile (per RMG/RPM)
 * 
 * @param xmlContent - Contenuto XML da validare
 * @param expectedSystemCode - Codice sistema atteso (usato per nome file)
 * @returns Oggetto con risultato validazione
 */
export function validateSystemCodeConsistency(
  xmlContent: string,
  expectedSystemCode: string
): SystemCodeValidationResult {
  let xmlSystemCode: string | null = null;
  
  // Determina tipo report e estrai codice sistema
  const isRCA = xmlContent.includes('<RiepilogoControlloAccessi');
  const isRMG = xmlContent.includes('<RiepilogoGiornaliero');
  const isRPM = xmlContent.includes('<RiepilogoMensile');
  
  if (isRCA) {
    // RCA: Extract CodiceSistemaCA or CodiceSistemaEmissione
    const codiceSistemaCAMatch = xmlContent.match(/<CodiceSistemaCA>([^<]+)<\/CodiceSistemaCA>/);
    const codiceSistemaEmissioneMatch = xmlContent.match(/<CodiceSistemaEmissione>([^<]+)<\/CodiceSistemaEmissione>/);
    xmlSystemCode = codiceSistemaCAMatch?.[1] || codiceSistemaEmissioneMatch?.[1] || null;
  } else if (isRMG || isRPM) {
    // RMG/RPM: Extract SistemaEmissione
    const sistemaEmissioneMatch = xmlContent.match(/<SistemaEmissione>([^<]+)<\/SistemaEmissione>/);
    xmlSystemCode = sistemaEmissioneMatch?.[1] || null;
  }
  
  // Se non troviamo codice sistema nell'XML, è un warning ma non un errore bloccante
  if (!xmlSystemCode) {
    return {
      valid: true,
      xmlSystemCode: null,
      filenameSystemCode: expectedSystemCode,
    };
  }
  
  // Verifica coerenza elemento SistemaEmissione/CodiceSistemaCA
  if (xmlSystemCode !== expectedSystemCode) {
    return {
      valid: false,
      xmlSystemCode,
      filenameSystemCode: expectedSystemCode,
      error: `ERRORE COERENZA CODICE SISTEMA: Il codice sistema nell'XML (${xmlSystemCode}) non corrisponde a quello usato per il nome file (${expectedSystemCode}). Questo causerebbe errore SIAE 0600/0603.`,
    };
  }
  
  // Verifica anche attributo NomeFile (solo per RMG/RPM che lo supportano)
  // Formato generato da generateSiaeAttachmentName():
  // - RMG: RMG_yyyyMMdd_SSSSSSSS_nnn.xsi (es: RMG_20260115_EVENT4U1_001.xsi)
  // - RPM: RPM_yyyyMM_SSSSSSSS_nnn.xsi (es: RPM_202601_EVENT4U1_001.xsi)
  // Il codice sistema è SEMPRE nella 3a parte (parts[2]) con underscore come separatore
  if (isRMG || isRPM) {
    const nomeFileMatch = xmlContent.match(/NomeFile="([^"]+)"/);
    if (nomeFileMatch) {
      const nomeFileValue = nomeFileMatch[1];
      const parts = nomeFileValue.split('_');
      // parts[0] = tipo (RMG/RPM)
      // parts[1] = data (yyyyMMdd o yyyyMM)
      // parts[2] = codice sistema (8 caratteri)
      // parts[3] = progressivo.estensione (nnn.xsi o nnn.xsi.p7m)
      const nomeFileSystemCode = parts.length >= 3 ? parts[2] : null;
      
      if (nomeFileSystemCode && nomeFileSystemCode !== expectedSystemCode) {
        return {
          valid: false,
          xmlSystemCode: nomeFileSystemCode,
          filenameSystemCode: expectedSystemCode,
          error: `ERRORE COERENZA ATTRIBUTO NOMEFILE: Il codice sistema nell'attributo NomeFile (${nomeFileSystemCode}) non corrisponde a quello atteso (${expectedSystemCode}). Questo causerebbe errore SIAE 0600.`,
        };
      }
    }
  }
  
  return {
    valid: true,
    xmlSystemCode,
    filenameSystemCode: expectedSystemCode,
  };
}

// ==================== XML Character Escaping ====================

/**
 * Escape caratteri speciali XML per conformità UTF-8
 * Gestisce anche caratteri accentati italiani (à, è, é, ì, ò, ù)
 */
export function escapeXml(str: string | null | undefined): string {
  if (!str) return '';
  return str.replace(/[<>&'"]/g, (c) => {
    switch (c) {
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '&': return '&amp;';
      case "'": return '&apos;';
      case '"': return '&quot;';
      default: return c;
    }
  });
}

// ==================== Date/Time Formatting ====================

/**
 * Formatta data in formato SIAE compatto AAAAMMGG
 * Conforme a Allegato B - Provvedimento 04/03/2008
 * Es: 20241228 per 28 dicembre 2024
 */
export function formatSiaeDateCompact(date: Date | string | null): string {
  if (!date) return '00000000';
  const d = typeof date === 'string' ? new Date(date) : date;
  if (isNaN(d.getTime())) return '00000000';
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${year}${month}${day}`;
}

/**
 * Formatta ora in formato SIAE compatto HHMMSS
 * Conforme a Allegato B - OraGenerazioneRiepilogo
 * Es: 143015 per 14:30:15
 */
export function formatSiaeTimeCompact(date: Date | string | null): string {
  if (!date) return '000000';
  const d = typeof date === 'string' ? new Date(date) : date;
  if (isNaN(d.getTime())) return '000000';
  const hours = String(d.getHours()).padStart(2, '0');
  const minutes = String(d.getMinutes()).padStart(2, '0');
  const seconds = String(d.getSeconds()).padStart(2, '0');
  return `${hours}${minutes}${seconds}`;
}

/**
 * Formatta ora in formato SIAE HHMM (per OraEvento)
 * Conforme a Allegato B - OraEvento
 * Es: 1430 per 14:30
 */
export function formatSiaeTimeHHMM(date: Date | string | null): string {
  if (!date) return '0000';
  const d = typeof date === 'string' ? new Date(date) : date;
  if (isNaN(d.getTime())) return '0000';
  const hours = String(d.getHours()).padStart(2, '0');
  const minutes = String(d.getMinutes()).padStart(2, '0');
  return `${hours}${minutes}`;
}

/**
 * Formatta data in formato SIAE YYYY-MM-DD (legacy)
 */
export function formatSiaeDate(date: Date | null | undefined): string {
  if (!date) return '';
  return date.toISOString().split('T')[0];
}

/**
 * Formatta datetime in formato SIAE YYYY-MM-DDTHH:MM:SS (legacy)
 */
export function formatSiaeDateTime(date: Date | null | undefined): string {
  if (!date) return '';
  return date.toISOString().replace('.000Z', '');
}

// ==================== Amount Conversion ====================

/**
 * Converte importo da euro a centesimi (intero)
 * SIAE richiede importi in centesimi senza decimali
 */
export function toCentesimi(euroAmount: number | string): number {
  const euro = typeof euroAmount === 'string' ? parseFloat(euroAmount) : euroAmount;
  return Math.round((euro || 0) * 100);
}

// ==================== Code Normalization ====================

/**
 * Normalizza TipoTitolo per conformità SIAE
 * Valori validi (da tabella 3 LTA - Lista Titoli Accessi):
 * - I1, I2, etc. = Intero (biglietto a prezzo pieno)
 * - R1, R2, etc. = Ridotto (biglietto con sconto)
 * - O1, O2, etc. = Omaggio (biglietto gratuito)
 * - ABB = Abbonamento
 */
export function normalizeSiaeTipoTitolo(rawCode: string | null | undefined, isComplimentary?: boolean): string {
  if (isComplimentary) return 'O1';
  if (!rawCode) return 'I1'; // Default: Intero tipo 1
  
  const code = rawCode.toUpperCase().trim();
  
  // Se già in formato SIAE (lettera + cifra), usa direttamente
  if (/^[IRO][0-9]$/.test(code)) {
    return code;
  }
  
  switch (code) {
    case 'I1':
    case 'I2':
    case 'INTERO':
    case 'FULL':
    case 'STANDARD':
    case 'NORMAL':
      return 'I1';
    
    case 'R1':
    case 'R2':
    case 'RIDOTTO':
    case 'REDUCED':
    case 'DISCOUNT':
      return 'R1';
    
    case 'O1':
    case 'O2':
    case 'OMAGGIO':
    case 'FREE':
    case 'COMPLIMENTARY':
    case 'GRATIS':
      return 'O1';
    
    case 'ABB':
    case 'ABBONAMENTO':
    case 'SUBSCRIPTION':
      return 'I1'; // Abbonamento trattato come Intero per RCA
    
    default:
      return 'I1'; // Default: Intero tipo 1
  }
}

/**
 * Normalizza CodiceOrdine (settore) per conformità SIAE
 * Valori validi: A0, A1, B1, ecc. (formato lettera + numero)
 */
export function normalizeSiaeCodiceOrdine(rawCode: string | null | undefined): string {
  if (!rawCode) return 'A0';
  
  const code = rawCode.toUpperCase().trim();
  
  if (/^[A-Z][0-9]$/.test(code)) {
    return code;
  }
  
  if (/^[A-Z]+$/.test(code)) {
    return code.charAt(0) + '0';
  }
  
  if (/^[0-9]+$/.test(code)) {
    return 'A' + code.charAt(0);
  }
  
  return 'A0';
}

/**
 * Normalizza CodiceRichiedenteEmissioneSigillo per conformità SIAE
 * OBBLIGATORIO: 8 CIFRE nel formato TTCCCCCC (tutto numerico)
 * - TT = tipo richiesta (2 cifre): 01=prima emissione, 02=sostituzione, 03=annullamento, 04=duplicato, 05=emissione sistema
 * - CCCCCC = codice sistema (6 CIFRE numeriche)
 * 
 * Allegato B - Provvedimento Agenzia Entrate 04/03/2008
 * NOTA: SIAE richiede formato STRETTAMENTE NUMERICO (8 cifre), non alfanumerico
 */
export function formatCodiceRichiedente(rawCode: string | null | undefined, systemCode: string): string {
  // Se già nel formato corretto (8 cifre numeriche: 2 tipo + 6 codice)
  if (rawCode && /^[0-9]{8}$/.test(rawCode)) {
    return rawCode;
  }
  
  // Genera codice conforme: tipo "05" (emissione sistema) + 6 cifre
  const tipoRichiesta = '05'; // emissione da sistema automatico
  
  // Estrai solo le cifre dal systemCode, genera hash numerico se necessario
  let cifre = systemCode.replace(/\D/g, ''); // Solo cifre
  
  if (cifre.length >= 6) {
    // Prendi le ultime 6 cifre
    cifre = cifre.substring(cifre.length - 6);
  } else if (cifre.length > 0) {
    // Padda con zeri a sinistra
    cifre = cifre.padStart(6, '0');
  } else {
    // Nessuna cifra nel systemCode: genera hash numerico dal nome
    // Usa semplice hash basato su codici carattere
    let hash = 0;
    for (let i = 0; i < systemCode.length; i++) {
      hash = ((hash << 5) - hash + systemCode.charCodeAt(i)) | 0;
    }
    // Converti in 6 cifre positive
    cifre = String(Math.abs(hash) % 1000000).padStart(6, '0');
  }
  
  return tipoRichiesta + cifre;
}

/**
 * Normalizza CausaleAnnullamento per conformità SIAE
 * OBBLIGATORIO: 3 cifre nel range 001-010
 * 
 * Codici SIAE Allegato B:
 * 001 = Biglietto smarrito
 * 002 = Biglietto difettoso
 * 003 = Evento annullato
 * 004 = Cambio data evento
 * 005 = Richiesta cliente
 * 006 = Errore operatore
 * 007 = Doppia vendita
 * 008 = Overbooking
 * 009 = Annullamento fiscale
 * 010 = Cambio nominativo (Allegato B art. 5.4)
 */
export function normalizeCausaleAnnullamento(rawCode: string | null | undefined): string {
  if (!rawCode) return '005'; // Default: richiesta cliente
  
  const code = rawCode.replace(/\D/g, ''); // Solo cifre
  
  // Se già 3 cifre, verifica range
  if (code.length === 3) {
    const num = parseInt(code, 10);
    if (num >= 1 && num <= 10) {
      return code;
    }
  }
  
  // Se 1-2 cifre, padda a 3
  if (code.length >= 1 && code.length <= 2) {
    const num = parseInt(code, 10);
    if (num >= 1 && num <= 10) {
      return String(num).padStart(3, '0');
    }
  }
  
  // Default fallback
  return '005';
}

// ==================== File Naming ====================

/**
 * Genera NOME FILE ALLEGATO conforme Allegato C SIAE (Sezione 1.4.1)
 * 
 * FORMATO ALLEGATO: XXX_<yyyyMMdd>_<Sistema8cifre>_<nnn>.xsi(.p7m)
 * Esempio: RMG_20260113_P0004010_004.xsi
 * 
 * NOTA: Questo è DIVERSO dal Subject email che ha formato con separatori!
 * 
 * - XXX = Prefisso (RCA, RMG, RPM)
 * - yyyyMMdd = Data contigua (SENZA underscore)
 * - Sistema8cifre = Codice sistema a 8 caratteri (es: P0004010)
 * - nnn = Progressivo (001-999)
 * - .xsi = Estensione XML SIAE
 * - .p7m = aggiunta per file firmati CAdES
 */
export function generateSiaeAttachmentName(
  reportType: 'giornaliero' | 'mensile' | 'rca' | 'log',
  date: Date,
  progressivo: number,
  signatureFormat?: 'cades' | 'xmldsig' | null,
  systemCode?: string
): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const prog = String(progressivo).padStart(3, '0');
  
  // FIX 2026-01-17: Codice sistema OBBLIGATORIO - non usare default!
  // Il default EVENT4U1 NON è registrato presso SIAE e causa errore 0600
  if (!systemCode || systemCode.length !== 8) {
    console.error(`[SIAE-UTILS] CRITICAL: Codice sistema mancante o invalido in generateSiaeAttachmentName! Valore: "${systemCode || 'undefined'}"`);
    // Se il codice è il default o mancante, BLOCCA con errore esplicito invece di usare placeholder
    if (!systemCode || systemCode === SIAE_SYSTEM_CODE_DEFAULT) {
      throw new Error(`Codice sistema SIAE non configurato. Il codice "${SIAE_SYSTEM_CODE_DEFAULT}" non è registrato presso SIAE e causerebbe errore 0600.`);
    }
  }
  const sysCode = systemCode;
  
  // Estensione: .xsi.p7m per CAdES, .xsi per non firmato
  const extension = signatureFormat === 'cades' ? '.xsi.p7m' : '.xsi';
  
  // Data contigua SENZA underscore (yyyyMMdd)
  const dateStr = `${year}${month}${day}`;
  const monthStr = `${year}${month}`;
  
  // Formato allegato conforme: XXX_yyyyMMdd_SSSSSSSS_nnn.xsi(.p7m)
  switch (reportType) {
    case 'mensile':
      // RPM = Riepilogo Periodico Mensile (usa solo anno-mese)
      return `RPM_${monthStr}_${sysCode}_${prog}${extension}`;
    case 'log':
    case 'rca':
      // RCA = Riepilogo Controllo Accessi
      return `RCA_${dateStr}_${sysCode}_${prog}${extension}`;
    case 'giornaliero':
    default:
      // RMG = Riepilogo Mensile Giornaliero
      return `RMG_${dateStr}_${sysCode}_${prog}${extension}`;
  }
}

/**
 * Genera SUBJECT EMAIL conforme Allegato C SIAE
 * 
 * FIX 2026-01-16: Il subject DEVE essere IDENTICO al nome file allegato (senza estensione)
 * per evitare errore SIAE 0603 "Le date dell'oggetto, del nome file, e del contenuto non sono coerenti"
 * 
 * FORMATO SUBJECT = nome file senza estensione:
 * - RMG_YYYYMMDD_SSSSSSSS_NNN (giornaliero)
 * - RPM_YYYYMM_SSSSSSSS_NNN (mensile)
 * - RCA_YYYYMMDD_SSSSSSSS_NNN (evento)
 * 
 * Esempi:
 * - RMG_20260115_P0004010_012
 * - RPM_202601_P0004010_009
 * - RCA_20260115_P0004010_001
 */
export function generateSiaeSubject(
  reportType: 'giornaliero' | 'mensile' | 'rca' | 'log',
  date: Date,
  progressivo: number,
  systemCode?: string
): string {
  // Genera il nome file completo e rimuovi l'estensione
  // Questo garantisce che subject e nome file siano SEMPRE identici
  const fullFileName = generateSiaeAttachmentName(reportType, date, progressivo, null, systemCode);
  // Rimuovi .xsi o .xsi.p7m dall'estensione
  const subject = fullFileName.replace(/\.xsi(\.p7m)?$/, '');
  return subject;
}

/**
 * LEGACY: Mantiene compatibilità con codice esistente
 * Reindirizza a generateSiaeAttachmentName
 * 
 * @deprecated Usa generateSiaeAttachmentName per il nome file allegato
 *             e generateSiaeSubject per il Subject email
 */
export function generateSiaeFileName(
  reportType: 'giornaliero' | 'mensile' | 'rca' | 'log',
  date: Date,
  progressivo: number,
  signatureFormat?: 'cades' | 'xmldsig' | null,
  systemCode?: string
): string {
  return generateSiaeAttachmentName(reportType, date, progressivo, signatureFormat, systemCode);
}

// ==================== C1 Log XML Generation ====================
// Conforme a Log_v0040_20190627.dtd per trasmissione C1 evento a SIAE

/**
 * Struttura biglietto per generazione Log C1
 * Compatibile con siaeTickets schema
 */
export interface SiaeTicketForLog {
  id: string;
  fiscalSealCode: string | null;
  progressiveNumber: number;
  cardCode: string | null;
  emissionChannelCode: string | null;
  emissionDate: Date | string;
  ticketTypeCode: string;
  sectorCode: string;
  grossAmount: string | number;
  netAmount?: string | number | null;
  vatAmount?: string | number | null;
  prevendita?: string | number | null;
  prevenditaVat?: string | number | null;
  entertainmentTaxBase?: string | number | null;
  status: string;
  cancellationReasonCode?: string | null;
  cancellationDate?: Date | string | null;
  isComplimentary?: boolean;
  row?: string | null;
  seatNumber?: string | null;
  participantFirstName?: string | null;
  participantLastName?: string | null;
  originalTicketId?: string | null;
  originalProgressiveNumber?: number | null;
  replacedByTicketId?: string | null;
}

/**
 * Dati evento per generazione Log C1
 */
export interface SiaeEventForLog {
  id: string;
  name: string;
  date: Date | string;
  time?: Date | string | null;
  venueCode: string;
  genreCode: string;
  organizerTaxId: string;
  organizerName?: string;
  tipoTassazione?: 'S' | 'I';
  ivaPreassolta?: 'N' | 'B' | 'F';
}

/**
 * Parametri per generazione Log C1 XML
 */
export interface C1LogParams {
  companyId: string;
  eventId: string;
  event: SiaeEventForLog;
  tickets: SiaeTicketForLog[];
  systemConfig: {
    systemCode?: string;
    taxId?: string;
    businessName?: string;
    codiceRichiedente?: string;
  };
  companyName: string;
  taxId: string;
  cardNumber?: string;
}

/**
 * Risultato generazione Log C1 XML
 */
export interface C1LogResult {
  success: boolean;
  xml: string;
  transactionCount: number;
  errors: string[];
  warnings: string[];
}

/**
 * @deprecated Use generateRCAXml instead. This function generates LogTransazione format
 * which is rejected by SIAE with error 40605 "Il riepilogo risulta illegibile".
 * 
 * Genera XML conforme al DTD Log_v0040_20190627.dtd per trasmissione C1 evento a SIAE
 * 
 * Struttura:
 * - LogTransazione contiene N elementi Transazione (uno per biglietto)
 * - Ogni Transazione ha attributi obbligatori e contiene TitoloAccesso
 * - Importi in CENTESIMI (moltiplicare euro * 100) usando toCentesimi()
 * - Date formato AAAAMMGG, ore formato HHMMSS o HHMM
 * 
 * CORREZIONI DTD-COMPLIANT (Log_v0040_20190627.dtd):
 * - SistemaEmissione: da systemConfig.systemCode o SIAE_SYSTEM_CODE_DEFAULT
 * - CartaAttivazione: da cardNumber o ticket.cardCode (warning se mancante)
 * - NumeroProgressivo: da ticket.progressiveNumber o fallback a indice+1
 * - OraEvento: da event.time (non usare new Date() come fallback)
 * - Tutti gli importi convertiti con toCentesimi()
 * 
 * @param params - Parametri per la generazione del Log C1
 * @returns Oggetto con XML generato, conteggio transazioni e eventuali errori
 */
export function generateC1LogXml(params: C1LogParams): C1LogResult {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  const { event, tickets, systemConfig, companyName, taxId, cardNumber } = params;
  
  // Validazione parametri obbligatori
  if (!event) {
    errors.push('Evento obbligatorio per generazione Log C1');
    return { success: false, xml: '', transactionCount: 0, errors, warnings };
  }
  
  if (!tickets || tickets.length === 0) {
    errors.push('Almeno un biglietto obbligatorio per generazione Log C1');
    return { success: false, xml: '', transactionCount: 0, errors, warnings };
  }
  
  if (!taxId || taxId.length < 11) {
    errors.push('Codice Fiscale Titolare obbligatorio (11-16 caratteri)');
    return { success: false, xml: '', transactionCount: 0, errors, warnings };
  }
  
  // FIX 2026-01-17: Validazione codice sistema PRIMA di generare XML
  // Blocca la generazione se il codice sistema non è valido (previene errore 0600)
  const systemCodeResult = resolveSystemCodeSafe(null, systemConfig);
  if (!systemCodeResult.success || !systemCodeResult.systemCode) {
    errors.push(systemCodeResult.error || 'Codice sistema SIAE non configurato - impossibile generare Log C1');
    return { success: false, xml: '', transactionCount: 0, errors, warnings };
  }
  const sistemaEmissione = systemCodeResult.systemCode;
  
  // CF deve essere uppercase, max 16 caratteri, senza padding con spazi
  const cfTitolare = taxId.toUpperCase().substring(0, 16);
  const cfOrganizzatore = (event.organizerTaxId || taxId).toUpperCase().substring(0, 16);
  const tipoTassazione = event.tipoTassazione || 'S';
  const ivaPreassolta = event.ivaPreassolta || 'N';
  
  // CodiceRichiedenteEmissioneSigillo: OBBLIGATORIO 8 caratteri
  // Formato: TTCCCCCC dove TT = tipo richiesta (2 cifre), CCCCCC = codice sistema (6 cifre)
  // Tipi: 01=prima emissione, 02=sostituzione, 03=annullamento, 04=duplicato, 05=emissione sistema
  const codiceRichiedente = formatCodiceRichiedente(
    systemConfig?.codiceRichiedente,
    sistemaEmissione
  );
  
  // DEBUG: Log per tracciare valori generati
  console.log('[SIAE C1] CodiceRichiedenteEmissioneSigillo:', {
    input: systemConfig?.codiceRichiedente,
    systemCode: systemConfig?.systemCode,
    output: codiceRichiedente,
    isValid8Digits: /^[0-9]{8}$/.test(codiceRichiedente)
  });
  
  // 2. CartaAttivazione: NON usare "00000000"! Usa cardNumber o avvisa
  // Placeholder documentato solo se entrambi mancano
  const globalCartaAttivazione = cardNumber || null;
  if (!globalCartaAttivazione) {
    warnings.push('CartaAttivazione globale mancante - verrà usato il valore del singolo biglietto o placeholder');
  }
  
  // Dati evento
  const eventDate = typeof event.date === 'string' ? new Date(event.date) : event.date;
  const dataEvento = formatSiaeDateCompact(eventDate);
  
  // 5. OraEvento: usare event.time, non new Date() come fallback!
  // Se event.time è presente, usarlo; altrimenti estrarre l'ora da event.date
  let eventTimeValue: Date;
  if (event.time) {
    eventTimeValue = typeof event.time === 'string' ? new Date(event.time) : event.time;
  } else {
    // Usa l'ora dall'eventDate stesso, non un fallback a "ora corrente"
    eventTimeValue = eventDate;
  }
  const oraEvento = formatSiaeTimeHHMM(eventTimeValue);
  
  const codiceLocale = (event.venueCode || '0000000000001').padStart(13, '0');
  const tipoGenere = event.genreCode || 'S1';
  const titolo = escapeXml(event.name || 'Evento');
  
  // Costruzione XML
  let xmlLines: string[] = [];
  
  // Intestazione XML
  xmlLines.push('<?xml version="1.0" encoding="UTF-8"?>');
  xmlLines.push('<!DOCTYPE LogTransazione SYSTEM "Log_v0040_20190627.dtd">');
  xmlLines.push('<LogTransazione>');
  
  // Genera una Transazione per ogni biglietto
  for (let i = 0; i < tickets.length; i++) {
    const ticket = tickets[i];
    const ticketIndex = i + 1;
    
    // Validazione biglietto - SigilloFiscale è obbligatorio DTD
    const sigilloFiscale = ticket.fiscalSealCode || '';
    if (!sigilloFiscale) {
      warnings.push(`Ticket ${ticketIndex}: SigilloFiscale mancante`);
    }
    
    // 2. CartaAttivazione: priorità cardNumber globale > ticket.cardCode
    const ticketCarta = globalCartaAttivazione || ticket.cardCode;
    if (!ticketCarta) {
      warnings.push(`Ticket ${ticketIndex}: CartaAttivazione mancante (né cardNumber né ticket.cardCode)`);
    }
    // Placeholder documentato SOLO se necessario (mai "00000000" senza motivo)
    const cartaAttivazioneValue = ticketCarta || 'MANCANTE';
    
    // 7. Date formattate correttamente
    const emissionDate = typeof ticket.emissionDate === 'string' 
      ? new Date(ticket.emissionDate) 
      : ticket.emissionDate;
    const dataEmissione = formatSiaeDateCompact(emissionDate);
    // OraEmissione deve essere in formato HHMM (4 cifre), non HHMMSS (6 cifre)
    const oraEmissione = formatSiaeTimeHHMM(emissionDate);
    
    // 4. NumeroProgressivo: usa ticket.progressiveNumber o fallback a indice+1
    const progressivo = ticket.progressiveNumber || ticketIndex;
    const numeroProgressivo = String(progressivo).padStart(10, '0');
    
    // Tipo titolo e codice ordine normalizzati
    const tipoTitolo = normalizeSiaeTipoTitolo(ticket.ticketTypeCode, ticket.isComplimentary);
    const codiceOrdine = normalizeSiaeCodiceOrdine(ticket.sectorCode);
    
    // 3. Importi in centesimi - TUTTI con toCentesimi()
    const grossAmountCents = toCentesimi(ticket.grossAmount);
    const prevenditaCents = toCentesimi(ticket.prevendita || 0);
    const ivaCorrispettivoCents = toCentesimi(ticket.vatAmount || 0);
    const ivaPrevenditaCents = toCentesimi(ticket.prevenditaVat || 0);
    
    // ImponibileIntrattenimenti: calcolato solo per TipoTassazione="I" (Intrattenimento)
    // Per Spettacolo ("S") è sempre 0
    const imponibileIntrattenimenti = tipoTassazione === 'I' 
      ? toCentesimi(ticket.entertainmentTaxBase || ticket.grossAmount || 0)
      : 0;
    
    // Annullamento - considera status, cancellationReasonCode e cancellationDate
    // IMPORTANTE: Se cancellationReasonCode o cancellationDate sono presenti, il biglietto è annullato
    const isCancelled = isCancelledStatus(ticket.status) || !!ticket.cancellationReasonCode || !!ticket.cancellationDate;
    const annullamento = isCancelled ? 'S' : 'N';
    
    // Posto (opzionale)
    const posto = ticket.row && ticket.seatNumber 
      ? `${ticket.row}-${ticket.seatNumber}` 
      : (ticket.seatNumber || '');
    
    // 6. CausaleAnnullamento: normalizzata a 3 cifre (001-010) per conformità SIAE
    const causaleAnnullamento = isCancelled 
      ? normalizeCausaleAnnullamento(ticket.cancellationReasonCode)
      : '';
    
    // Costruzione attributi Transazione (ordine DTD)
    let transactionAttrs = [
      `CFOrganizzatore="${cfOrganizzatore}"`,
      `CFTitolare="${cfTitolare}"`,
      `IVAPreassolta="${ivaPreassolta}"`,
      `TipoTassazione="${tipoTassazione}"`,
      `Valuta="E"`,
      `SistemaEmissione="${escapeXml(sistemaEmissione)}"`,
      `CartaAttivazione="${escapeXml(cartaAttivazioneValue)}"`,
      `SigilloFiscale="${escapeXml(sigilloFiscale)}"`,
      `DataEmissione="${dataEmissione}"`,
      `OraEmissione="${oraEmissione}"`,
      `NumeroProgressivo="${numeroProgressivo}"`,
      `TipoTitolo="${tipoTitolo}"`,
      `CodiceOrdine="${codiceOrdine}"`,
      `CodiceRichiedenteEmissioneSigillo="${escapeXml(codiceRichiedente)}"`,
      `ImponibileIntrattenimenti="${imponibileIntrattenimenti}"`,
    ];
    
    // Attributi opzionali
    if (posto) {
      transactionAttrs.push(`Posto="${escapeXml(posto)}"`);
    }
    
    // 6. CausaleAnnullamento per biglietti annullati (OBBLIGATORIO se annullato)
    if (isCancelled) {
      transactionAttrs.push(`CausaleAnnullamento="${causaleAnnullamento}"`);
    }
    
    if (ticket.originalTicketId) {
      transactionAttrs.push(`OriginaleAnnullato="${escapeXml(ticket.originalTicketId)}"`);
    }
    
    // Apertura Transazione
    xmlLines.push(`  <Transazione ${transactionAttrs.join(' ')}>`);
    
    // TitoloAccesso
    xmlLines.push(`    <TitoloAccesso Annullamento="${annullamento}">`);
    xmlLines.push(`      <CorrispettivoLordo>${grossAmountCents}</CorrispettivoLordo>`);
    xmlLines.push(`      <Prevendita>${prevenditaCents}</Prevendita>`);
    xmlLines.push(`      <IVACorrispettivo>${ivaCorrispettivoCents}</IVACorrispettivo>`);
    xmlLines.push(`      <IVAPrevendita>${ivaPrevenditaCents}</IVAPrevendita>`);
    xmlLines.push(`      <CodiceLocale>${codiceLocale}</CodiceLocale>`);
    xmlLines.push(`      <DataEvento>${dataEvento}</DataEvento>`);
    xmlLines.push(`      <OraEvento>${oraEvento}</OraEvento>`);
    xmlLines.push(`      <TipoGenere>${tipoGenere}</TipoGenere>`);
    xmlLines.push(`      <Titolo>${titolo}</Titolo>`);
    
    // Partecipante (opzionale, se nominativo)
    if (ticket.participantFirstName && ticket.participantLastName) {
      xmlLines.push(`      <Partecipante>`);
      xmlLines.push(`        <Nome>${escapeXml(ticket.participantFirstName)}</Nome>`);
      xmlLines.push(`        <Cognome>${escapeXml(ticket.participantLastName)}</Cognome>`);
      xmlLines.push(`      </Partecipante>`);
    }
    
    // Chiusura TitoloAccesso
    xmlLines.push(`    </TitoloAccesso>`);
    
    // RiferimentoAnnullamento: OBBLIGATORIO quando Annullamento="S" (Allegato B art. 5.4)
    // NOTA DTD: RiferimentoAnnullamento è figlio DIRETTO di Transazione, NON di TitoloAccesso!
    // DTD: <!ELEMENT Transazione (TitoloAccesso?, ..., RiferimentoAnnullamento?)>
    if (isCancelled) {
      xmlLines.push(`    <RiferimentoAnnullamento>`);
      // OriginaleRiferimentoAnnullamento: progressivo del biglietto originale
      const originaleRef = ticket.originalProgressiveNumber || ticket.progressiveNumber || ticketIndex;
      xmlLines.push(`      <OriginaleRiferimentoAnnullamento>${String(originaleRef).padStart(10, '0')}</OriginaleRiferimentoAnnullamento>`);
      // CartaRiferimentoAnnullamento: carta usata per emissione originale
      xmlLines.push(`      <CartaRiferimentoAnnullamento>${escapeXml(cartaAttivazioneValue)}</CartaRiferimentoAnnullamento>`);
      // CausaleRiferimentoAnnullamento: motivo annullamento (3 cifre)
      xmlLines.push(`      <CausaleRiferimentoAnnullamento>${causaleAnnullamento}</CausaleRiferimentoAnnullamento>`);
      xmlLines.push(`    </RiferimentoAnnullamento>`);
    }
    
    xmlLines.push(`  </Transazione>`);
  }
  
  // Chiusura LogTransazione
  xmlLines.push('</LogTransazione>');
  
  const xml = xmlLines.join('\n');
  
  return {
    success: errors.length === 0,
    xml,
    transactionCount: tickets.length,
    errors,
    warnings
  };
}

// ==================== SIAE Configuration ====================

export const SIAE_SYSTEM_CODE_DEFAULT = 'EVENT4U1';

/**
 * Valida il formato del codice sistema SIAE.
 * 
 * Codici validi SIAE:
 * - Test: Iniziano con 'P' seguito da 7 cifre (es: P0004010)
 * - Produzione: 8 caratteri alfanumerici assegnati da SIAE
 * 
 * Il default EVENT4U1 NON è un codice registrato presso SIAE e causerà errore 0600.
 * 
 * @param systemCode - Codice da validare
 * @returns Oggetto con validità e eventuale messaggio di errore
 */
export function validateSiaeSystemCode(systemCode: string): { 
  valid: boolean; 
  isDefault: boolean;
  isTestCode: boolean;
  error?: string;
} {
  if (!systemCode || systemCode.length !== 8) {
    return {
      valid: false,
      isDefault: false,
      isTestCode: false,
      error: `Codice sistema "${systemCode}" non valido: deve essere esattamente 8 caratteri`
    };
  }
  
  const isDefault = systemCode === SIAE_SYSTEM_CODE_DEFAULT;
  const isTestCode = systemCode.toUpperCase().startsWith('P');
  
  // Il codice default EVENT4U1 NON è registrato presso SIAE
  if (isDefault) {
    return {
      valid: false,
      isDefault: true,
      isTestCode: false,
      error: `Codice sistema "${SIAE_SYSTEM_CODE_DEFAULT}" è un placeholder non registrato presso SIAE. Configurare un codice valido in Impostazioni SIAE oppure collegare una Smart Card attiva.`
    };
  }
  
  // Codici test (iniziano con P): verificare formato P + 7 cifre
  if (isTestCode) {
    const testCodePattern = /^P\d{7}$/;
    if (!testCodePattern.test(systemCode.toUpperCase())) {
      return {
        valid: false,
        isDefault: false,
        isTestCode: true,
        error: `Codice sistema test "${systemCode}" non valido: formato atteso P + 7 cifre (es: P0004010)`
      };
    }
  }
  
  return {
    valid: true,
    isDefault: false,
    isTestCode
  };
}

/**
 * Risultato della risoluzione del codice sistema SIAE
 */
export interface ResolveSystemCodeResult {
  success: boolean;
  systemCode: string | null;
  source: 'smartcard' | 'config' | 'none';
  error?: string;
}

/**
 * Risolve il codice sistema SIAE da usare in modo consistente in tutto il sistema.
 * 
 * PRIORITÀ (dalla più affidabile alla meno affidabile):
 * 1. Smart Card EFFF systemId - Codice ufficiale SIAE dalla carta di attivazione
 * 2. systemConfig.systemCode - Configurazione manuale dell'utente
 * 3. BLOCCO - NON ritorna più EVENT4U1 che causa errore 0600!
 * 
 * IMPORTANTE: Questo codice DEVE essere usato in modo consistente per:
 * - Nome file allegato (es: RPM_202601_P0004010_001.xsi)
 * - Attributo NomeFile nell'XML
 * - Elemento SistemaEmissione nell'XML
 * 
 * L'incongruenza tra questi valori causa errori SIAE:
 * - 0600: "Nome del file contenente il riepilogo sbagliato"
 * - 0603: "Le date dell'oggetto, del nome file, e del contenuto del riepilogo non sono coerenti"
 * 
 * FIX 2026-01-17: Non ritorna più il default EVENT4U1 che NON è registrato presso SIAE!
 * Ora ritorna null se nessun codice valido è disponibile, forzando il chiamante a gestire l'errore.
 * 
 * @param cachedEfff - Dati EFFF dalla smart card (opzionale)
 * @param systemConfig - Configurazione SIAE dell'azienda (opzionale)
 * @returns Oggetto con codice sistema o errore
 */
export function resolveSystemCodeSafe(
  cachedEfff?: { systemId?: string } | null,
  systemConfig?: { systemCode?: string } | null
): ResolveSystemCodeResult {
  // Priorità 1: Smart Card EFFF (codice ufficiale SIAE)
  if (cachedEfff?.systemId && cachedEfff.systemId.length === 8) {
    console.log(`[SIAE-UTILS] resolveSystemCodeSafe: using Smart Card EFFF systemId = ${cachedEfff.systemId}`);
    return { success: true, systemCode: cachedEfff.systemId, source: 'smartcard' };
  }
  
  // Priorità 2: Configurazione utente (ma NON se è il default EVENT4U1!)
  if (systemConfig?.systemCode && 
      systemConfig.systemCode.length === 8 && 
      systemConfig.systemCode !== SIAE_SYSTEM_CODE_DEFAULT) {
    console.log(`[SIAE-UTILS] resolveSystemCodeSafe: using systemConfig.systemCode = ${systemConfig.systemCode}`);
    return { success: true, systemCode: systemConfig.systemCode, source: 'config' };
  }
  
  // FIX 2026-01-17: NON ritornare EVENT4U1! Causa errore SIAE 0600!
  console.error(`[SIAE-UTILS] resolveSystemCodeSafe: NESSUN CODICE SISTEMA VALIDO! Configurare in Impostazioni SIAE o collegare Smart Card.`);
  return { 
    success: false, 
    systemCode: null, 
    source: 'none',
    error: `Codice sistema SIAE non configurato. Il codice "${SIAE_SYSTEM_CODE_DEFAULT}" non è registrato presso SIAE e causerebbe errore 0600. Configurare un codice valido in Impostazioni SIAE oppure collegare una Smart Card attiva.`
  };
}

/**
 * LEGACY: Risolve il codice sistema SIAE (mantiene compatibilità con codice esistente)
 * 
 * ATTENZIONE: Questa funzione ritorna ancora EVENT4U1 come fallback per compatibilità.
 * Usare resolveSystemCodeSafe() per nuove implementazioni!
 * 
 * @deprecated Usare resolveSystemCodeSafe() che non ritorna codici invalidi
 */
export function resolveSystemCode(
  cachedEfff?: { systemId?: string } | null,
  systemConfig?: { systemCode?: string } | null
): string {
  // Priorità 1: Smart Card EFFF (codice ufficiale SIAE)
  if (cachedEfff?.systemId && cachedEfff.systemId.length === 8) {
    console.log(`[SIAE-UTILS] resolveSystemCode: using Smart Card EFFF systemId = ${cachedEfff.systemId}`);
    return cachedEfff.systemId;
  }
  
  // Priorità 2: Configurazione utente
  if (systemConfig?.systemCode && systemConfig.systemCode.length === 8) {
    console.log(`[SIAE-UTILS] resolveSystemCode: using systemConfig.systemCode = ${systemConfig.systemCode}`);
    return systemConfig.systemCode;
  }
  
  // Priorità 3: Default (DEPRECATO - causa errore 0600!)
  console.warn(`[SIAE-UTILS] resolveSystemCode: WARNING - using default ${SIAE_SYSTEM_CODE_DEFAULT} which is NOT registered with SIAE!`);
  return SIAE_SYSTEM_CODE_DEFAULT;
}

/**
 * FIX 2026-01-17: Risolve codice sistema per trasmissioni S/MIME (RCA)
 * 
 * Per trasmissioni firmate con S/MIME, SIAE verifica che il codice sistema nell'XML
 * corrisponda a quello registrato sulla Smart Card usata per la firma.
 * 
 * IMPORTANTE: Se la Smart Card ha un systemId, questo DEVE essere usato.
 * Usare un codice diverso (es. siaeConfig.systemCode) causa errore SIAE 0600:
 * "Nome del file contenente il riepilogo sbagliato"
 * 
 * @param cachedEfff - Dati EFFF dalla Smart Card (OBBLIGATORIO per S/MIME)
 * @param systemConfig - Configurazione SIAE dell'azienda (fallback)
 * @returns Oggetto con codice sistema e source, oppure errore
 */
export interface ResolveSystemCodeForSmimeResult {
  success: boolean;
  systemCode: string | null;
  source: 'smartcard' | 'config' | 'none';
  warning?: string;
  error?: string;
}

export function resolveSystemCodeForSmime(
  cachedEfff?: { systemId?: string } | null,
  systemConfig?: { systemCode?: string } | null
): ResolveSystemCodeForSmimeResult {
  // Per S/MIME, la Smart Card è OBBLIGATORIA
  if (!cachedEfff) {
    console.error(`[SIAE-UTILS] resolveSystemCodeForSmime: EFFF data non disponibile - Smart Card non connessa o non letta`);
    return {
      success: false,
      systemCode: null,
      source: 'none',
      error: 'SMART_CARD_REQUIRED: Per trasmissioni RCA (S/MIME) è necessario connettere una Smart Card SIAE. ' +
             'Il codice sistema deve provenire dalla carta usata per la firma digitale.'
    };
  }
  
  // Priorità 1: Smart Card EFFF (UNICO codice valido per S/MIME)
  if (cachedEfff.systemId && cachedEfff.systemId.length === 8) {
    console.log(`[SIAE-UTILS] resolveSystemCodeForSmime: using Smart Card EFFF systemId = ${cachedEfff.systemId}`);
    
    // Verifica coerenza con siaeConfig se configurato
    if (systemConfig?.systemCode && 
        systemConfig.systemCode.length === 8 && 
        systemConfig.systemCode !== cachedEfff.systemId) {
      console.warn(`[SIAE-UTILS] resolveSystemCodeForSmime: ATTENZIONE - siaeConfig.systemCode (${systemConfig.systemCode}) != Smart Card (${cachedEfff.systemId})`);
      console.warn(`[SIAE-UTILS] Per S/MIME verrà usato il codice dalla Smart Card. Aggiornare la configurazione se necessario.`);
      return { 
        success: true, 
        systemCode: cachedEfff.systemId, 
        source: 'smartcard',
        warning: `Configurazione SIAE (${systemConfig.systemCode}) diversa dalla Smart Card (${cachedEfff.systemId}). Usato codice Smart Card per evitare errore SIAE 0600.`
      };
    }
    
    return { success: true, systemCode: cachedEfff.systemId, source: 'smartcard' };
  }
  
  // Smart Card connessa ma senza systemId valido
  console.error(`[SIAE-UTILS] resolveSystemCodeForSmime: Smart Card connessa ma systemId non valido: "${cachedEfff.systemId || '(vuoto)'}"`);
  
  // NON usare siaeConfig come fallback per S/MIME - causa errore 0600!
  // L'XML userebbe siaeConfig.systemCode ma la firma S/MIME è fatta con la Smart Card che ha un codice diverso
  return {
    success: false,
    systemCode: null,
    source: 'none',
    error: `SMARTCARD_SYSTEMID_INVALID: La Smart Card non contiene un codice sistema valido (letto: "${cachedEfff.systemId || '(vuoto)'}"). ` +
           `Verificare che la carta sia inserita correttamente e che sia una carta SIAE di attivazione valida. ` +
           `Non è possibile usare il codice dalla configurazione (${systemConfig?.systemCode || 'non configurato'}) ` +
           `perché SIAE verificherebbe la firma contro il codice della Smart Card.`
  };
}

/**
 * Stati ticket che indicano annullamento/cancellazione per conteggi SIAE
 * Usare questa costante in tutto il sistema per coerenza
 */
export const SIAE_CANCELLED_STATUSES = [
  'cancelled',
  'annullato', 
  'refunded',
  'rimborsato',
  'voided',
  'annullato_rimborso',
  'annullato_rivendita',  // Secondary ticketing marketplace
  'annullato_cambio_nominativo'  // Name change - original ticket
] as const;

/**
 * Verifica se uno status indica un biglietto annullato
 */
export function isCancelledStatus(status: string | null | undefined): boolean {
  if (!status) return false;
  return SIAE_CANCELLED_STATUSES.includes(status.toLowerCase() as any);
}

/**
 * Normalizza codice genere SIAE a formato 2 cifre
 * I codici SIAE sono definiti nella tabella siae_event_genres e sono già validi.
 * Questa funzione si limita a normalizzare il formato (padding a 2 cifre).
 * 
 * Codici SIAE secondo Allegato A - Tabella 1 Provvedimento 23/07/2001:
 * - 01-04: Cinema
 * - 05-29: Sport
 * - 30-40: Giochi e scommesse (Intrattenimento)
 * - 41-44: Musei e gallerie
 * - 45-59: Teatro e concerti
 * - 60-69: Ballo e intrattenimento musicale (DISCOTECA = 61)
 * - 70-79: Fiere, mostre, parchi
 * 
 * IMPORTANTE: Per discoteche/club il codice corretto è 61 (Ballo con musica preregistrata)
 */
export function mapToSiaeTipoGenere(genreCode: string | null | undefined): string {
  if (!genreCode) return '61'; // Default: discoteca (ballo con musica preregistrata)
  
  const code = genreCode.trim();
  
  // Se è un codice numerico, normalizza a 2 cifre
  if (/^\d{1,2}$/.test(code)) {
    return code.padStart(2, '0');
  }
  
  // Se è già 2 cifre, ritorna così com'è
  if (/^\d{2}$/.test(code)) {
    return code;
  }
  
  // Per codici non numerici (legacy), usa default discoteca
  console.warn(`[SIAE] TipoGenere '${code}' non numerico, usando 61 (discoteca)`);
  return '61';
}

// ==================== EFFF Smart Card Data Structure ====================
// Conforme a Descrizione_contenuto_SmartCardTestxBA-V102.pdf

/**
 * Struttura dati file EFFF della Smart Card SIAE
 * Contiene 15 campi in record variabili (PKCS#11 DF 11 11)
 */
export interface SiaeCardEfffData {
  /** 1. Codice univoco del Sistema (8 char) - Pxxxxxxx per test, xxxxxxxx per produzione */
  systemId: string;
  /** 2. Nome del firmatario/richiedente (40 char) */
  contactName: string;
  /** 3. Cognome del firmatario/richiedente (40 char) */
  contactLastName: string;
  /** 4. Codice Fiscale del firmatario (18 char) */
  contactCodFis: string;
  /** 5. Ubicazione del sistema (100 char) */
  systemLocation: string;
  /** 6. Email associata al certificato digitale (50 char) */
  contactEmail: string;
  /** 7. Email server SIAE per invio report (40 char) - servertest2@batest.siae.it per test */
  siaeEmail: string;
  /** 8. Ragione sociale o Nome/Cognome titolare (60 char) */
  partnerName: string;
  /** 9. Codice Fiscale o P.IVA del titolare (18 char) */
  partnerCodFis: string;
  /** 10. Numero iscrizione REA (ex CCIAA) (18 char) */
  partnerRegistroImprese: string;
  /** 11. Nazione titolare ISO 3166 (2 char) - es: IT */
  partnerNation: string;
  /** 12. Num. protocollo delibera approvazione (20 char) */
  systemApprCode: string;
  /** 13. Data delibera approvazione (20 char) - formato libero */
  systemApprDate: string;
  /** 14. Tipo rappresentanza legale (1 char) - I/T/L/N/P */
  contactRepresentationType: 'I' | 'T' | 'L' | 'N' | 'P' | string;
  /** 15. Versione file dati utente (5 char) */
  userDataFileVersion: string;
}

/**
 * Verifica se il systemId indica una Smart Card di TEST
 * Le carte di test hanno systemId con pattern Pxxxxxxx (es: P0001234)
 * Le carte di produzione hanno pattern xxxxxxxx (es: 00001234)
 */
export function isTestSmartCard(systemId: string | null | undefined): boolean {
  if (!systemId) return true; // Default a test se non disponibile
  return systemId.toUpperCase().startsWith('P');
}

/**
 * Determina l'ambiente SIAE dalla Smart Card
 */
export function getSiaeEnvironment(systemId: string | null | undefined): 'test' | 'production' {
  return isTestSmartCard(systemId) ? 'test' : 'production';
}

/**
 * Restituisce l'email SIAE corretta in base all'ambiente
 */
export function getSiaeEmailForEnvironment(systemId: string | null | undefined): string {
  return isTestSmartCard(systemId) 
    ? 'servertest2@batest.siae.it' 
    : 'server@ba.siae.it'; // Email produzione (da verificare con SIAE)
}

// ==================== DTD Validation ====================

/**
 * Risultato validazione DTD
 */
export interface DtdValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Risultato validazione pre-trasmissione centralizzata
 * Unifica tutti i controlli preventivi SIAE
 */
export interface PreTransmissionValidationResult {
  canTransmit: boolean;
  errors: Array<{
    code: string;
    field: string;
    message: string;
    resolution?: string;
    siaeErrorCode?: string;
  }>;
  warnings: Array<{
    code: string;
    field: string;
    message: string;
    suggestion?: string;
    siaeErrorCode?: string;
  }>;
  details: {
    xmlValid: boolean;
    systemCodeConsistent: boolean;
    encodingValid: boolean;
    fieldLengthsValid: boolean;
    datesCoherent: boolean;
  };
}

/**
 * Verifica che l'XML contenga gli elementi obbligatori per il tipo di report
 * Validazione sintattica semplificata (non usa parser DTD completo)
 */
export function validateSiaeXml(xml: string, reportType: 'giornaliero' | 'mensile' | 'rca'): DtdValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  // Verifica dichiarazione XML
  if (!xml.startsWith('<?xml')) {
    errors.push('Dichiarazione XML mancante: <?xml version="1.0" encoding="UTF-8"?>');
  }
  
  // Verifica encoding UTF-8
  if (!xml.includes('encoding="UTF-8"') && !xml.includes("encoding='UTF-8'")) {
    warnings.push('Encoding UTF-8 non specificato esplicitamente');
  }
  
  // Verifica elemento radice corretto
  const rootElements: Record<string, string> = {
    'giornaliero': 'RiepilogoGiornaliero',
    'mensile': 'RiepilogoMensile',
    'rca': 'RiepilogoControlloAccessi'
  };
  
  const expectedRoot = rootElements[reportType];
  if (!xml.includes(`<${expectedRoot}`)) {
    errors.push(`Elemento radice mancante: <${expectedRoot}>`);
  }
  
  // Verifica attributi obbligatori per tipo report
  if (reportType === 'giornaliero') {
    if (!xml.includes('Data="')) {
      errors.push('Attributo Data mancante in RiepilogoGiornaliero');
    }
    // Verifica che NON contenga elementi solo mensili
    if (xml.includes('<ImponibileIntrattenimenti>')) {
      errors.push('ImponibileIntrattenimenti non ammesso in RiepilogoGiornaliero (solo mensile)');
    }
    if (xml.includes('<IVAEccedenteOmaggi>')) {
      errors.push('IVAEccedenteOmaggi non ammesso in RiepilogoGiornaliero (solo mensile)');
    }
  } else if (reportType === 'mensile') {
    if (!xml.includes('Mese="')) {
      errors.push('Attributo Mese mancante in RiepilogoMensile');
    }
  }
  
  // Verifica elementi obbligatori comuni
  const requiredElements = ['Titolare', 'Denominazione', 'CodiceFiscale'];
  for (const elem of requiredElements) {
    if (!xml.includes(`<${elem}>`)) {
      errors.push(`Elemento obbligatorio mancante: <${elem}>`);
    }
  }
  
  // Verifica attributi generazione
  if (!xml.includes('DataGenerazione="')) {
    errors.push('Attributo DataGenerazione mancante');
  }
  if (!xml.includes('OraGenerazione="')) {
    errors.push('Attributo OraGenerazione mancante');
  }
  if (!xml.includes('ProgressivoGenerazione="')) {
    errors.push('Attributo ProgressivoGenerazione mancante');
  }
  
  // Verifica caratteri non ammessi
  if (xml.includes('&') && !xml.includes('&amp;') && !xml.includes('&lt;') && !xml.includes('&gt;') && !xml.includes('&apos;') && !xml.includes('&quot;')) {
    warnings.push('Possibile carattere & non escaped correttamente');
  }
  
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Validazione specifica per RiepilogoControlloAccessi (C1 report)
 * Conforme a RiepilogoControlloAccessi_v0100_20080201.dtd
 */
export interface C1ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
  summary: {
    ticketsCount: number;
    totalAmount: number;
    hasEvents: boolean;
    hasTitolare: boolean;
    systemCode: string | null;
    taxId: string | null;
  };
}

export function validateC1Report(xml: string): C1ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];
  const summary = {
    ticketsCount: 0,
    totalAmount: 0,
    hasEvents: false,
    hasTitolare: false,
    systemCode: null as string | null,
    taxId: null as string | null,
  };
  
  // 1. Verifica dichiarazione XML
  if (!xml.startsWith('<?xml')) {
    errors.push('Dichiarazione XML mancante');
  }
  
  // Detect report format: LogTransazione, RiepilogoControlloAccessi, RiepilogoGiornaliero, RiepilogoMensile
  const isLog = xml.includes('<LogTransazione');
  const isRCA = xml.includes('<RiepilogoControlloAccessi');
  const isRG = xml.includes('<RiepilogoGiornaliero');
  const isRM = xml.includes('<RiepilogoMensile');
  
  if (!isLog && !isRCA && !isRG && !isRM) {
    errors.push('Elemento radice mancante (atteso LogTransazione, RiepilogoControlloAccessi, RiepilogoGiornaliero o RiepilogoMensile)');
  }
  
  // Validate based on format
  if (isLog) {
    // ============ LogTransazione format (C1 evento) ============
    // Conforme a Log_v0040_20190627.dtd
    
    if (!xml.includes('<!DOCTYPE LogTransazione')) {
      warnings.push('DOCTYPE LogTransazione mancante');
    }
    
    // Verifica presenza di almeno una Transazione
    const transactionCount = (xml.match(/<Transazione\s/g) || []).length;
    if (transactionCount === 0) {
      errors.push('Nessuna Transazione trovata nel LogTransazione');
    } else {
      summary.ticketsCount = transactionCount;
      summary.hasEvents = true;
    }
    
    // Verifica attributi obbligatori nelle Transazioni
    const requiredAttrs = ['CFOrganizzatore', 'CFTitolare', 'SistemaEmissione', 'CartaAttivazione', 
                          'SigilloFiscale', 'DataEmissione', 'OraEmissione', 'NumeroProgressivo',
                          'TipoTitolo', 'CodiceOrdine', 'CodiceRichiedenteEmissioneSigillo'];
    for (const attr of requiredAttrs) {
      if (!xml.includes(`${attr}="`)) {
        errors.push(`Attributo obbligatorio mancante: ${attr}`);
      }
    }
    
    // Estrai informazioni dal primo CFTitolare trovato
    const cfMatch = xml.match(/CFTitolare="([^"]+)"/);
    if (cfMatch) {
      summary.taxId = cfMatch[1];
      summary.hasTitolare = true;
    }
    
    const sysMatch = xml.match(/SistemaEmissione="([^"]+)"/);
    if (sysMatch) {
      summary.systemCode = sysMatch[1];
    }
    
    // Somma importi CorrispettivoLordo (in centesimi)
    const corrMatches = Array.from(xml.matchAll(/<CorrispettivoLordo>(\d+)<\/CorrispettivoLordo>/g));
    for (const match of corrMatches) {
      summary.totalAmount += parseInt(match[1], 10);
    }
    
    // Verifica elementi TitoloAccesso
    if (!xml.includes('<TitoloAccesso')) {
      errors.push('Nessun elemento TitoloAccesso trovato');
    }
    
    // Verifica chiusura
    if (!xml.includes('</LogTransazione>')) {
      errors.push('Chiusura elemento LogTransazione mancante');
    }
    
  } else if (isRCA) {
    // ============ RiepilogoControlloAccessi format ============
    if (!xml.includes('<!DOCTYPE RiepilogoControlloAccessi')) {
      warnings.push('DOCTYPE RiepilogoControlloAccessi mancante');
    }
    
    // Verifica sezione Titolare (formato RCA)
    if (xml.includes('<Titolare>')) {
      summary.hasTitolare = true;
      
      const cfMatch = xml.match(/<CFTitolareCA>([^<]+)<\/CFTitolareCA>/);
      if (cfMatch) {
        summary.taxId = cfMatch[1];
        if (cfMatch[1].length !== 16 && cfMatch[1].length !== 11) {
          errors.push(`Codice Fiscale non valido (${cfMatch[1].length} caratteri, attesi 16 o 11)`);
        }
      } else {
        errors.push('CFTitolareCA mancante - Codice Fiscale obbligatorio');
      }
      
      const codeMatch = xml.match(/<CodiceSistemaCA>([^<]+)<\/CodiceSistemaCA>/);
      if (codeMatch) {
        summary.systemCode = codeMatch[1];
      } else {
        errors.push('CodiceSistemaCA mancante - Codice Sistema obbligatorio');
      }
      
      if (!xml.includes('<DenominazioneTitolareCA>')) {
        errors.push('DenominazioneTitolareCA mancante');
      }
      if (!xml.includes('<DataRiepilogo>')) {
        errors.push('DataRiepilogo mancante');
      }
      if (!xml.includes('<ProgressivoRiepilogo>')) {
        errors.push('ProgressivoRiepilogo mancante');
      }
    } else {
      errors.push('Sezione Titolare mancante - obbligatoria');
    }
    
    // Verifica evento (formato RCA)
    if (xml.includes('<Evento>')) {
      summary.hasEvents = true;
      const rcaEventRequired = ['CFOrganizzatore', 'DenominazioneOrganizzatore', 'TipologiaOrganizzatore', 
                                'DenominazioneLocale', 'CodiceLocale', 'DataEvento', 'OraEvento', 'TipoGenere'];
      for (const field of rcaEventRequired) {
        if (!xml.includes(`<${field}>`)) {
          errors.push(`Campo evento obbligatorio mancante: ${field}`);
        }
      }
    } else {
      warnings.push('Nessun evento trovato nel report');
    }
    
    if (!xml.includes('</RiepilogoControlloAccessi>')) {
      errors.push('Chiusura elemento RiepilogoControlloAccessi mancante');
    }
    
  } else if (isRG || isRM) {
    // ============ RiepilogoGiornaliero / RiepilogoMensile format ============
    const rootTag = isRG ? 'RiepilogoGiornaliero' : 'RiepilogoMensile';
    
    // Verifica sezione Titolare (formato RG/RM)
    if (xml.includes('<Titolare>')) {
      summary.hasTitolare = true;
      
      // In RG/RM format uses <CodiceFiscale> and <SistemaEmissione>
      const cfMatch = xml.match(/<Titolare>[^]*?<CodiceFiscale>([^<]+)<\/CodiceFiscale>/);
      if (cfMatch) {
        summary.taxId = cfMatch[1];
        if (cfMatch[1].length !== 16 && cfMatch[1].length !== 11) {
          errors.push(`Codice Fiscale non valido (${cfMatch[1].length} caratteri, attesi 16 o 11)`);
        }
      } else {
        errors.push('CodiceFiscale in Titolare mancante');
      }
      
      const codeMatch = xml.match(/<Titolare>[^]*?<SistemaEmissione>([^<]+)<\/SistemaEmissione>/);
      if (codeMatch) {
        summary.systemCode = codeMatch[1];
      } else {
        errors.push('SistemaEmissione in Titolare mancante');
      }
      
      if (!/<Titolare>[^]*?<Denominazione>/.test(xml)) {
        errors.push('Denominazione in Titolare mancante');
      }
    } else {
      errors.push('Sezione Titolare mancante - obbligatoria');
    }
    
    // Verifica Organizzatore
    if (xml.includes('<Organizzatore>')) {
      const orgRequired = ['Denominazione', 'CodiceFiscale', 'TipoOrganizzatore'];
      for (const field of orgRequired) {
        const regex = new RegExp(`<Organizzatore>[^]*?<${field}>`);
        if (!regex.test(xml)) {
          warnings.push(`Campo Organizzatore mancante: ${field}`);
        }
      }
    }
    
    // Verifica evento (formato RG/RM)
    if (xml.includes('<Evento>')) {
      summary.hasEvents = true;
      const rgEventRequired = ['Denominazione', 'CodiceLocale', 'DataEvento', 'OraEvento'];
      for (const field of rgEventRequired) {
        if (!xml.includes(`<${field}>`)) {
          warnings.push(`Campo evento mancante: ${field}`);
        }
      }
      
      // Conta biglietti da Quantita in TitoliEmessi
      const quantitaMatches = Array.from(xml.matchAll(/<TitoliEmessi>[^]*?<Quantita>(\d+)<\/Quantita>/g));
      for (const match of quantitaMatches) {
        summary.ticketsCount += parseInt(match[1], 10);
      }
      
      // Somma importi da CorrispettivoLordo
      const corrMatchesRG = Array.from(xml.matchAll(/<CorrispettivoLordo>(\d+)<\/CorrispettivoLordo>/g));
      for (const match of corrMatchesRG) {
        summary.totalAmount += parseInt(match[1], 10);
      }
    } else {
      // FIX 2026-01-18: Per report giornaliero (RMG), 0 biglietti è permesso (solo warning)
      // Per report mensile (RPM), rimane un errore bloccante
      if (isRG) {
        warnings.push('Nessun evento trovato nel report giornaliero (RMG con 0 biglietti)');
      } else {
        errors.push('SIAE_NO_EVENTS: Nessun elemento <Evento> trovato. Il report C1 mensile richiede almeno un evento con biglietti emessi.');
      }
    }
    
    if (!xml.includes(`</${rootTag}>`)) {
      errors.push(`Chiusura elemento ${rootTag} mancante`);
    }
  }
  
  // Verifica caratteri XML validi (comune)
  const invalidChars = xml.match(/[^\x09\x0A\x0D\x20-\uD7FF\uE000-\uFFFD]/g);
  if (invalidChars && invalidChars.length > 0) {
    errors.push(`Caratteri XML non validi trovati: ${invalidChars.slice(0, 5).join(', ')}`);
  }
  
  return {
    valid: errors.length === 0,
    errors,
    warnings,
    summary
  };
}

// ==================== Log.xsi Response Parser ====================
// Conforme a Log_v0040_20190627.dtd

/**
 * Singola transazione dal Log SIAE
 */
export interface SiaeLogTransaction {
  cfOrganizzatore: string;
  cfTitolare: string;
  ivaPreassolta: 'N' | 'B' | 'F';
  tipoTassazione: 'S' | 'I';
  valuta: 'E' | 'L';
  sistemaEmissione: string;
  cartaAttivazione: string;
  sigilloFiscale: string;
  dataEmissione: string;
  oraEmissione: string;
  numeroProgressivo: string;
  tipoTitolo: string;
  codiceOrdine: string;
  causale?: string;
  posto?: string;
  codiceRichiedenteEmissioneSigillo: string;
  prestampa?: string;
  imponibileIntrattenimenti?: string;
  originaleAnnullato?: string;
  cartaOriginaleAnnullato?: string;
  causaleAnnullamento?: string;
  // Dati TitoloAccesso
  titoloAccesso?: {
    annullamento: boolean;
    corrispettivoLordo?: number;
    prevendita?: number;
    ivaCorrispettivo?: number;
    ivaPrevendita?: number;
    importoFigurativo?: number;
    ivaFigurativa?: number;
    codiceLocale: string;
    dataEvento: string;
    oraEvento: string;
    tipoGenere: string;
    titolo: string;
  };
  // Dati Abbonamento
  abbonamento?: {
    annullamento: boolean;
    codiceAbbonamento: string;
    progressivoAbbonamento: string;
    turno: 'F' | 'L';
    quantitaEventiAbilitati: number;
    validita: string;
    rateo: number;
    rateoIntrattenimenti: number;
    rateoIva: number;
  };
}

/**
 * Risultato parsing Log SIAE
 */
export interface SiaeLogParseResult {
  success: boolean;
  transactions: SiaeLogTransaction[];
  totalTransactions: number;
  errors: string[];
}

/**
 * Parser semplificato per Log.xsi SIAE
 * Estrae le transazioni dal LogTransazione XML
 */
export function parseSiaeLogXml(xml: string): SiaeLogParseResult {
  const errors: string[] = [];
  const transactions: SiaeLogTransaction[] = [];
  
  try {
    // Verifica elemento radice
    if (!xml.includes('<LogTransazione')) {
      return {
        success: false,
        transactions: [],
        totalTransactions: 0,
        errors: ['Elemento LogTransazione non trovato - non è un Log SIAE valido']
      };
    }
    
    // Estrai tutte le transazioni con regex (parser semplificato)
    const transactionRegex = /<Transazione([^>]*)>([\s\S]*?)<\/Transazione>/g;
    let match;
    
    while ((match = transactionRegex.exec(xml)) !== null) {
      const attrs = match[1];
      const content = match[2];
      
      // Estrai attributi obbligatori
      const extractAttr = (name: string): string => {
        const attrMatch = attrs.match(new RegExp(`${name}="([^"]*)"`));
        return attrMatch ? attrMatch[1] : '';
      };
      
      // Estrai elementi figli
      const extractElement = (name: string): string | undefined => {
        const elemMatch = content.match(new RegExp(`<${name}>([^<]*)<\/${name}>`));
        return elemMatch ? elemMatch[1] : undefined;
      };
      
      const transaction: SiaeLogTransaction = {
        cfOrganizzatore: extractAttr('CFOrganizzatore'),
        cfTitolare: extractAttr('CFTitolare'),
        ivaPreassolta: extractAttr('IVAPreassolta') as 'N' | 'B' | 'F',
        tipoTassazione: extractAttr('TipoTassazione') as 'S' | 'I',
        valuta: (extractAttr('Valuta') || 'E') as 'E' | 'L',
        sistemaEmissione: extractAttr('SistemaEmissione'),
        cartaAttivazione: extractAttr('CartaAttivazione'),
        sigilloFiscale: extractAttr('SigilloFiscale'),
        dataEmissione: extractAttr('DataEmissione'),
        oraEmissione: extractAttr('OraEmissione'),
        numeroProgressivo: extractAttr('NumeroProgressivo'),
        tipoTitolo: extractAttr('TipoTitolo'),
        codiceOrdine: extractAttr('CodiceOrdine'),
        causale: extractAttr('Causale') || undefined,
        posto: extractAttr('Posto') || undefined,
        codiceRichiedenteEmissioneSigillo: extractAttr('CodiceRichiedenteEmissioneSigillo'),
        prestampa: extractAttr('Prestampa') || undefined,
        imponibileIntrattenimenti: extractAttr('ImponibileIntrattenimenti') || undefined,
        originaleAnnullato: extractAttr('OriginaleAnnullato') || undefined,
        cartaOriginaleAnnullato: extractAttr('CartaOriginaleAnnullato') || undefined,
        causaleAnnullamento: extractAttr('CausaleAnnullamento') || undefined,
      };
      
      // Estrai TitoloAccesso se presente
      if (content.includes('<TitoloAccesso')) {
        const taMatch = content.match(/<TitoloAccesso([^>]*)>([\s\S]*?)<\/TitoloAccesso>/);
        if (taMatch) {
          const taAttrs = taMatch[1];
          const taContent = taMatch[2];
          const annullamento = taAttrs.includes('Annullamento="S"');
          
          transaction.titoloAccesso = {
            annullamento,
            corrispettivoLordo: parseInt(extractElement('CorrispettivoLordo') || '0'),
            prevendita: parseInt(extractElement('Prevendita') || '0'),
            ivaCorrispettivo: parseInt(extractElement('IVACorrispettivo') || '0'),
            ivaPrevendita: parseInt(extractElement('IVAPrevendita') || '0'),
            importoFigurativo: parseInt(extractElement('ImportoFigurativo') || '0'),
            ivaFigurativa: parseInt(extractElement('IVAFigurativa') || '0'),
            codiceLocale: extractElement('CodiceLocale') || '',
            dataEvento: extractElement('DataEvento') || '',
            oraEvento: extractElement('OraEvento') || '',
            tipoGenere: extractElement('TipoGenere') || '',
            titolo: extractElement('Titolo') || '',
          };
        }
      }
      
      transactions.push(transaction);
    }
    
    return {
      success: true,
      transactions,
      totalTransactions: transactions.length,
      errors
    };
    
  } catch (error: any) {
    return {
      success: false,
      transactions: [],
      totalTransactions: 0,
      errors: [`Errore parsing Log XML: ${error.message}`]
    };
  }
}

/**
 * Analizza il Log SIAE per estrarre statistiche
 */
export interface SiaeLogStats {
  totalTransactions: number;
  ticketsEmitted: number;
  ticketsCancelled: number;
  subscriptionsEmitted: number;
  subscriptionsCancelled: number;
  totalGrossAmount: number;
  totalVat: number;
  byTipoTitolo: Record<string, number>;
  byOrganizer: Record<string, number>;
}

export function analyzeSiaeLog(result: SiaeLogParseResult): SiaeLogStats {
  const stats: SiaeLogStats = {
    totalTransactions: result.totalTransactions,
    ticketsEmitted: 0,
    ticketsCancelled: 0,
    subscriptionsEmitted: 0,
    subscriptionsCancelled: 0,
    totalGrossAmount: 0,
    totalVat: 0,
    byTipoTitolo: {},
    byOrganizer: {}
  };
  
  for (const tx of result.transactions) {
    // Conteggio per tipo titolo
    stats.byTipoTitolo[tx.tipoTitolo] = (stats.byTipoTitolo[tx.tipoTitolo] || 0) + 1;
    
    // Conteggio per organizzatore
    stats.byOrganizer[tx.cfOrganizzatore] = (stats.byOrganizer[tx.cfOrganizzatore] || 0) + 1;
    
    if (tx.titoloAccesso) {
      if (tx.titoloAccesso.annullamento) {
        stats.ticketsCancelled++;
      } else {
        stats.ticketsEmitted++;
        stats.totalGrossAmount += tx.titoloAccesso.corrispettivoLordo || 0;
        stats.totalVat += tx.titoloAccesso.ivaCorrispettivo || 0;
      }
    }
    
    if (tx.abbonamento) {
      if (tx.abbonamento.annullamento) {
        stats.subscriptionsCancelled++;
      } else {
        stats.subscriptionsEmitted++;
      }
    }
  }
  
  return stats;
}

// ==================== RiepilogoControlloAccessi XML Generation ====================
// Conforme a RiepilogoControlloAccessi_v0100_20080201.dtd per trasmissione a SIAE
// Allegato B - Provvedimento Agenzia delle Entrate 04/03/2008

/**
 * Parametri per generazione RiepilogoControlloAccessi XML
 */
export interface RCAParams {
  companyId: string;
  eventId: string;
  event: SiaeEventForLog;
  tickets: SiaeTicketForLog[];
  sectors?: { code: string; name: string; capacity: number }[];
  systemConfig: {
    systemCode?: string;
    taxId?: string;
    businessName?: string;
  };
  companyName: string;
  taxId: string;
  progressivo?: number;
  venueName?: string;
  author?: string;
  performer?: string;
  forceSubstitution?: boolean; // Forza Sostituzione="S" per reinvio report già elaborati (errore 40604)
}

/**
 * Risultato generazione RiepilogoControlloAccessi XML
 * FIX 2026-01-18: Aggiunti campi autoritativi per allineamento resend
 */
export interface RCAResult {
  success: boolean;
  xml: string;
  ticketCount: number;           // Totale biglietti processati
  cancelledCount: number;        // Biglietti annullati (isCancelledStatus + replaced)
  totalGrossAmount: number;      // Totale lordo TUTTI i biglietti
  activeGrossAmount: number;     // Totale lordo solo biglietti attivi
  sectorSummaries: RCASectorSummary[];
  errors: string[];
  warnings: string[];
}

/**
 * Riepilogo per settore/tipo titolo
 */
export interface RCASectorSummary {
  ordinePosto: string;
  tipoTitolo: string;
  capienza: number;
  totaleLTA: number;
  noAccessoTradiz: number;
  automatizzatiTradiz: number;
  manualiTradiz: number;
  annullatiTradiz: number;
}

/**
 * Mappa OrdinePosto interno a codice SIAE (2 caratteri)
 * Allegato B - OrdinePosto
 * PL=Platea, GA=Galleria, PA=Palco, AN=Anello, etc.
 */
export function normalizeOrdinePosto(sectorCode: string | null | undefined): string {
  if (!sectorCode) return 'PL';
  
  const code = sectorCode.toUpperCase().trim();
  
  // Se già in formato corretto (2 lettere)
  if (/^[A-Z]{2}$/.test(code)) {
    return code;
  }
  
  // Mappature comuni
  const mappings: Record<string, string> = {
    'PLATEA': 'PL',
    'GALLERIA': 'GA',
    'PALCO': 'PA',
    'LOGGIONE': 'LO',
    'BALCONATA': 'BA',
    'PARTERRE': 'PT',
    'TRIBUNA': 'TR',
    'ANELLO': 'AN',
    'CURVA': 'CU',
    'PRATO': 'PR',
    'VIP': 'VI',
    'A0': 'PL',
    'A1': 'PL',
    'B0': 'GA',
    'B1': 'GA',
    'P0': 'PL',
    'P1': 'PL',
  };
  
  return mappings[code] || 'PL';
}

/**
 * Mappa TipoTitolo interno a codice SIAE per RCA (2 caratteri)
 * Allegato B - TipoTitolo per RiepilogoControlloAccessi
 * 
 * NOTA: I codici SIAE ufficiali sono R1, R2, I1, I2, O1, etc. (da tabella 3 LTA)
 * R1 = Ridotto tipo 1, I1 = Intero tipo 1, O1 = Omaggio tipo 1
 * 
 * Manteniamo i codici originali se già conformi al formato SIAE
 */
export function normalizeRCATipoTitolo(ticketTypeCode: string | null | undefined, isComplimentary?: boolean): string {
  if (isComplimentary) return 'O1'; // Omaggio tipo 1
  if (!ticketTypeCode) return 'I1'; // Intero tipo 1 (default)
  
  const code = ticketTypeCode.toUpperCase().trim();
  
  // Se già in formato SIAE (lettera + cifra), usa direttamente
  if (/^[RIO][0-9]$/.test(code)) {
    return code;
  }
  
  const mappings: Record<string, string> = {
    'R1': 'R1',
    'R2': 'R2',
    'I1': 'I1',
    'I2': 'I2',
    'O1': 'O1',
    'ABB': 'I1', // Abbonamento -> trattato come Intero per RCA
    'INTERO': 'I1',
    'RIDOTTO': 'R1',
    'OMAGGIO': 'O1',
    'ABBONAMENTO': 'I1',
    'FULL': 'I1',
    'STANDARD': 'I1',
    'REDUCED': 'R1',
    'FREE': 'O1',
    'COMPLIMENTARY': 'O1',
    'IN': 'I1',
    'RI': 'R1',
    'OM': 'O1',
    'AB': 'I1',
  };
  
  return mappings[code] || 'I1'; // Default: Intero tipo 1
}

/**
 * Genera XML conforme al DTD ControlloAccessi_v0001_20080626.dtd per trasmissione a SIAE
 * 
 * Struttura ufficiale (conforme al DTD):
 * - RiepilogoControlloAccessi (con attributo Sostituzione="N"|"S")
 *   - Titolare: dati del titolare del sistema (ordine elementi specifico!)
 *   - Evento+: uno o più eventi (non AnagraficaEvento!)
 *     - SistemaEmissione+: sistemi che hanno emesso biglietti
 *       - Titoli*: raggruppati per CodiceOrdinePosto (settore)
 *         - TotaleTipoTitolo+: statistiche per tipo titolo (R1, R2, O1, etc.)
 *       - Abbonamenti*: simile a Titoli, per abbonamenti
 * 
 * IMPORTANTE: Questo formato è richiesto per SIAE (Allegato B Provvedimento 04/03/2008)
 * Il formato LogTransazione genera errore 40605 "Il riepilogo risulta illegibile"
 * 
 * Riferimenti:
 * - DTD: ControlloAccessi_v0001_20080626.dtd
 * - Esempio: RCA_2015_09_22_001.xml
 * 
 * @param params - Parametri per la generazione del RCA
 * @returns Oggetto con XML generato, conteggio biglietti e eventuali errori
 */
export function generateRCAXml(params: RCAParams): RCAResult {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  const { event, tickets, sectors, systemConfig, companyName, taxId, progressivo = 1, venueName, author, performer, forceSubstitution = false } = params;
  
  // Validazione parametri obbligatori
  // FIX 2026-01-18: Early return con tutti i campi dell'interfaccia RCAResult
  // NOTA: Clona gli array errors/warnings per evitare condivisione di stato tra chiamate
  const emptyResult = (): RCAResult => ({
    success: false, xml: '', ticketCount: 0, cancelledCount: 0,
    totalGrossAmount: 0, activeGrossAmount: 0, sectorSummaries: [], 
    errors: [...errors], warnings: [...warnings]
  });
  
  if (!event) {
    errors.push('Evento obbligatorio per generazione RiepilogoControlloAccessi');
    return emptyResult();
  }
  
  if (!taxId || taxId.length < 11) {
    errors.push('Codice Fiscale Titolare obbligatorio (11-16 caratteri)');
    return emptyResult();
  }
  
  // FIX 2026-01-17: Validazione codice sistema PRIMA di generare XML
  // Blocca la generazione se il codice sistema non è valido (previene errore 0600)
  const systemCodeResult = resolveSystemCodeSafe(null, systemConfig);
  if (!systemCodeResult.success || !systemCodeResult.systemCode) {
    errors.push(systemCodeResult.error || 'Codice sistema SIAE non configurato - impossibile generare report');
    return emptyResult();
  }
  const sistemaEmissione = systemCodeResult.systemCode;
  const cfTitolare = taxId.toUpperCase().substring(0, 16);
  const cfOrganizzatore = (event.organizerTaxId || taxId).toUpperCase().substring(0, 16);
  // PRIORITÀ: systemConfig.businessName > companyName (fix warning 2606)
  const denominazioneTitolare = escapeXml((systemConfig?.businessName || companyName || 'N/D').substring(0, 60));
  const denominazioneOrganizzatore = escapeXml((event.organizerName || systemConfig?.businessName || companyName || 'N/D').substring(0, 60));
  
  // Date/time evento (usato anche per DataRiepilogo - DEVE coincidere con nome file!)
  const eventDate = typeof event.date === 'string' ? new Date(event.date) : event.date;
  const dataEvento = formatSiaeDateCompact(eventDate);
  
  // FIX 2026-01-07: DataRiepilogo DEVE essere uguale alla data nel nome file!
  // SIAE Error 40603: "Le date dell'oggetto, del nome file, e del contenuto del riepilogo non sono coerenti"
  // Il nome file usa eventDate (es: RCA_2025_12_17_001.xsi), quindi DataRiepilogo deve essere 20251217
  const now = new Date();
  const dataRiepilogo = formatSiaeDateCompact(eventDate); // USA eventDate, NON now!
  const dataGenerazione = formatSiaeDateCompact(now);
  const oraGenerazione = formatSiaeTimeCompact(now);
  let eventTimeValue: Date;
  if (event.time) {
    eventTimeValue = typeof event.time === 'string' ? new Date(event.time) : event.time;
  } else {
    eventTimeValue = eventDate;
  }
  const oraEvento = formatSiaeTimeHHMM(eventTimeValue);
  
  // Codici evento
  const codiceLocale = (event.venueCode || '0000000000001').padStart(13, '0').substring(0, 13);
  // Usa mappatura centralizzata per TipoGenere SIAE (fix error 2101)
  const tipoGenere = mapToSiaeTipoGenere(event.genreCode);
  const titoloEvento = escapeXml((event.name || 'Evento').substring(0, 100));
  const nomeLocale = escapeXml((venueName || event.name || 'Locale').substring(0, 100));
  
  // Per tipoGenere Intrattenimento, Autore/Esecutore/NazionalitaFilm NON devono essere presenti
  // SIAE Warning 2108/2110/2112/2114: OMETTERE completamente i tag, non usare '-'
  // Codici Intrattenimento: 30-40 (giochi), 60-69 (ballo/discoteca), 70-74 (fiere/mostre), 79 (luna park)
  // Codici Cinema (01-04): richiedono NazionalitaFilm (ISO 3166)
  // Codici Teatro/Concerti (45-59): richiedono Autore ed Esecutore
  const genreNum = parseInt(tipoGenere);
  const isIntrattenimento = (genreNum >= 30 && genreNum <= 40) || 
                            (genreNum >= 60 && genreNum <= 69) || 
                            (genreNum >= 70 && genreNum <= 74) || 
                            genreNum === 79;
  const isCinema = genreNum >= 1 && genreNum <= 4;
  const isTeatroConcerti = genreNum >= 45 && genreNum <= 59;
  
  // Genera valori solo se necessari (verranno inclusi condizionalmente nell'XML)
  const autore = isTeatroConcerti ? escapeXml((author || event.name || 'N/D').substring(0, 100)) : null;
  const esecutore = isTeatroConcerti ? escapeXml((performer || event.organizerName || companyName || 'N/D').substring(0, 100)) : null;
  const nazionalitaFilm = isCinema ? 'IT' : null;
  
  // SpettacoloIntrattenimento: S=spettacolo, I=intrattenimento (default S)
  const spettacoloIntrattenimento = event.tipoTassazione === 'I' ? 'I' : 'S';
  
  // IncidenzaIntrattenimento: percentuale 0-100 (solo per intrattenimento)
  const incidenzaIntrattenimento = spettacoloIntrattenimento === 'I' ? '50' : '0';
  
  // TipologiaOrganizzatore: G=Generico, E=Esercizio, P=Parrocchiale
  const tipologiaOrganizzatore = 'G';
  
  // ==================== Aggregazione biglietti per settore/tipo ====================
  // Struttura: Map<settore, Map<tipoTitolo, contatori>>
  interface TicketCounters {
    totaleLTA: number;
    noAccessoTradiz: number;
    noAccessoDigitali: number;
    automatizzatiTradiz: number;
    automatizzatiDigitali: number;
    manualiTradiz: number;
    manualiDigitali: number;
    annullatiTradiz: number;
    annullatiDigitali: number;
  }
  
  interface SectorData {
    codiceOrdinePosto: string;
    capienza: number;
    tipoTitoli: Map<string, TicketCounters>;
  }
  
  const sectorMap = new Map<string, SectorData>();
  
  // Calcola capienza per settore dai dati sectors
  const sectorCapacity = new Map<string, number>();
  if (sectors && sectors.length > 0) {
    for (const sector of sectors) {
      const code = normalizeCodiceOrdinePosto(sector.code);
      sectorCapacity.set(code, (sectorCapacity.get(code) || 0) + sector.capacity);
    }
  }
  
  // FIX 2026-01-18: Calcola valori autoritativi durante l'iterazione
  // Questi valori verranno usati per i metadati della trasmissione (allineamento resend)
  let totalCancelledCount = 0;
  let totalGrossAmount = 0;
  let activeGrossAmount = 0;
  
  // Aggrega biglietti per settore → tipo titolo
  for (const ticket of tickets) {
    const codiceOrdinePosto = normalizeCodiceOrdinePosto(ticket.sectorCode);
    const tipoTitolo = normalizeSiaeTipoTitolo(ticket.ticketTypeCode, ticket.isComplimentary);
    
    // Calcola valori autoritativi per ogni biglietto
    const grossAmount = parseFloat(String(ticket.grossAmount || '0'));
    totalGrossAmount += grossAmount;
    
    // Crea settore se non esiste
    if (!sectorMap.has(codiceOrdinePosto)) {
      sectorMap.set(codiceOrdinePosto, {
        codiceOrdinePosto,
        capienza: sectorCapacity.get(codiceOrdinePosto) || 1000,
        tipoTitoli: new Map()
      });
    }
    
    const sector = sectorMap.get(codiceOrdinePosto)!;
    
    // Crea tipo titolo se non esiste
    if (!sector.tipoTitoli.has(tipoTitolo)) {
      sector.tipoTitoli.set(tipoTitolo, {
        totaleLTA: 0,
        noAccessoTradiz: 0,
        noAccessoDigitali: 0,
        automatizzatiTradiz: 0,
        automatizzatiDigitali: 0,
        manualiTradiz: 0,
        manualiDigitali: 0,
        annullatiTradiz: 0,
        annullatiDigitali: 0,
      });
    }
    
    const counters = sector.tipoTitoli.get(tipoTitolo)!;
    counters.totaleLTA++;
    
    // Mappa status a contatori (usiamo solo Tradiz - tradizionale)
    const status = (ticket.status || '').toLowerCase();
    
    // FIX 2026-01-18: Traccia annullati con isCancelledStatus + replacedByTicketId
    // Un biglietto è annullato se ha status annullato OPPURE è stato sostituito
    const isCancelled = isCancelledStatus(status) || !!(ticket as any).replacedByTicketId;
    
    if (isCancelled) {
      counters.annullatiTradiz++;
      totalCancelledCount++;
    } else if (status === 'validated' || status === 'used' || status === 'usato' || status === 'checked_in') {
      activeGrossAmount += grossAmount;
      const isManual = (ticket as any).manualCheckin === true;
      if (isManual) {
        counters.manualiTradiz++;
      } else {
        counters.automatizzatiTradiz++;
      }
    } else {
      // Non annullato e non validato = no accesso
      activeGrossAmount += grossAmount;
      counters.noAccessoTradiz++;
    }
  }
  
  // Se non ci sono settori, crea uno di default
  if (sectorMap.size === 0) {
    sectorMap.set('UN', {
      codiceOrdinePosto: 'UN',
      capienza: 1000,
      tipoTitoli: new Map([['R1', {
        totaleLTA: 0,
        noAccessoTradiz: 0,
        noAccessoDigitali: 0,
        automatizzatiTradiz: 0,
        automatizzatiDigitali: 0,
        manualiTradiz: 0,
        manualiDigitali: 0,
        annullatiTradiz: 0,
        annullatiDigitali: 0,
      }]])
    });
    warnings.push('Nessun biglietto trovato, generato riepilogo vuoto');
  }
  
  // Crea sectorSummaries per compatibilità con interfaccia di ritorno
  const sectorSummaries: RCASectorSummary[] = [];
  for (const [, sector] of Array.from(sectorMap)) {
    for (const [tipoTitolo, counters] of Array.from(sector.tipoTitoli)) {
      sectorSummaries.push({
        ordinePosto: sector.codiceOrdinePosto,
        tipoTitolo,
        capienza: sector.capienza,
        totaleLTA: counters.totaleLTA,
        noAccessoTradiz: counters.noAccessoTradiz,
        automatizzatiTradiz: counters.automatizzatiTradiz,
        manualiTradiz: counters.manualiTradiz,
        annullatiTradiz: counters.annullatiTradiz,
      });
    }
  }
  
  // ==================== Generazione XML conforme a DTD ====================
  const xmlLines: string[] = [];
  
  // Intestazione XML con encoding ISO-8859-1 come richiesto da SIAE (Allegato C)
  // IMPORTANTE: SIAE richiede Latin-1, non UTF-8
  xmlLines.push('<?xml version="1.0" encoding="ISO-8859-1"?>');
  
  // DOCTYPE obbligatorio per validazione DTD SIAE
  // Riferimento: ControlloAccessi_v0001_20080626.dtd
  xmlLines.push('<!DOCTYPE RiepilogoControlloAccessi SYSTEM "ControlloAccessi_v0001_20080626.dtd">');
  
  // Root element con attributo Sostituzione OBBLIGATORIO
  // Se forceSubstitution=true, usa "S" per reinviare report già elaborati (errore 40604)
  const sostituzioneValue = forceSubstitution ? 'S' : 'N';
  xmlLines.push(`<RiepilogoControlloAccessi Sostituzione="${sostituzioneValue}">`);
  
  if (forceSubstitution) {
    warnings.push('Sostituzione forzata: il report sostituirà quello precedentemente elaborato');
  }
  
  // ==================== Titolare ====================
  // ORDINE ESATTO da DTD: DenominazioneTitolareCA, CFTitolareCA, CodiceSistemaCA,
  // DataRiepilogo, DataGenerazioneRiepilogo, OraGenerazioneRiepilogo, ProgressivoRiepilogo
  xmlLines.push('    <Titolare>');
  xmlLines.push(`        <DenominazioneTitolareCA>${denominazioneTitolare}</DenominazioneTitolareCA>`);
  xmlLines.push(`        <CFTitolareCA>${cfTitolare}</CFTitolareCA>`);
  xmlLines.push(`        <CodiceSistemaCA>${escapeXml(sistemaEmissione)}</CodiceSistemaCA>`);
  xmlLines.push(`        <DataRiepilogo>${dataRiepilogo}</DataRiepilogo>`);
  xmlLines.push(`        <DataGenerazioneRiepilogo>${dataGenerazione}</DataGenerazioneRiepilogo>`);
  xmlLines.push(`        <OraGenerazioneRiepilogo>${oraGenerazione}</OraGenerazioneRiepilogo>`);
  xmlLines.push(`        <ProgressivoRiepilogo>${progressivo}</ProgressivoRiepilogo>`);
  xmlLines.push('    </Titolare>');
  
  // ==================== Evento ====================
  // ORDINE ESATTO da DTD: CFOrganizzatore, DenominazioneOrganizzatore, TipologiaOrganizzatore,
  // SpettacoloIntrattenimento, IncidenzaIntrattenimento, DenominazioneLocale, CodiceLocale,
  // DataEvento, OraEvento, TipoGenere, TitoloEvento, Autore, Esecutore,
  // NazionalitaFilm, NumOpereRappresentate, SistemaEmissione+
  xmlLines.push('    <Evento>');
  xmlLines.push(`        <CFOrganizzatore>${cfOrganizzatore}</CFOrganizzatore>`);
  xmlLines.push(`        <DenominazioneOrganizzatore>${denominazioneOrganizzatore}</DenominazioneOrganizzatore>`);
  xmlLines.push(`        <TipologiaOrganizzatore>${tipologiaOrganizzatore}</TipologiaOrganizzatore>`);
  xmlLines.push(`        <SpettacoloIntrattenimento>${spettacoloIntrattenimento}</SpettacoloIntrattenimento>`);
  xmlLines.push(`        <IncidenzaIntrattenimento>${incidenzaIntrattenimento}</IncidenzaIntrattenimento>`);
  xmlLines.push(`        <DenominazioneLocale>${nomeLocale}</DenominazioneLocale>`);
  xmlLines.push(`        <CodiceLocale>${codiceLocale}</CodiceLocale>`);
  xmlLines.push(`        <DataEvento>${dataEvento}</DataEvento>`);
  xmlLines.push(`        <OraEvento>${oraEvento}</OraEvento>`);
  xmlLines.push(`        <TipoGenere>${tipoGenere}</TipoGenere>`);
  xmlLines.push(`        <TitoloEvento>${titoloEvento}</TitoloEvento>`);
  // Includi Autore/Esecutore/NazionalitaFilm SOLO per categorie che li richiedono
  // Per Intrattenimento (30-40, 60-69, 70-74, 79): OMETTI completamente
  // Per Teatro/Concerti (45-59): includi Autore e Esecutore
  // Per Cinema (01-04): includi NazionalitaFilm
  if (autore !== null) {
    xmlLines.push(`        <Autore>${autore}</Autore>`);
  }
  if (esecutore !== null) {
    xmlLines.push(`        <Esecutore>${esecutore}</Esecutore>`);
  }
  if (nazionalitaFilm !== null) {
    xmlLines.push(`        <NazionalitaFilm>${nazionalitaFilm}</NazionalitaFilm>`);
  }
  xmlLines.push(`        <NumOpereRappresentate>1</NumOpereRappresentate>`);
  
  // ==================== SistemaEmissione ====================
  // Contiene: CodiceSistemaEmissione, Titoli*, Abbonamenti*
  xmlLines.push('        <SistemaEmissione>');
  xmlLines.push(`            <CodiceSistemaEmissione>${escapeXml(sistemaEmissione)}</CodiceSistemaEmissione>`);
  
  // ==================== Titoli (raggruppati per settore) ====================
  // Ogni settore genera un elemento <Titoli> con N elementi <TotaleTipoTitolo>
  for (const [, sector] of Array.from(sectorMap)) {
    xmlLines.push('            <Titoli>');
    xmlLines.push(`                <CodiceOrdinePosto>${sector.codiceOrdinePosto}</CodiceOrdinePosto>`);
    xmlLines.push(`                <Capienza>${sector.capienza}</Capienza>`);
    
    // TotaleTipoTitolo per ogni tipo in questo settore
    for (const [tipoTitolo, counters] of Array.from(sector.tipoTitoli)) {
      xmlLines.push('                <TotaleTipoTitolo>');
      xmlLines.push(`                    <TipoTitolo>${tipoTitolo}</TipoTitolo>`);
      xmlLines.push(`                    <TotaleTitoliLTA>${counters.totaleLTA}</TotaleTitoliLTA>`);
      xmlLines.push(`                    <TotaleTitoliNoAccessoTradiz>${counters.noAccessoTradiz}</TotaleTitoliNoAccessoTradiz>`);
      xmlLines.push(`                    <TotaleTitoliNoAccessoDigitali>${counters.noAccessoDigitali}</TotaleTitoliNoAccessoDigitali>`);
      xmlLines.push(`                    <TotaleTitoliAutomatizzatiTradiz>${counters.automatizzatiTradiz}</TotaleTitoliAutomatizzatiTradiz>`);
      xmlLines.push(`                    <TotaleTitoliAutomatizzatiDigitali>${counters.automatizzatiDigitali}</TotaleTitoliAutomatizzatiDigitali>`);
      xmlLines.push(`                    <TotaleTitoliManualiTradiz>${counters.manualiTradiz}</TotaleTitoliManualiTradiz>`);
      xmlLines.push(`                    <TotaleTitoliManualiDigitali>${counters.manualiDigitali}</TotaleTitoliManualiDigitali>`);
      xmlLines.push(`                    <TotaleTitoliAnnullatiTradiz>${counters.annullatiTradiz}</TotaleTitoliAnnullatiTradiz>`);
      xmlLines.push(`                    <TotaleTitoliAnnullatiDigitali>${counters.annullatiDigitali}</TotaleTitoliAnnullatiDigitali>`);
      xmlLines.push(`                    <TotaleTitoliDaspatiTradiz>0</TotaleTitoliDaspatiTradiz>`);
      xmlLines.push(`                    <TotaleTitoliDaspatiDigitali>0</TotaleTitoliDaspatiDigitali>`);
      xmlLines.push(`                    <TotaleTitoliRubatiTradiz>0</TotaleTitoliRubatiTradiz>`);
      xmlLines.push(`                    <TotaleTitoliRubatiDigitali>0</TotaleTitoliRubatiDigitali>`);
      xmlLines.push(`                    <TotaleTitoliBLTradiz>0</TotaleTitoliBLTradiz>`);
      xmlLines.push(`                    <TotaleTitoliBLDigitali>0</TotaleTitoliBLDigitali>`);
      xmlLines.push('                </TotaleTipoTitolo>');
    }
    
    xmlLines.push('            </Titoli>');
  }
  
  // Abbonamenti è opzionale (Abbonamenti*) - non lo includiamo se non usiamo abbonamenti
  
  xmlLines.push('        </SistemaEmissione>');
  xmlLines.push('    </Evento>');
  xmlLines.push('</RiepilogoControlloAccessi>');
  
  // IMPORTANTE: Usa CRLF come terminatore di riga (obbligatorio per SIAE)
  // RFC 5751 e Allegato C richiedono CRLF nei messaggi S/MIME
  const xml = xmlLines.join('\r\n');
  
  // FIX 2026-01-18: Ritorna valori autoritativi calcolati durante iterazione
  // Questi sono i valori che devono essere usati per i metadati della trasmissione
  return {
    success: errors.length === 0,
    xml,
    ticketCount: tickets.length,
    cancelledCount: totalCancelledCount,
    totalGrossAmount: totalGrossAmount,
    activeGrossAmount: activeGrossAmount,
    sectorSummaries,
    errors,
    warnings
  };
}

/**
 * Normalizza CodiceOrdinePosto per conformità DTD SIAE
 * Formato: 2 caratteri alfanumerici (es. UN, PL, A1, B2)
 * UN = Unico (posto unico/non numerato)
 */
function normalizeCodiceOrdinePosto(sectorCode: string | null | undefined): string {
  if (!sectorCode) return 'UN';
  
  const code = sectorCode.toUpperCase().trim();
  
  // Se già in formato corretto (2 caratteri alfanumerici)
  if (/^[A-Z0-9]{2}$/.test(code)) {
    return code;
  }
  
  // Mappature comuni
  const mappings: Record<string, string> = {
    'UNICO': 'UN',
    'UNIQUE': 'UN',
    'GENERAL': 'UN',
    'GENERALE': 'UN',
    'PLATEA': 'PL',
    'GALLERIA': 'GA',
    'PALCO': 'PA',
    'LOGGIONE': 'LO',
    'BALCONATA': 'BA',
    'PARTERRE': 'PT',
    'TRIBUNA': 'TR',
    'ANELLO': 'AN',
    'CURVA': 'CU',
    'PRATO': 'PR',
    'VIP': 'VI',
    'A0': 'A1',
    'A': 'A1',
    'B': 'B1',
    'C': 'C1',
    'P0': 'PL',
    'P1': 'P1',
  };
  
  if (mappings[code]) {
    return mappings[code];
  }
  
  // Prendi i primi 2 caratteri se la stringa è più lunga
  if (code.length >= 2) {
    return code.substring(0, 2);
  }
  
  // Padda con '1' se solo 1 carattere
  if (code.length === 1) {
    return code + '1';
  }
  
  return 'UN';
}

// ==================== SIAE Response Parsing ====================

/**
 * Risultato del parsing di una risposta SIAE
 */
export interface SiaeResponseParseResult {
  success: boolean;
  type: 'OK' | 'ERRORE' | 'UNKNOWN';
  code: string | null;
  description: string | null;
  detail: string | null;
  protocolNumber: string | null;
  rawContent: string;
}

/**
 * Parsa il contenuto di un file di risposta SIAE
 * Formato tipico:
 * REPLY:
 * 
 * ERRORE
 * CODICE:      40604
 * DESCRIZIONE: Il riepilogo risulta gia' elaborato
 * DETTAGLIO:   
 * 
 * oppure per successo:
 * REPLY:
 * 
 * OK
 * PROTOCOLLO: 12345678
 */
export function parseSiaeResponseFile(content: string): SiaeResponseParseResult {
  const result: SiaeResponseParseResult = {
    success: false,
    type: 'UNKNOWN',
    code: null,
    description: null,
    detail: null,
    protocolNumber: null,
    rawContent: content,
  };
  
  if (!content || content.trim().length === 0) {
    return result;
  }
  
  const lines = content.split('\n').map(l => l.trim());
  
  // Cerca il tipo di risposta (OK o ERRORE)
  for (const line of lines) {
    if (line === 'OK') {
      result.type = 'OK';
      result.success = true;
      break;
    }
    if (line === 'ERRORE') {
      result.type = 'ERRORE';
      result.success = false;
      break;
    }
  }
  
  // Estrai i campi
  for (const line of lines) {
    // CODICE: estrai il numero (può avere spazi)
    const codiceMatch = line.match(/^CODICE:\s*(\d+)/i);
    if (codiceMatch) {
      result.code = codiceMatch[1];
    }
    
    // DESCRIZIONE: estrai il testo
    const descrizioneMatch = line.match(/^DESCRIZIONE:\s*(.+)/i);
    if (descrizioneMatch) {
      result.description = descrizioneMatch[1].trim();
    }
    
    // DETTAGLIO: estrai il testo (può essere vuoto)
    const dettaglioMatch = line.match(/^DETTAGLIO:\s*(.*)/i);
    if (dettaglioMatch) {
      result.detail = dettaglioMatch[1].trim() || null;
    }
    
    // PROTOCOLLO: per risposte OK
    const protocolloMatch = line.match(/^PROTOCOLLO:\s*(\S+)/i);
    if (protocolloMatch) {
      result.protocolNumber = protocolloMatch[1];
    }
  }
  
  return result;
}

// ==================== VALIDAZIONE PREVENTIVA SIAE ====================

/**
 * Risultato validazione prerequisiti SIAE
 */
export interface SiaePrerequisiteValidation {
  isReady: boolean;
  score: number; // 0-100
  errors: SiaeValidationError[];
  warnings: SiaeValidationWarning[];
  checklist: SiaeChecklistItem[];
}

export interface SiaeValidationError {
  code: string;
  field: string;
  category: 'titolare' | 'evento' | 'genere' | 'settori' | 'biglietti' | 'trasmissione';
  message: string;
  resolution: string;
  siaeErrorCode?: string;
}

export interface SiaeValidationWarning {
  code: string;
  field: string;
  category: 'titolare' | 'evento' | 'genere' | 'settori' | 'biglietti' | 'trasmissione';
  message: string;
  suggestion: string;
}

export interface SiaeChecklistItem {
  category: 'titolare' | 'evento' | 'genere' | 'settori' | 'biglietti' | 'trasmissione';
  field: string;
  label: string;
  status: 'ok' | 'warning' | 'error' | 'missing';
  value?: string | number | null;
  required: boolean;
}

/**
 * Dati necessari per validazione prerequisiti
 */
export interface SiaePrerequisiteData {
  // Titolare (Company)
  company: {
    id: string;
    name: string;
    taxId?: string | null;
    fiscalCode?: string | null;
    regimeFiscale?: string | null;
  };
  // Evento SIAE
  ticketedEvent: {
    id: string;
    siaeLocationCode?: string | null;
    genreCode: string;
    taxType: string;
    entertainmentIncidence?: number | null;
    organizerType?: string | null;
    author?: string | null;
    performer?: string | null;
    filmNationality?: string | null;
    totalCapacity: number;
  };
  // Dati evento base
  event: {
    id: string;
    name: string;
    startDatetime?: Date | string | null;
    endDatetime?: Date | string | null;
  };
  // Settori
  sectors?: Array<{
    id: string;
    orderCode?: string | null;
    capacity?: number | null;
  }>;
  // Configurazione sistema
  systemConfig?: {
    systemCode?: string | null;
  } | null;
  // Smart Card EFFF (opzionale)
  smartCardData?: {
    systemId?: string;
    partnerCodFis?: string;
    partnerName?: string;
  } | null;
  // Stato bridge
  bridgeConnected?: boolean;
}

/**
 * Regole di validazione per tipo genere SIAE
 */
interface GenreValidationRules {
  requiresAuthor: boolean;
  requiresPerformer: boolean;
  requiresFilmNationality: boolean;
  mustBeIntrattenimento: boolean;
  mustBeSpettacolo: boolean;
  defaultVatRate: number;
  description: string;
}

/**
 * Ottiene le regole di validazione per un codice genere
 */
function getGenreValidationRules(genreCode: string): GenreValidationRules {
  const code = parseInt(genreCode, 10);
  
  // Cinema (01-04): richiede NazionalitaFilm
  if (code >= 1 && code <= 4) {
    return {
      requiresAuthor: false,
      requiresPerformer: false,
      requiresFilmNationality: true,
      mustBeIntrattenimento: false,
      mustBeSpettacolo: true,
      defaultVatRate: code === 4 ? 10 : 22,
      description: 'Cinema'
    };
  }
  
  // Sport (05-29): nessun campo aggiuntivo
  if (code >= 5 && code <= 29) {
    return {
      requiresAuthor: false,
      requiresPerformer: false,
      requiresFilmNationality: false,
      mustBeIntrattenimento: false,
      mustBeSpettacolo: true,
      defaultVatRate: 22,
      description: 'Sport'
    };
  }
  
  // Giochi/Casinò (30-40): Intrattenimento obbligatorio
  if (code >= 30 && code <= 40) {
    return {
      requiresAuthor: false,
      requiresPerformer: false,
      requiresFilmNationality: false,
      mustBeIntrattenimento: true,
      mustBeSpettacolo: false,
      defaultVatRate: 22,
      description: 'Giochi/Intrattenimento'
    };
  }
  
  // Musei/Gallerie (41-44)
  if (code >= 41 && code <= 44) {
    return {
      requiresAuthor: false,
      requiresPerformer: false,
      requiresFilmNationality: false,
      mustBeIntrattenimento: false,
      mustBeSpettacolo: true,
      defaultVatRate: 22,
      description: 'Musei/Gallerie'
    };
  }
  
  // Teatro/Concerti (45-59): richiede Autore e Esecutore
  if (code >= 45 && code <= 59) {
    return {
      requiresAuthor: true,
      requiresPerformer: true,
      requiresFilmNationality: false,
      mustBeIntrattenimento: false,
      mustBeSpettacolo: true,
      defaultVatRate: 10,
      description: 'Teatro/Concerti'
    };
  }
  
  // Ballo/Discoteca (60-69): Intrattenimento obbligatorio
  if (code >= 60 && code <= 69) {
    return {
      requiresAuthor: false,
      requiresPerformer: false,
      requiresFilmNationality: false,
      mustBeIntrattenimento: true,
      mustBeSpettacolo: false,
      defaultVatRate: 22,
      description: 'Ballo/Discoteca'
    };
  }
  
  // Fiere/Mostre (70-74): Intrattenimento
  if (code >= 70 && code <= 74) {
    return {
      requiresAuthor: false,
      requiresPerformer: false,
      requiresFilmNationality: false,
      mustBeIntrattenimento: true,
      mustBeSpettacolo: false,
      defaultVatRate: 22,
      description: 'Fiere/Mostre'
    };
  }
  
  // Circo/Spettacoli viaggianti (75-78): Spettacolo
  if (code >= 75 && code <= 78) {
    return {
      requiresAuthor: false,
      requiresPerformer: false,
      requiresFilmNationality: false,
      mustBeIntrattenimento: false,
      mustBeSpettacolo: true,
      defaultVatRate: 10,
      description: 'Circo/Spettacoli viaggianti'
    };
  }
  
  // Luna park/Attrazioni (79-89): Intrattenimento
  if (code >= 79 && code <= 89) {
    return {
      requiresAuthor: false,
      requiresPerformer: false,
      requiresFilmNationality: false,
      mustBeIntrattenimento: true,
      mustBeSpettacolo: false,
      defaultVatRate: 22,
      description: 'Attrazioni/Parchi'
    };
  }
  
  // Altro (90-99): generalmente Spettacolo
  return {
    requiresAuthor: false,
    requiresPerformer: false,
    requiresFilmNationality: false,
    mustBeIntrattenimento: false,
    mustBeSpettacolo: false,
    defaultVatRate: 22,
    description: 'Altro'
  };
}

/**
 * Valida Codice Fiscale italiano (16 caratteri alfanumerici)
 */
function validateCodiceFiscale(cf: string): { valid: boolean; error?: string } {
  if (!cf) return { valid: false, error: 'Codice Fiscale mancante' };
  
  const cleaned = cf.toUpperCase().trim();
  
  // P.IVA: 11 cifre
  if (/^\d{11}$/.test(cleaned)) {
    return { valid: true };
  }
  
  // Codice Fiscale: 16 caratteri alfanumerici
  if (/^[A-Z]{6}\d{2}[A-Z]\d{2}[A-Z]\d{3}[A-Z]$/.test(cleaned)) {
    return { valid: true };
  }
  
  if (cleaned.length === 16 && /^[A-Z0-9]{16}$/.test(cleaned)) {
    return { valid: true }; // Formato accettabile
  }
  
  return { 
    valid: false, 
    error: `Formato non valido (${cleaned.length} caratteri). Atteso: P.IVA 11 cifre o CF 16 caratteri` 
  };
}

/**
 * Valida Codice Locale SIAE (13 caratteri)
 */
function validateCodiceLocale(code: string | null | undefined): { valid: boolean; error?: string; normalized?: string } {
  if (!code) {
    return { valid: false, error: 'Codice Locale SIAE mancante' };
  }
  
  const cleaned = code.trim();
  
  // Deve essere esattamente 13 caratteri (o meno, verrà padded)
  if (cleaned.length > 13) {
    return { valid: false, error: `Troppo lungo (${cleaned.length} caratteri). Massimo 13` };
  }
  
  // Normalizza a 13 caratteri con zeri a sinistra
  const normalized = cleaned.padStart(13, '0');
  
  // Deve contenere solo cifre
  if (!/^\d{13}$/.test(normalized)) {
    return { valid: false, error: 'Deve contenere solo cifre' };
  }
  
  // Non può essere tutto zeri
  if (normalized === '0000000000000') {
    return { valid: false, error: 'Codice Locale non configurato (tutto zeri)' };
  }
  
  return { valid: true, normalized };
}

/**
 * Valida Codice Sistema SIAE (8 caratteri)
 */
function validateSystemCode(code: string | null | undefined): { valid: boolean; error?: string } {
  if (!code) {
    return { valid: false, error: 'Codice Sistema mancante' };
  }
  
  if (code.length !== 8) {
    return { valid: false, error: `Deve essere esattamente 8 caratteri (attuale: ${code.length})` };
  }
  
  // Pattern valido: Pxxxxxxx (test) o 0xxxxxxx (produzione)
  if (!/^[A-Z0-9]{8}$/i.test(code)) {
    return { valid: false, error: 'Deve contenere solo caratteri alfanumerici' };
  }
  
  return { valid: true };
}

/**
 * VALIDAZIONE PREVENTIVA COMPLETA SIAE
 * 
 * Verifica TUTTI i requisiti PRIMA della generazione XML per prevenire
 * errori di trasmissione. Restituisce lista dettagliata di errori/warning
 * con istruzioni per risolverli.
 */
export function validateSiaeReportPrerequisites(data: SiaePrerequisiteData): SiaePrerequisiteValidation {
  const errors: SiaeValidationError[] = [];
  const warnings: SiaeValidationWarning[] = [];
  const checklist: SiaeChecklistItem[] = [];
  
  // Risolvi codice sistema (priorità: Smart Card > config > default)
  const systemCode = data.smartCardData?.systemId || data.systemConfig?.systemCode || SIAE_SYSTEM_CODE_DEFAULT;
  
  // Risolvi CF Titolare (priorità: Smart Card > company.taxId > company.fiscalCode)
  const cfTitolare = data.smartCardData?.partnerCodFis || data.company.taxId || data.company.fiscalCode || '';
  
  // Risolvi denominazione (priorità: Smart Card > company.name)
  const denominazione = data.smartCardData?.partnerName || data.company.name || '';
  
  // ==================== VALIDAZIONI TITOLARE ====================
  
  // 1. Codice Sistema (8 caratteri) - OBBLIGATORIO
  // Verifica se è stato configurato esplicitamente o si sta usando il default
  const hasConfiguredSystemCode = !!(data.smartCardData?.systemId || data.systemConfig?.systemCode);
  const sysCodeValidation = validateSystemCode(systemCode);
  
  // SystemCode DEVE essere configurato esplicitamente (Smart Card o config)
  // Non è accettabile usare un default per trasmissioni RCA ufficiali
  // - Se non configurato = error bloccante (non può procedere)
  // - Se configurato MA non valido = error bloccante
  // - Se configurato E valido = ok
  let systemCodeStatus: 'ok' | 'warning' | 'error' = 'ok';
  if (!hasConfiguredSystemCode) {
    systemCodeStatus = 'error'; // Mancanza configurazione = bloccante
  } else if (!sysCodeValidation.valid) {
    systemCodeStatus = 'error'; // Valore non valido = bloccante
  }
  
  checklist.push({
    category: 'titolare',
    field: 'systemCode',
    label: 'Codice Sistema SIAE',
    status: systemCodeStatus,
    value: hasConfiguredSystemCode ? systemCode : 'Non configurato',
    required: true
  });
  
  if (!hasConfiguredSystemCode) {
    errors.push({
      code: 'SYSTEM_CODE_NOT_CONFIGURED',
      field: 'systemCode',
      category: 'titolare',
      message: 'Codice Sistema SIAE obbligatorio ma non configurato',
      resolution: 'Connettere Smart Card per leggere il codice automaticamente, oppure configurare manualmente in Impostazioni SIAE (8 caratteri alfanumerici)',
      siaeErrorCode: '0600'
    });
  } else if (!sysCodeValidation.valid) {
    errors.push({
      code: 'SYSTEM_CODE_INVALID',
      field: 'systemCode',
      category: 'titolare',
      message: sysCodeValidation.error || 'Codice Sistema non valido',
      resolution: 'Verificare che il codice sistema sia di 8 caratteri alfanumerici',
      siaeErrorCode: '0600'
    });
  }
  
  // 2. Codice Fiscale Titolare
  const cfValidation = validateCodiceFiscale(cfTitolare);
  checklist.push({
    category: 'titolare',
    field: 'taxId',
    label: 'Codice Fiscale / P.IVA Titolare',
    status: cfValidation.valid ? 'ok' : 'error',
    value: cfTitolare || null,
    required: true
  });
  if (!cfValidation.valid) {
    errors.push({
      code: 'TAX_ID_INVALID',
      field: 'taxId',
      category: 'titolare',
      message: cfValidation.error || 'Codice Fiscale/P.IVA non valido',
      resolution: 'Inserire P.IVA (11 cifre) o Codice Fiscale (16 caratteri) nelle impostazioni azienda',
      siaeErrorCode: '2606'
    });
  }
  
  // 3. Denominazione Titolare
  checklist.push({
    category: 'titolare',
    field: 'businessName',
    label: 'Denominazione Titolare',
    status: denominazione ? 'ok' : 'error',
    value: denominazione || null,
    required: true
  });
  if (!denominazione) {
    errors.push({
      code: 'BUSINESS_NAME_MISSING',
      field: 'businessName',
      category: 'titolare',
      message: 'Denominazione azienda mancante',
      resolution: 'Inserire nome azienda nelle impostazioni',
      siaeErrorCode: '2606'
    });
  }
  
  // 4. Bridge connesso (warning se non connesso)
  checklist.push({
    category: 'trasmissione',
    field: 'bridgeConnected',
    label: 'Smart Card Bridge',
    status: data.bridgeConnected ? 'ok' : 'warning',
    value: data.bridgeConnected ? 'Connesso' : 'Non connesso',
    required: false
  });
  if (!data.bridgeConnected) {
    warnings.push({
      code: 'BRIDGE_NOT_CONNECTED',
      field: 'bridgeConnected',
      category: 'trasmissione',
      message: 'Smart Card Bridge non connesso',
      suggestion: 'Connettere il bridge per firma digitale automatica dei report'
    });
  }
  
  // ==================== VALIDAZIONI EVENTO ====================
  
  // 5. Codice Locale SIAE (13 caratteri)
  const localeValidation = validateCodiceLocale(data.ticketedEvent.siaeLocationCode);
  checklist.push({
    category: 'evento',
    field: 'siaeLocationCode',
    label: 'Codice Locale SIAE',
    status: localeValidation.valid ? 'ok' : 'error',
    value: localeValidation.normalized || data.ticketedEvent.siaeLocationCode || null,
    required: true
  });
  if (!localeValidation.valid) {
    errors.push({
      code: 'LOCATION_CODE_INVALID',
      field: 'siaeLocationCode',
      category: 'evento',
      message: localeValidation.error || 'Codice Locale SIAE non valido',
      resolution: 'Inserire il codice locale SIAE (13 cifre) nella configurazione evento bigliettato',
      siaeErrorCode: '40605'
    });
  }
  
  // 6. Tipo Genere (2 cifre, 01-99)
  const genreCode = data.ticketedEvent.genreCode;
  const genreNum = parseInt(genreCode, 10);
  const genreValid = !isNaN(genreNum) && genreNum >= 1 && genreNum <= 99;
  checklist.push({
    category: 'evento',
    field: 'genreCode',
    label: 'Tipo Genere SIAE (TAB.1)',
    status: genreValid ? 'ok' : 'error',
    value: genreCode,
    required: true
  });
  if (!genreValid) {
    errors.push({
      code: 'GENRE_CODE_INVALID',
      field: 'genreCode',
      category: 'evento',
      message: `Codice genere "${genreCode}" non valido. Deve essere 01-99`,
      resolution: 'Selezionare un genere valido dalla tabella TAB.1 SIAE',
      siaeErrorCode: '2101'
    });
  }
  
  // 7. Data/Ora Evento
  const eventDate = data.event.startDatetime;
  const hasValidDate = eventDate && !isNaN(new Date(eventDate).getTime());
  checklist.push({
    category: 'evento',
    field: 'startDatetime',
    label: 'Data/Ora Evento',
    status: hasValidDate ? 'ok' : 'error',
    value: hasValidDate ? new Date(eventDate).toLocaleString('it-IT') : null,
    required: true
  });
  if (!hasValidDate) {
    errors.push({
      code: 'EVENT_DATE_INVALID',
      field: 'startDatetime',
      category: 'evento',
      message: 'Data/Ora evento mancante o non valida',
      resolution: 'Configurare data e ora di inizio evento',
      siaeErrorCode: '0603'
    });
  }
  
  // 8. Capienza totale
  const capacity = data.ticketedEvent.totalCapacity;
  checklist.push({
    category: 'evento',
    field: 'totalCapacity',
    label: 'Capienza Totale',
    status: capacity > 0 ? 'ok' : 'error',
    value: capacity,
    required: true
  });
  if (capacity <= 0) {
    errors.push({
      code: 'CAPACITY_INVALID',
      field: 'totalCapacity',
      category: 'evento',
      message: 'Capienza totale deve essere maggiore di 0',
      resolution: 'Configurare la capienza totale dell\'evento'
    });
  }
  
  // ==================== VALIDAZIONI PER TIPO GENERE ====================
  
  if (genreValid) {
    const rules = getGenreValidationRules(genreCode);
    
    // Descrizione categoria genere
    checklist.push({
      category: 'genere',
      field: 'genreCategory',
      label: 'Categoria Genere',
      status: 'ok',
      value: rules.description,
      required: false
    });
    
    // Tax Type coerenza
    const taxType = data.ticketedEvent.taxType;
    if (rules.mustBeIntrattenimento && taxType !== 'I') {
      errors.push({
        code: 'TAX_TYPE_MISMATCH',
        field: 'taxType',
        category: 'genere',
        message: `Genere ${genreCode} (${rules.description}) richiede Tax Type = Intrattenimento (I), ma è impostato "${taxType}"`,
        resolution: 'Modificare Tax Type a "I" (Intrattenimento) per questo genere'
      });
      checklist.push({
        category: 'genere',
        field: 'taxType',
        label: 'Tipo Imposta',
        status: 'error',
        value: taxType,
        required: true
      });
    } else if (rules.mustBeSpettacolo && taxType !== 'S') {
      warnings.push({
        code: 'TAX_TYPE_MISMATCH_WARN',
        field: 'taxType',
        category: 'genere',
        message: `Genere ${genreCode} (${rules.description}) tipicamente usa Tax Type = Spettacolo (S)`,
        suggestion: 'Verificare se il Tax Type è corretto per questo evento'
      });
      checklist.push({
        category: 'genere',
        field: 'taxType',
        label: 'Tipo Imposta',
        status: 'warning',
        value: taxType,
        required: true
      });
    } else {
      checklist.push({
        category: 'genere',
        field: 'taxType',
        label: 'Tipo Imposta',
        status: 'ok',
        value: taxType === 'I' ? 'Intrattenimento' : 'Spettacolo',
        required: true
      });
    }
    
    // Incidenza Intrattenimento (obbligatoria se I, deve essere > 0 per generi intrattenimento)
    if (taxType === 'I') {
      const incidence = data.ticketedEvent.entertainmentIncidence;
      // Per generi intrattenimento (30-40, 60-69) l'incidenza deve essere > 0
      const minIncidence = rules.mustBeIntrattenimento ? 1 : 0;
      const incidenceValid = incidence !== null && incidence !== undefined && incidence >= minIncidence && incidence <= 100;
      checklist.push({
        category: 'genere',
        field: 'entertainmentIncidence',
        label: 'Incidenza Intrattenimento',
        status: incidenceValid ? 'ok' : 'error',
        value: incidence !== null && incidence !== undefined ? `${incidence}%` : null,
        required: true
      });
      if (!incidenceValid) {
        errors.push({
          code: 'ENTERTAINMENT_INCIDENCE_MISSING',
          field: 'entertainmentIncidence',
          category: 'genere',
          message: rules.mustBeIntrattenimento 
            ? `Incidenza Intrattenimento obbligatoria (1-100%) per genere ${genreCode} (${rules.description})`
            : 'Incidenza Intrattenimento obbligatoria per Tax Type = I (0-100%)',
          resolution: rules.mustBeIntrattenimento 
            ? 'Impostare percentuale incidenza intrattenimento maggiore di 0 (tipicamente 100% per discoteche/ballo)'
            : 'Impostare percentuale incidenza intrattenimento (0-100%)'
        });
      }
    }
    
    // Autore (obbligatorio per Teatro/Concerti 45-59)
    if (rules.requiresAuthor) {
      const author = data.ticketedEvent.author;
      checklist.push({
        category: 'genere',
        field: 'author',
        label: 'Autore Opera',
        status: author ? 'ok' : 'error',
        value: author || null,
        required: true
      });
      if (!author) {
        errors.push({
          code: 'AUTHOR_REQUIRED',
          field: 'author',
          category: 'genere',
          message: `Autore obbligatorio per genere ${genreCode} (${rules.description})`,
          resolution: 'Inserire il nome dell\'autore dell\'opera nella configurazione evento SIAE'
        });
      }
    }
    
    // Esecutore/Artista (obbligatorio per Teatro/Concerti 45-59)
    if (rules.requiresPerformer) {
      const performer = data.ticketedEvent.performer;
      checklist.push({
        category: 'genere',
        field: 'performer',
        label: 'Esecutore/Artista',
        status: performer ? 'ok' : 'error',
        value: performer || null,
        required: true
      });
      if (!performer) {
        errors.push({
          code: 'PERFORMER_REQUIRED',
          field: 'performer',
          category: 'genere',
          message: `Esecutore/Artista obbligatorio per genere ${genreCode} (${rules.description})`,
          resolution: 'Inserire il nome dell\'artista/interprete nella configurazione evento SIAE'
        });
      }
    }
    
    // NazionalitaFilm (obbligatorio per Cinema 01-04)
    if (rules.requiresFilmNationality) {
      const nationality = data.ticketedEvent.filmNationality;
      const natValid = nationality && /^[A-Z]{2}$/i.test(nationality);
      checklist.push({
        category: 'genere',
        field: 'filmNationality',
        label: 'Nazionalità Film (ISO)',
        status: natValid ? 'ok' : 'error',
        value: nationality || null,
        required: true
      });
      if (!natValid) {
        errors.push({
          code: 'FILM_NATIONALITY_REQUIRED',
          field: 'filmNationality',
          category: 'genere',
          message: `Nazionalità film obbligatoria per genere ${genreCode} (Cinema). Usare codice ISO 2 lettere (IT, US, FR...)`,
          resolution: 'Inserire il codice nazionalità ISO 3166 del film'
        });
      }
    }
  }
  
  // ==================== VALIDAZIONI SETTORI ====================
  
  const sectors = data.sectors || [];
  // RCA richiede almeno un settore per la struttura XML
  const hasSectors = sectors.length > 0;
  checklist.push({
    category: 'settori',
    field: 'sectorsCount',
    label: 'Settori Configurati',
    status: hasSectors ? 'ok' : 'error',
    value: sectors.length,
    required: true
  });
  
  if (!hasSectors) {
    errors.push({
      code: 'NO_SECTORS',
      field: 'sectors',
      category: 'settori',
      message: 'Almeno un settore obbligatorio per trasmissione RCA',
      resolution: 'Configurare almeno un settore con codice ordine (es: UN, PL) e capienza nella sezione Settori evento',
      siaeErrorCode: '40605'
    });
  } else {
    // Verifica ogni settore
    for (const sector of sectors) {
      if (!sector.orderCode || !/^[A-Z0-9]{2}$/i.test(sector.orderCode)) {
        warnings.push({
          code: 'SECTOR_CODE_INVALID',
          field: 'orderCode',
          category: 'settori',
          message: `Settore "${sector.id}" ha codice ordine non valido: "${sector.orderCode}"`,
          suggestion: 'Usare codice 2 caratteri alfanumerici (es: UN, PL, A1)'
        });
      }
      if (!sector.capacity || sector.capacity <= 0) {
        warnings.push({
          code: 'SECTOR_CAPACITY_INVALID',
          field: 'capacity',
          category: 'settori',
          message: `Settore "${sector.orderCode || sector.id}" ha capienza non valida`,
          suggestion: 'Configurare capienza settore > 0'
        });
      }
    }
  }
  
  // ==================== CALCOLO SCORE ====================
  
  // Pesi: errori = -20 punti, warning = -5 punti
  // Base = 100, minimo = 0
  const baseScore = 100;
  const errorPenalty = errors.length * 20;
  const warningPenalty = warnings.length * 5;
  const score = Math.max(0, Math.min(100, baseScore - errorPenalty - warningPenalty));
  
  return {
    isReady: errors.length === 0,
    score,
    errors,
    warnings,
    checklist
  };
}

// ==================== AUTO-CORREZIONE PRE-TRASMISSIONE ====================

/**
 * Risultato dell'auto-correzione XML SIAE
 */
export interface AutoCorrectResult {
  correctedXml: string;
  corrections: Array<{
    field: string;
    original: string;
    corrected: string;
    reason: string;
    siaeErrorPrevented: string;
  }>;
  uncorrectableErrors: Array<{
    field: string;
    message: string;
    siaeErrorCode: string;
  }>;
}

/**
 * Tabella generi SIAE con requisiti Autore/Esecutore/NazionalitàFilm
 * Basata su Tabella 1 Allegato A Provvedimento 23/7/2001
 */
const SIAE_GENRE_REQUIREMENTS: Record<string, { needsAutore: boolean; needsEsecutore: boolean; needsNazionalita: boolean; description: string }> = {
  // Cinema (01-04): richiedono NazionalitàFilm
  '01': { needsAutore: false, needsEsecutore: false, needsNazionalita: true, description: 'Cinema - Film' },
  '02': { needsAutore: false, needsEsecutore: false, needsNazionalita: true, description: 'Cinema - Documentario' },
  '03': { needsAutore: false, needsEsecutore: false, needsNazionalita: true, description: 'Cinema - Corto' },
  '04': { needsAutore: false, needsEsecutore: false, needsNazionalita: true, description: 'Cinema - Altro' },
  // Teatro/Concerti (45-59): richiedono Autore ed Esecutore
  '45': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Teatro - Prosa' },
  '46': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Teatro - Lirica' },
  '47': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Teatro - Balletto' },
  '48': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Teatro - Operetta' },
  '49': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Teatro - Musical' },
  '50': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Concerto - Classica' },
  '51': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Concerto - Pop/Rock' },
  '52': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Concerto - Jazz' },
  '53': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Concerto - Folk' },
  '54': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Concerto - Altro' },
  '55': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Spettacolo comico' },
  '56': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Cabaret' },
  '57': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Varietà' },
  '58': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Circo' },
  '59': { needsAutore: true, needsEsecutore: true, needsNazionalita: false, description: 'Spettacolo viaggiante' },
  // Intrattenimento (30-40, 60-69, 70-79): NON richiedono nulla
  '30': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Giochi - Slot' },
  '31': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Giochi - Carte' },
  '32': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Giochi - Biliardo' },
  '33': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Giochi - Bowling' },
  '34': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Giochi - Flipper' },
  '35': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Giochi - Videogiochi' },
  '36': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Giochi - Altri' },
  '60': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Discoteca' },
  '61': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Sala da ballo' },
  '62': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Piano bar' },
  '63': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Karaoke' },
  '64': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Disco pub' },
  '65': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Night club' },
  '66': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Locale notturno' },
  '67': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Beach club' },
  '68': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Lido' },
  '69': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Altro intrattenimento' },
  '70': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Fiera' },
  '71': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Mostra' },
  '72': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Esposizione' },
  '73': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Sagra' },
  '74': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Festa patronale' },
  '79': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Luna park' },
  // Sport (80-89)
  '80': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Evento sportivo' },
  '81': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Calcio' },
  '82': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Basket' },
  '83': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Tennis' },
  '84': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Pugilato' },
  '85': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Automobilismo' },
  '86': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Motociclismo' },
  '89': { needsAutore: false, needsEsecutore: false, needsNazionalita: false, description: 'Altro sport' },
};

/**
 * Codici ISO 3166-1 alpha-2 validi per NazionalitàFilm
 */
const VALID_ISO_3166_CODES = new Set([
  'IT', 'US', 'GB', 'FR', 'DE', 'ES', 'PT', 'NL', 'BE', 'AT', 'CH', 'PL', 'CZ', 'SK', 'HU',
  'RO', 'BG', 'GR', 'HR', 'SI', 'RS', 'BA', 'ME', 'MK', 'AL', 'XK', 'UA', 'RU', 'BY', 'MD',
  'SE', 'NO', 'DK', 'FI', 'IS', 'IE', 'LU', 'MT', 'CY', 'EE', 'LV', 'LT', 'TR', 'IL', 'EG',
  'MA', 'TN', 'DZ', 'LY', 'ZA', 'NG', 'KE', 'ET', 'GH', 'CI', 'SN', 'CM', 'AO', 'MZ', 'TZ',
  'JP', 'CN', 'KR', 'KP', 'TW', 'HK', 'MO', 'SG', 'MY', 'ID', 'TH', 'VN', 'PH', 'MM', 'KH',
  'IN', 'PK', 'BD', 'LK', 'NP', 'BT', 'AF', 'IR', 'IQ', 'SA', 'AE', 'QA', 'KW', 'BH', 'OM',
  'AU', 'NZ', 'PG', 'FJ', 'WS', 'TO', 'VU', 'NC', 'PF', 'GU', 'AS',
  'CA', 'MX', 'GT', 'BZ', 'SV', 'HN', 'NI', 'CR', 'PA', 'CU', 'JM', 'HT', 'DO', 'PR', 'TT',
  'BR', 'AR', 'CL', 'PE', 'CO', 'VE', 'EC', 'BO', 'PY', 'UY', 'GY', 'SR'
]);

/**
 * AUTO-CORREZIONE PREVENTIVA XML SIAE
 * 
 * Corregge automaticamente gli errori comuni nell'XML SIAE prima della trasmissione.
 * Questa funzione deve essere chiamata PRIMA di validatePreTransmission().
 * 
 * Correzioni automatiche:
 * - Troncamento denominazione a 60 caratteri (previene warning 2606)
 * - Troncamento performer a 100 caratteri (previene errore 40605)
 * - Rimozione Autore/Esecutore/NazionalitàFilm se non richiesti dal genere (previene 2108/2111/2114)
 * - Aggiunta Autore/Esecutore placeholder se richiesti dal genere (previene 2110)
 * - Normalizzazione codice genere a formato valido (previene 2101)
 * - Padding codice locale a 13 cifre (previene 3203)
 * - Normalizzazione codice fiscale (previene 3111)
 * - Correzione encoding UTF-8 (previene 40603)
 * 
 * @param xml - Contenuto XML originale
 * @param genreCode - Codice genere evento (opzionale, estratto da XML se non fornito)
 * @param defaultAutore - Autore di default da usare se richiesto ma mancante
 * @param defaultEsecutore - Esecutore di default da usare se richiesto ma mancante
 * @returns Risultato con XML corretto e lista correzioni applicate
 */
export function autoCorrectSiaeXml(
  xml: string,
  genreCode?: string,
  defaultAutore?: string,
  defaultEsecutore?: string
): AutoCorrectResult {
  let correctedXml = xml;
  const corrections: AutoCorrectResult['corrections'] = [];
  const uncorrectableErrors: AutoCorrectResult['uncorrectableErrors'] = [];
  
  // ==================== 1. CORREZIONE ENCODING ====================
  // Rimuovi caratteri non-UTF8 e normalizza
  try {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder('utf-8', { fatal: false });
    const encoded = encoder.encode(correctedXml);
    const decoded = decoder.decode(encoded);
    if (decoded !== correctedXml) {
      corrections.push({
        field: 'encoding',
        original: 'Caratteri non-UTF8 presenti',
        corrected: 'Caratteri normalizzati UTF-8',
        reason: 'Rimossi caratteri non validi UTF-8',
        siaeErrorPrevented: '40603'
      });
      correctedXml = decoded;
    }
  } catch (e) {
    // Ignora errori encoding
  }
  
  // ==================== 2. CORREZIONE DENOMINAZIONE (max 60 char) ====================
  const denominazioneMatch = correctedXml.match(/<Denominazione>([^<]*)<\/Denominazione>/g);
  if (denominazioneMatch) {
    for (const match of denominazioneMatch) {
      const innerMatch = match.match(/<Denominazione>([^<]*)<\/Denominazione>/);
      if (innerMatch && innerMatch[1].length > 60) {
        const original = innerMatch[1];
        const truncated = original.substring(0, 60);
        correctedXml = correctedXml.replace(match, `<Denominazione>${truncated}</Denominazione>`);
        corrections.push({
          field: 'Denominazione',
          original: `${original.length} caratteri`,
          corrected: `Troncato a 60 caratteri`,
          reason: 'Denominazione max 60 caratteri per specifiche SIAE',
          siaeErrorPrevented: '2606'
        });
      }
    }
  }
  
  // ==================== 3. CORREZIONE AUTORE (max 100 char) ====================
  const autoreMatch = correctedXml.match(/<Autore>([^<]*)<\/Autore>/);
  if (autoreMatch && autoreMatch[1].length > 100) {
    const original = autoreMatch[1];
    const truncated = original.substring(0, 100);
    correctedXml = correctedXml.replace(autoreMatch[0], `<Autore>${truncated}</Autore>`);
    corrections.push({
      field: 'Autore',
      original: `${original.length} caratteri`,
      corrected: `Troncato a 100 caratteri`,
      reason: 'Autore max 100 caratteri per specifiche SIAE',
      siaeErrorPrevented: '40605'
    });
  }
  
  // ==================== 4. CORREZIONE ESECUTORE (max 100 char) ====================
  const esecutoreMatch = correctedXml.match(/<Esecutore>([^<]*)<\/Esecutore>/);
  if (esecutoreMatch && esecutoreMatch[1].length > 100) {
    const original = esecutoreMatch[1];
    const truncated = original.substring(0, 100);
    correctedXml = correctedXml.replace(esecutoreMatch[0], `<Esecutore>${truncated}</Esecutore>`);
    corrections.push({
      field: 'Esecutore',
      original: `${original.length} caratteri`,
      corrected: `Troncato a 100 caratteri`,
      reason: 'Esecutore max 100 caratteri per specifiche SIAE',
      siaeErrorPrevented: '40605'
    });
  }
  
  // ==================== 5. CORREZIONE CODICE GENERE ====================
  // Estrai codice genere dall'XML se non fornito
  let effectiveGenreCode = genreCode;
  if (!effectiveGenreCode) {
    const tipoGenereMatch = correctedXml.match(/<TipoGenere>([^<]*)<\/TipoGenere>/);
    effectiveGenreCode = tipoGenereMatch?.[1] || undefined;
  }
  
  // Valida e correggi formato codice genere
  if (effectiveGenreCode) {
    const genreNum = parseInt(effectiveGenreCode, 10);
    if (isNaN(genreNum) || genreNum < 1 || genreNum > 99) {
      // Codice non valido, usa default '60' (Discoteca)
      const correctedGenre = '60';
      if (correctedXml.includes(`<TipoGenere>${effectiveGenreCode}</TipoGenere>`)) {
        correctedXml = correctedXml.replace(
          `<TipoGenere>${effectiveGenreCode}</TipoGenere>`,
          `<TipoGenere>${correctedGenre}</TipoGenere>`
        );
        corrections.push({
          field: 'TipoGenere',
          original: effectiveGenreCode,
          corrected: correctedGenre,
          reason: 'Codice genere non valido, impostato default Discoteca (60)',
          siaeErrorPrevented: '2101'
        });
      }
      effectiveGenreCode = correctedGenre;
    } else {
      // Normalizza a 2 cifre con padding
      const normalizedGenre = genreNum.toString().padStart(2, '0');
      if (normalizedGenre !== effectiveGenreCode) {
        correctedXml = correctedXml.replace(
          `<TipoGenere>${effectiveGenreCode}</TipoGenere>`,
          `<TipoGenere>${normalizedGenre}</TipoGenere>`
        );
        corrections.push({
          field: 'TipoGenere',
          original: effectiveGenreCode,
          corrected: normalizedGenre,
          reason: 'Normalizzato formato codice genere a 2 cifre',
          siaeErrorPrevented: '2101'
        });
        effectiveGenreCode = normalizedGenre;
      }
    }
  }
  
  // ==================== 6. CORREZIONE AUTORE/ESECUTORE/NAZIONALITÀ IN BASE AL GENERE ====================
  if (effectiveGenreCode) {
    const requirements = SIAE_GENRE_REQUIREMENTS[effectiveGenreCode];
    
    if (requirements) {
      const hasAutore = correctedXml.includes('<Autore>');
      const hasEsecutore = correctedXml.includes('<Esecutore>');
      const hasNazionalita = correctedXml.includes('<NazionalitaFilm>');
      
      // Rimuovi elementi non richiesti
      if (!requirements.needsAutore && hasAutore) {
        correctedXml = correctedXml.replace(/<Autore>[^<]*<\/Autore>\s*/g, '');
        corrections.push({
          field: 'Autore',
          original: 'Presente',
          corrected: 'Rimosso',
          reason: `Autore non previsto per genere ${effectiveGenreCode} (${requirements.description})`,
          siaeErrorPrevented: '2108'
        });
      }
      
      if (!requirements.needsEsecutore && hasEsecutore) {
        correctedXml = correctedXml.replace(/<Esecutore>[^<]*<\/Esecutore>\s*/g, '');
        corrections.push({
          field: 'Esecutore',
          original: 'Presente',
          corrected: 'Rimosso',
          reason: `Esecutore non previsto per genere ${effectiveGenreCode} (${requirements.description})`,
          siaeErrorPrevented: '2111'
        });
      }
      
      if (!requirements.needsNazionalita && hasNazionalita) {
        correctedXml = correctedXml.replace(/<NazionalitaFilm>[^<]*<\/NazionalitaFilm>\s*/g, '');
        corrections.push({
          field: 'NazionalitaFilm',
          original: 'Presente',
          corrected: 'Rimosso',
          reason: `Nazionalità film non prevista per genere ${effectiveGenreCode} (${requirements.description})`,
          siaeErrorPrevented: '2114'
        });
      }
      
      // Aggiungi elementi richiesti se mancanti (solo se abbiamo valori default)
      if (requirements.needsAutore && !hasAutore) {
        const autoreValue = defaultAutore || 'Autore Evento';
        // Inserisci dopo TipoGenere
        if (correctedXml.includes('</TipoGenere>')) {
          correctedXml = correctedXml.replace(
            '</TipoGenere>',
            `</TipoGenere>\n        <Autore>${escapeXml(autoreValue.substring(0, 100))}</Autore>`
          );
          corrections.push({
            field: 'Autore',
            original: 'Mancante',
            corrected: autoreValue.substring(0, 30) + '...',
            reason: `Autore richiesto per genere ${effectiveGenreCode} (${requirements.description})`,
            siaeErrorPrevented: '2110'
          });
        }
      }
      
      if (requirements.needsEsecutore && !hasEsecutore) {
        const esecutoreValue = defaultEsecutore || 'Esecutore Evento';
        // Inserisci dopo Autore o TipoGenere
        if (correctedXml.includes('</Autore>')) {
          correctedXml = correctedXml.replace(
            '</Autore>',
            `</Autore>\n        <Esecutore>${escapeXml(esecutoreValue.substring(0, 100))}</Esecutore>`
          );
        } else if (correctedXml.includes('</TipoGenere>')) {
          correctedXml = correctedXml.replace(
            '</TipoGenere>',
            `</TipoGenere>\n        <Esecutore>${escapeXml(esecutoreValue.substring(0, 100))}</Esecutore>`
          );
        }
        corrections.push({
          field: 'Esecutore',
          original: 'Mancante',
          corrected: esecutoreValue.substring(0, 30) + '...',
          reason: `Esecutore richiesto per genere ${effectiveGenreCode} (${requirements.description})`,
          siaeErrorPrevented: '2110'
        });
      }
      
      if (requirements.needsNazionalita && !hasNazionalita) {
        // Per cinema, aggiungi IT di default
        if (correctedXml.includes('</Esecutore>')) {
          correctedXml = correctedXml.replace(
            '</Esecutore>',
            `</Esecutore>\n        <NazionalitaFilm>IT</NazionalitaFilm>`
          );
        } else if (correctedXml.includes('</TipoGenere>')) {
          correctedXml = correctedXml.replace(
            '</TipoGenere>',
            `</TipoGenere>\n        <NazionalitaFilm>IT</NazionalitaFilm>`
          );
        }
        corrections.push({
          field: 'NazionalitaFilm',
          original: 'Mancante',
          corrected: 'IT',
          reason: `Nazionalità film richiesta per genere ${effectiveGenreCode} (${requirements.description})`,
          siaeErrorPrevented: '2112'
        });
      }
    }
  }
  
  // ==================== 7. CORREZIONE NAZIONALITÀ FILM ISO 3166 ====================
  const nazionalitaMatch = correctedXml.match(/<NazionalitaFilm>([^<]*)<\/NazionalitaFilm>/);
  if (nazionalitaMatch) {
    const nazionalita = nazionalitaMatch[1].toUpperCase().trim();
    if (!VALID_ISO_3166_CODES.has(nazionalita)) {
      // Codice non valido, usa IT di default
      correctedXml = correctedXml.replace(nazionalitaMatch[0], '<NazionalitaFilm>IT</NazionalitaFilm>');
      corrections.push({
        field: 'NazionalitaFilm',
        original: nazionalita,
        corrected: 'IT',
        reason: 'Codice ISO 3166 non valido, impostato Italia (IT)',
        siaeErrorPrevented: '2112'
      });
    } else if (nazionalita !== nazionalitaMatch[1]) {
      // Normalizza a maiuscolo
      correctedXml = correctedXml.replace(nazionalitaMatch[0], `<NazionalitaFilm>${nazionalita}</NazionalitaFilm>`);
      corrections.push({
        field: 'NazionalitaFilm',
        original: nazionalitaMatch[1],
        corrected: nazionalita,
        reason: 'Normalizzato a maiuscolo',
        siaeErrorPrevented: '2112'
      });
    }
  }
  
  // ==================== 8. CORREZIONE CODICE LOCALE (13 cifre) ====================
  const codiceLocaleMatch = correctedXml.match(/<CodiceLocale>([^<]*)<\/CodiceLocale>/);
  if (codiceLocaleMatch) {
    const codice = codiceLocaleMatch[1].replace(/\D/g, ''); // Rimuovi non-cifre
    if (codice.length !== 13) {
      const correctedCodice = codice.padStart(13, '0').substring(0, 13);
      correctedXml = correctedXml.replace(codiceLocaleMatch[0], `<CodiceLocale>${correctedCodice}</CodiceLocale>`);
      corrections.push({
        field: 'CodiceLocale',
        original: codiceLocaleMatch[1],
        corrected: correctedCodice,
        reason: 'Normalizzato a 13 cifre con padding',
        siaeErrorPrevented: '3203'
      });
    }
  }
  
  // ==================== 9. CORREZIONE CODICE FISCALE (11-16 caratteri) ====================
  const cfMatches = correctedXml.match(/<CodiceFiscale>([^<]*)<\/CodiceFiscale>/g);
  if (cfMatches) {
    for (const match of cfMatches) {
      const innerMatch = match.match(/<CodiceFiscale>([^<]*)<\/CodiceFiscale>/);
      if (innerMatch) {
        const cf = innerMatch[1].toUpperCase().replace(/\s/g, '');
        if (cf.length < 11 || cf.length > 16) {
          uncorrectableErrors.push({
            field: 'CodiceFiscale',
            message: `Codice fiscale "${cf}" ha lunghezza non valida (${cf.length} caratteri, richiesti 11-16)`,
            siaeErrorCode: '3111'
          });
        } else if (cf !== innerMatch[1]) {
          // Normalizza (maiuscolo, senza spazi)
          correctedXml = correctedXml.replace(match, `<CodiceFiscale>${cf}</CodiceFiscale>`);
          corrections.push({
            field: 'CodiceFiscale',
            original: innerMatch[1],
            corrected: cf,
            reason: 'Normalizzato a maiuscolo senza spazi',
            siaeErrorPrevented: '3111'
          });
        }
      }
    }
  }
  
  // ==================== 10. RIMOZIONE DOCTYPE (causa errore 40605) ====================
  if (correctedXml.includes('<!DOCTYPE')) {
    correctedXml = correctedXml.replace(/<!DOCTYPE[^>]*>/g, '');
    corrections.push({
      field: 'DOCTYPE',
      original: 'Presente',
      corrected: 'Rimosso',
      reason: 'DOCTYPE non risolto da WS SIAE (XXE protection)',
      siaeErrorPrevented: '40605'
    });
  }
  
  return {
    correctedXml,
    corrections,
    uncorrectableErrors
  };
}

// ==================== PRE-TRANSMISSION VALIDATION ====================

/**
 * VALIDAZIONE CENTRALIZZATA PRE-TRASMISSIONE SIAE
 * 
 * Funzione di validazione unificata che esegue TUTTI i controlli preventivi
 * prima della trasmissione di un report SIAE. Previene gli errori più comuni:
 * - 0600/0603: Incoerenza codice sistema tra XML e nome file
 * - 40603: Encoding UTF-8 non valido
 * - 40601: Formato XML errato
 * - 40605: Impossibile estrarre informazioni (struttura XML)
 * 
 * NOTA: Chiamare autoCorrectSiaeXml() PRIMA di questa funzione per correggere
 * automaticamente gli errori risolvibili.
 * 
 * @param xml - Contenuto XML del report da validare
 * @param systemCode - Codice sistema SIAE (8 caratteri)
 * @param reportType - Tipo di report: 'giornaliero' | 'mensile' | 'rca'
 * @param reportDate - Data del report (per coerenza date)
 * @param denominazione - Denominazione titolare (max 60 char)
 * @param performer - Nome performer/artista (max 100 char)
 * @param transmissionSystemCode - Codice sistema salvato nella trasmissione (se esiste), usato per verificare coerenza
 * @returns Risultato validazione con errori, warning e dettagli
 */
export async function validatePreTransmission(
  xml: string,
  systemCode: string,
  reportType: 'giornaliero' | 'mensile' | 'rca',
  reportDate: Date | string,
  denominazione?: string,
  performer?: string,
  transmissionSystemCode?: string
): Promise<PreTransmissionValidationResult> {
  const errors: PreTransmissionValidationResult['errors'] = [];
  const warnings: PreTransmissionValidationResult['warnings'] = [];
  
  const details = {
    xmlValid: false,
    systemCodeConsistent: false,
    encodingValid: false,
    fieldLengthsValid: false,
    datesCoherent: false
  };
  
  // ==================== 0. VALIDAZIONE CODICE SISTEMA (FIX 2026-01-16) ====================
  // BLOCCO PRIMARIO: Il codice sistema EVENT4U1 NON è registrato presso SIAE e causa errore 0600
  // Questa validazione deve essere eseguita PRIMA di qualsiasi altra operazione
  const systemCodeFormatValidation = validateSiaeSystemCode(systemCode);
  if (!systemCodeFormatValidation.valid) {
    errors.push({
      code: 'INVALID_SYSTEM_CODE',
      field: 'systemCode',
      message: systemCodeFormatValidation.error || 'Codice sistema non valido',
      resolution: systemCodeFormatValidation.isDefault 
        ? 'Configurare il codice sistema SIAE in Impostazioni > SIAE > Configurazione Sistema, oppure collegare una Smart Card attiva tramite Desktop Bridge.'
        : 'Verificare il formato del codice sistema. Codici test: P + 7 cifre (es: P0004010)',
      siaeErrorCode: '0600'
    });
    // Ritorna subito con errore bloccante - non ha senso continuare con codice non valido
    return {
      canTransmit: false,
      errors,
      warnings,
      details
    };
  }
  
  // ==================== 1. VALIDAZIONE ENCODING UTF-8 ====================
  try {
    // Verifica che l'XML sia UTF-8 e non contenga caratteri non-ASCII non escaped
    const encoder = new TextEncoder();
    const encoded = encoder.encode(xml);
    
    // Verifica dichiarazione encoding
    if (!xml.includes('encoding="UTF-8"') && !xml.includes("encoding='UTF-8'")) {
      warnings.push({
        code: 'ENCODING_NOT_DECLARED',
        field: 'encoding',
        message: 'Encoding UTF-8 non dichiarato esplicitamente nell\'XML',
        suggestion: 'Aggiungere encoding="UTF-8" nella dichiarazione XML'
      });
    }
    
    // Verifica che non ci siano caratteri UTF-8 non validi
    const decoder = new TextDecoder('utf-8', { fatal: true });
    try {
      decoder.decode(encoded);
      details.encodingValid = true;
    } catch {
      errors.push({
        code: 'ENCODING_INVALID',
        field: 'encoding',
        message: 'Contenuto XML contiene caratteri non validi UTF-8',
        resolution: 'Verificare che tutti i caratteri speciali siano correttamente escaped',
        siaeErrorCode: '40603'
      });
    }
  } catch (e) {
    errors.push({
      code: 'ENCODING_ERROR',
      field: 'encoding',
      message: 'Errore nella verifica dell\'encoding: ' + (e instanceof Error ? e.message : String(e)),
      siaeErrorCode: '40603'
    });
  }
  
  // ==================== 2. VALIDAZIONE STRUTTURA XML ====================
  const xmlValidation = validateSiaeXml(xml, reportType);
  if (!xmlValidation.valid) {
    // FIX 2026-01-15: Aggiunge SEMPRE un errore bloccante se XML non valido
    // Anche se xmlValidation.errors è vuoto, l'errore deve essere generato
    errors.push({
      code: 'XML_STRUCTURE_INVALID',
      field: 'xml',
      message: xmlValidation.errors.length > 0 
        ? `Struttura XML non valida: ${xmlValidation.errors.join('; ')}`
        : 'Struttura XML non valida: errore di parsing',
      resolution: 'Verificare che l\'XML sia conforme alla DTD SIAE',
      siaeErrorCode: '40601'
    });
    details.xmlValid = false;
  } else {
    details.xmlValid = true;
  }
  
  // Aggiungi warning dalla validazione XML
  for (const warning of xmlValidation.warnings) {
    warnings.push({
      code: 'XML_WARNING',
      field: 'xml',
      message: warning
    });
  }
  
  // ==================== 2b. VALIDAZIONE DTD COMPLETA (FIX 2026-01-16) ====================
  // Chiamata al nuovo validator DTD che controlla:
  // - Ordine attributi secondo DTD v0039
  // - Attributi non validi (es. NomeFile)
  // - Struttura elementi obbligatori
  // - Valori attributi (es. Sostituzione: N|S)
  try {
    const { validateSiaeXML } = await import('./siae-xml-validator');
    const dtdValidation = validateSiaeXML(xml);
    
    // Aggiungi errori DTD
    for (const dtdError of dtdValidation.errors) {
      errors.push({
        code: dtdError.code,
        field: dtdError.element || 'xml',
        message: dtdError.message,
        resolution: dtdError.expected ? `Valore atteso: ${dtdError.expected}` : undefined,
        siaeErrorCode: dtdError.code === 'INVALID_ATTRIBUTE' ? '0600' : 
                       dtdError.code === 'MISSING_ATTRIBUTE' ? '40601' : 
                       dtdError.code === 'INVALID_ATTRIBUTE_VALUE' ? '40605' : undefined
      });
    }
    
    // Aggiungi warning DTD
    for (const dtdWarning of dtdValidation.warnings) {
      warnings.push({
        code: dtdWarning.code,
        field: dtdWarning.element || 'xml',
        message: dtdWarning.message,
        suggestion: dtdWarning.expected ? `Valore consigliato: ${dtdWarning.expected}` : undefined
      });
    }
    
    if (!dtdValidation.valid) {
      details.xmlValid = false;
    }
    
    console.log(`[SIAE-UTILS] DTD validation result: ${dtdValidation.valid ? 'VALID' : 'INVALID'} (type: ${dtdValidation.reportType}, errors: ${dtdValidation.errors.length}, warnings: ${dtdValidation.warnings.length})`);
  } catch (dtdError) {
    console.warn('[SIAE-UTILS] DTD validator import failed, skipping DTD validation:', dtdError);
  }
  
  // ==================== 3. VALIDAZIONE COERENZA CODICE SISTEMA ====================
  const systemCodeValidation = validateSystemCodeConsistency(xml, systemCode);
  if (!systemCodeValidation.valid) {
    details.systemCodeConsistent = false;
    errors.push({
      code: 'SYSTEM_CODE_MISMATCH',
      field: 'systemCode',
      message: systemCodeValidation.error || 'Codice sistema non coerente',
      siaeErrorCode: '0600'
    });
  } else {
    details.systemCodeConsistent = true;
  }
  
  // ==================== 4. VALIDAZIONE LUNGHEZZE CAMPI ====================
  let fieldLengthsValid = true;
  
  // Denominazione: max 60 caratteri
  if (denominazione) {
    if (denominazione.length > 60) {
      fieldLengthsValid = false;
      errors.push({
        code: 'DENOMINAZIONE_TOO_LONG',
        field: 'denominazione',
        message: `Denominazione titolare è troppo lunga: ${denominazione.length} caratteri (max 60)`,
        resolution: 'Ridurre la denominazione a massimo 60 caratteri',
        siaeErrorCode: '2606'
      });
    }
  }
  
  // Performer: max 100 caratteri
  if (performer) {
    if (performer.length > 100) {
      fieldLengthsValid = false;
      errors.push({
        code: 'PERFORMER_TOO_LONG',
        field: 'performer',
        message: `Nome performer è troppo lungo: ${performer.length} caratteri (max 100)`,
        resolution: 'Ridurre il nome performer a massimo 100 caratteri',
        siaeErrorCode: '40605'
      });
    }
  }
  
  // Verifica lunghezze nel contenuto XML
  const denominazioneMatch = xml.match(/<Denominazione>([^<]*)<\/Denominazione>/);
  if (denominazioneMatch && denominazioneMatch[1].length > 60) {
    fieldLengthsValid = false;
    errors.push({
      code: 'XML_DENOMINAZIONE_TOO_LONG',
      field: 'denominazione',
      message: `Denominazione nell'XML è troppo lunga: ${denominazioneMatch[1].length} caratteri (max 60)`,
      resolution: 'Modificare la denominazione nel XML a massimo 60 caratteri',
      siaeErrorCode: '2606'
    });
  }
  
  details.fieldLengthsValid = fieldLengthsValid;
  
  // ==================== 5. VALIDAZIONE COERENZA DATE ====================
  let datesCoherent = true;
  const reportDateObj = typeof reportDate === 'string' ? new Date(reportDate) : reportDate;
  
  // FIX 2026-01-16: DataGenerazione deve essere la data di CREAZIONE del file (oggi),
  // NON la data del periodo del report. Per report di date passate, DataGenerazione è comunque oggi.
  const actualToday = new Date().toISOString().split('T')[0].replace(/-/g, ''); // Data reale odierna YYYYMMDD
  const reportDateStr = reportDateObj.toISOString().split('T')[0].replace(/-/g, ''); // Data periodo report YYYYMMDD
  
  // Tolleranza mezzanotte - accetta anche ieri
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayStr = yesterday.toISOString().split('T')[0].replace(/-/g, '');
  
  // FIX 2026-01-17: RCA usa elementi (non attributi) per le date
  // RCA: <DataGenerazioneRiepilogo>yyyyMMdd</DataGenerazioneRiepilogo>, <DataRiepilogo>yyyyMMdd</DataRiepilogo>
  // RMG/RPM: DataGenerazione="yyyyMMdd" (attributo)
  if (reportType === 'rca') {
    // ==================== VALIDAZIONE DATE RCA (ELEMENTI) ====================
    
    // 1. DataGenerazioneRiepilogo deve essere la data odierna
    const dataGenRiepilogoMatch = xml.match(/<DataGenerazioneRiepilogo>([^<]+)<\/DataGenerazioneRiepilogo>/);
    if (dataGenRiepilogoMatch) {
      const xmlDate = dataGenRiepilogoMatch[1]; // Formato: YYYYMMDD
      
      if (xmlDate !== actualToday && xmlDate !== yesterdayStr) {
        datesCoherent = false;
        errors.push({
          code: 'DATE_MISMATCH',
          field: 'dates',
          message: `DataGenerazioneRiepilogo (${xmlDate}) non corrisponde alla data odierna (${actualToday})`,
          resolution: 'Rigenerare il report per aggiornare DataGenerazioneRiepilogo alla data corrente',
          siaeErrorCode: '0603'
        });
      }
    } else {
      datesCoherent = false;
      errors.push({
        code: 'MISSING_DATA_GENERAZIONE_RIEPILOGO',
        field: 'DataGenerazioneRiepilogo',
        message: 'Elemento DataGenerazioneRiepilogo mancante nell\'XML RCA',
        resolution: 'Verificare che l\'XML RCA contenga <DataGenerazioneRiepilogo>',
        siaeErrorCode: '0603'
      });
    }
    
    // 2. FIX 2026-01-17: DataRiepilogo DEVE corrispondere alla data nel nome file!
    // SIAE Error 0603: "Le date dell'oggetto, del nome file, e del contenuto del riepilogo non sono coerenti"
    // Nome file RCA: RCA_yyyyMMdd_SSSSSSSS_nnn.xsi
    // DataRiepilogo deve essere ESATTAMENTE uguale a yyyyMMdd nel nome file
    const dataRiepilogoMatch = xml.match(/<DataRiepilogo>([^<]+)<\/DataRiepilogo>/);
    if (dataRiepilogoMatch) {
      const xmlDataRiepilogo = dataRiepilogoMatch[1]; // Formato: YYYYMMDD
      
      // DataRiepilogo deve corrispondere a reportDateStr (data dell'evento = data nel nome file)
      if (xmlDataRiepilogo !== reportDateStr) {
        datesCoherent = false;
        errors.push({
          code: 'DATA_RIEPILOGO_MISMATCH',
          field: 'DataRiepilogo',
          message: `DataRiepilogo (${xmlDataRiepilogo}) non corrisponde alla data evento/nome file (${reportDateStr})`,
          resolution: 'La DataRiepilogo nell\'XML deve corrispondere alla data nel nome file RCA',
          siaeErrorCode: '0603'
        });
      }
    } else {
      datesCoherent = false;
      errors.push({
        code: 'MISSING_DATA_RIEPILOGO',
        field: 'DataRiepilogo',
        message: 'Elemento DataRiepilogo mancante nell\'XML RCA',
        resolution: 'Verificare che l\'XML RCA contenga <DataRiepilogo>',
        siaeErrorCode: '0603'
      });
    }
    
  } else {
    // ==================== VALIDAZIONE DATE RMG/RPM (ATTRIBUTI) ====================
    
    // Estrai DataGenerazione dall'XML (attributo)
    const dataGenerazioneMatch = xml.match(/DataGenerazione="([^"]+)"/);
    if (dataGenerazioneMatch) {
      const xmlDate = dataGenerazioneMatch[1]; // Formato: YYYYMMDD
      
      // DataGenerazione deve essere la data odierna (quando è stato generato il file)
      if (xmlDate !== actualToday && xmlDate !== yesterdayStr) {
        datesCoherent = false;
        errors.push({
          code: 'DATE_MISMATCH',
          field: 'dates',
          message: `DataGenerazione (${xmlDate}) non corrisponde alla data odierna (${actualToday})`,
          resolution: 'Rigenerare il report per aggiornare DataGenerazione alla data corrente',
          siaeErrorCode: '0603'
        });
      }
    }
    
    // Verifica Mese attributo (per report mensile)
    // FIX 2026-01-16: L'attributo Mese deve corrispondere al PERIODO del report, non a oggi
    if (reportType === 'mensile') {
      const meseMatch = xml.match(/Mese="([^"]+)"/);
      if (meseMatch) {
        const mese = meseMatch[1]; // Formato: YYYYMM
        const reportMonth = reportDateStr.substring(0, 6); // YYYYMM del periodo richiesto
        if (mese !== reportMonth) {
          datesCoherent = false;
          errors.push({
            code: 'MONTH_MISMATCH',
            field: 'month',
            message: `Attributo Mese (${mese}) non corrisponde al periodo richiesto (${reportMonth})`,
            resolution: 'Verificare che l\'attributo Mese corrisponda al mese del report',
            siaeErrorCode: '0603'
          });
        }
        
        // FIX 2026-01-18: RPM non può essere inviato per un mese non ancora concluso
        // La SIAE richiede che DataGenerazione sia nel mese SUCCESSIVO al periodo di riferimento
        // Es: RPM per gennaio 2026 (Mese="202601") deve avere DataGenerazione >= febbraio 2026
        const meseYear = parseInt(mese.substring(0, 4), 10);
        const meseMonth = parseInt(mese.substring(4, 6), 10);
        const dataGenYear = parseInt(actualToday.substring(0, 4), 10);
        const dataGenMonth = parseInt(actualToday.substring(4, 6), 10);
        
        // Calcola se siamo nel mese successivo o oltre
        const isAfterReportMonth = 
          dataGenYear > meseYear || 
          (dataGenYear === meseYear && dataGenMonth > meseMonth);
        
        if (!isAfterReportMonth) {
          datesCoherent = false;
          errors.push({
            code: 'RPM_MONTH_NOT_CONCLUDED',
            field: 'month',
            message: `Impossibile inviare RPM per ${mese}: il mese non è ancora concluso. DataGenerazione=${actualToday} ma Mese=${mese}`,
            resolution: `Attendere il primo giorno del mese successivo (${meseMonth === 12 ? meseYear + 1 : meseYear}${String((meseMonth % 12) + 1).padStart(2, '0')}) per inviare il riepilogo mensile`,
            siaeErrorCode: '0603'
          });
        }
      }
      
      // FIX 2026-01-18: Verifica che non ci siano eventi futuri nel riepilogo
      // La SIAE non accetta riepiloghi con DataEvento nel futuro
      const dataEventoMatches = Array.from(xml.matchAll(/<DataEvento>(\d{8})<\/DataEvento>/g));
      for (const match of dataEventoMatches) {
        const eventDate = match[1]; // YYYYMMDD
        if (eventDate > actualToday) {
          datesCoherent = false;
          errors.push({
            code: 'FUTURE_EVENT_DATE',
            field: 'DataEvento',
            message: `Il riepilogo contiene un evento con data futura: ${eventDate} (oggi è ${actualToday})`,
            resolution: `Rimuovere gli eventi futuri dal riepilogo o attendere che l'evento si sia svolto`,
            siaeErrorCode: '0603'
          });
        }
      }
    }
    
    // Verifica Data attributo (per report giornaliero)
    // FIX 2026-01-16: L'attributo Data deve corrispondere al PERIODO del report, non a oggi
    if (reportType === 'giornaliero') {
      const dataMatch = xml.match(/Data="([^"]+)"/);
      if (dataMatch) {
        const data = dataMatch[1]; // Formato: YYYYMMDD
        if (data !== reportDateStr) {
          datesCoherent = false;
          errors.push({
            code: 'DAY_MISMATCH',
            field: 'day',
            message: `Attributo Data (${data}) non corrisponde al periodo richiesto (${reportDateStr})`,
            resolution: 'Verificare che l\'attributo Data corrisponda alla data del report',
            siaeErrorCode: '0603'
          });
        }
      }
    }
  }
  
  details.datesCoherent = datesCoherent;
  
  // ==================== 6. VALIDAZIONE TRANSMISSION SYSTEM CODE ====================
  // Confronta il systemCode della trasmissione salvata (se disponibile) con quello risolto ora
  // Previene l'invio di trasmissioni con codice sistema incoerente nel database
  if (transmissionSystemCode && transmissionSystemCode !== systemCode) {
    errors.push({
      code: 'TRANSMISSION_SYSTEM_CODE_MISMATCH',
      field: 'systemCode',
      message: `Il codice sistema salvato nella trasmissione (${transmissionSystemCode}) non corrisponde al codice sistema risolto (${systemCode})`,
      resolution: 'Aggiornare il record di trasmissione con il codice sistema corretto prima di reinviare',
      siaeErrorCode: '0600'
    });
  }
  
  // ==================== 7. VALIDAZIONE OBBLIGATORIA ELEMENTI ====================
  // FIX 2026-01-17: RCA usa elementi diversi da RMG/RPM
  if (reportType === 'rca') {
    // RCA usa DenominazioneTitolareCA, CFTitolareCA, CodiceSistemaCA
    const rcaRequiredElements = ['Titolare', 'DenominazioneTitolareCA', 'CFTitolareCA', 'CodiceSistemaCA', 'DataRiepilogo'];
    for (const elem of rcaRequiredElements) {
      if (!xml.includes(`<${elem}>`)) {
        errors.push({
          code: `MISSING_${elem.toUpperCase().replace(/[^A-Z0-9]/g, '_')}`,
          field: elem,
          message: `Elemento RCA obbligatorio mancante: <${elem}>`,
          siaeErrorCode: '40605'
        });
      }
    }
  } else {
    // RMG/RPM usano Denominazione, CodiceFiscale
    const requiredElements = ['Titolare', 'Denominazione', 'CodiceFiscale'];
    for (const elem of requiredElements) {
      if (!xml.includes(`<${elem}>`)) {
        errors.push({
          code: `MISSING_${elem.toUpperCase()}`,
          field: elem,
          message: `Elemento obbligatorio mancante: <${elem}>`,
          siaeErrorCode: '40605'
        });
      }
    }
  }
  
  // ==================== 8. VALIDAZIONE ATTRIBUTI/ELEMENTI GENERAZIONE ====================
  // FIX 2026-01-17: RCA usa elementi, RMG/RPM usano attributi
  if (reportType === 'rca') {
    // RCA usa elementi per le date di generazione (già validati in sezione 5)
    // Verifica solo ProgressivoRiepilogo
    if (!xml.includes('<ProgressivoRiepilogo>')) {
      errors.push({
        code: 'MISSING_PROGRESSIVO_RIEPILOGO',
        field: 'ProgressivoRiepilogo',
        message: 'Elemento obbligatorio mancante: <ProgressivoRiepilogo>',
        siaeErrorCode: '40605'
      });
    }
    if (!xml.includes('<OraGenerazioneRiepilogo>')) {
      errors.push({
        code: 'MISSING_ORA_GENERAZIONE_RIEPILOGO',
        field: 'OraGenerazioneRiepilogo',
        message: 'Elemento obbligatorio mancante: <OraGenerazioneRiepilogo>',
        siaeErrorCode: '40605'
      });
    }
  } else {
    // RMG/RPM usano attributi per le date di generazione
    const requiredAttributes = ['DataGenerazione', 'OraGenerazione', 'ProgressivoGenerazione'];
    for (const attr of requiredAttributes) {
      if (!xml.includes(`${attr}="`)) {
        errors.push({
          code: `MISSING_ATTR_${attr.toUpperCase()}`,
          field: attr,
          message: `Attributo obbligatorio mancante: ${attr}`,
          siaeErrorCode: '40605'
        });
      }
    }
  }
  
  // ==================== CALCOLO RISULTATO FINALE ====================
  // FIX 2026-01-15: canTransmit è TRUE solo se TUTTI i dettagli sono validi E non ci sono errori
  const allDetailsValid = details.xmlValid && 
                          details.systemCodeConsistent && 
                          details.encodingValid && 
                          details.fieldLengthsValid && 
                          details.datesCoherent;
  const canTransmit = errors.length === 0 && allDetailsValid;
  
  return {
    canTransmit,
    errors,
    warnings,
    details
  };
}

// ==================== C1 XML Generation (Unified) ====================

/**
 * Parameters for unified C1 XML generation
 * Supports both daily (RMG) and monthly (RPM) reports
 */
export interface C1XmlParams {
  reportKind: 'giornaliero' | 'mensile';
  companyId: string;
  reportDate: Date;
  resolvedSystemCode: string;
  progressivo: number;
  taxId: string;
  businessName: string;
  events: C1EventContext[];
  subscriptions?: C1SubscriptionData[];
}

/**
 * Event context with all pre-hydrated data
 */
export interface C1EventContext {
  ticketedEvent: {
    id: string;
    companyId: string;
    eventId: string;
    siaeLocationCode?: string | null;
    capacity?: number | null;
    taxType?: string | null;
    entertainmentIncidence?: number | null;
    genreCode?: string | null;
    genreIncidence?: number | null;
    author?: string | null;
    performer?: string | null;
    organizerType?: string | null;
  };
  eventRecord: {
    id: string;
    name?: string;
    startDatetime?: Date | string;
    locationId?: string;
  } | null;
  location?: {
    name?: string;
    siaeLocationCode?: string | null;
  } | null;
  sectors: C1SectorData[];
  tickets: C1TicketData[];
}

/**
 * Sector data for C1 report
 */
export interface C1SectorData {
  id: string;
  sectorCode?: string | null;
  orderCode?: string | null;
  capacity?: number | null;
}

/**
 * Ticket data for C1 report
 */
export interface C1TicketData {
  id: string;
  ticketedEventId: string;
  sectorId?: string | null;
  status: string;
  ticketTypeCode?: string | null;
  isComplimentary?: boolean;
  grossAmount?: string | number | null;
  prevendita?: string | number | null;
  vatAmount?: string | number | null;
  prevenditaVat?: string | number | null;
  serviceAmount?: string | number | null;
  cancellationReasonCode?: string | null;
  cancellationDate?: Date | null;
}

/**
 * Subscription data for C1 report
 */
export interface C1SubscriptionData {
  id: string;
  subscriptionCode: string;
  ticketedEventId?: string | null;
  sectorId?: string | null;
  validTo?: Date | string;
  createdAt?: Date;
  taxType?: string | null;
  turnType?: string | null;
  ticketTypeCode?: string | null;
  isComplimentary?: boolean;
  status: string;
  totalAmount?: string | number | null;
  rateoVat?: string | number | null;
  eventsCount?: number | null;
}

/**
 * Result from C1 XML generation
 */
export interface C1XmlResult {
  xml: string;
  stats: {
    ticketsCount: number;
    totalRevenue: number;
    eventsCount: number;
    subscriptionsCount: number;
  };
}

/**
 * Generate C1 XML Report (RiepilogoGiornaliero or RiepilogoMensile)
 * Unified function that replaces both generateC1ReportXml (routes) and generateC1StyleXml (scheduler)
 * 
 * Conforme al tracciato SIAE Allegato B - Provvedimento 04/03/2008
 * Importi in centesimi (interi), struttura con Abbonamenti
 * 
 * @param params - All required parameters with pre-hydrated data
 * @returns XML string and statistics
 */
export function generateC1Xml(params: C1XmlParams): C1XmlResult {
  const {
    reportKind,
    companyId,
    reportDate,
    resolvedSystemCode,
    progressivo,
    taxId,
    businessName,
    events,
    subscriptions = []
  } = params;

  const isMonthly = reportKind === 'mensile';
  const now = new Date();
  const dataGenAttr = formatSiaeDateCompact(now);
  const oraGen = formatSiaeTimeCompact(now);

  let periodAttrName: string;
  let periodAttrValue: string;

  if (isMonthly) {
    periodAttrName = 'Mese';
    periodAttrValue = `${reportDate.getFullYear()}${String(reportDate.getMonth() + 1).padStart(2, '0')}`;
  } else {
    periodAttrName = 'Data';
    periodAttrValue = formatSiaeDateCompact(reportDate);
  }

  const sostituzione = progressivo > 1 ? 'S' : 'N';
  const progressivePadded = String(progressivo).padStart(3, '0');

  // FIX 2026-01-18: Per report giornaliero (RMG), 0 biglietti è permesso
  // Per report mensile (RPM), rimane un errore bloccante
  if (events.length === 0 && subscriptions.length === 0) {
    if (isMonthly) {
      throw new Error('SIAE_NO_EVENTS: Nessun biglietto o abbonamento trovato per il periodo richiesto. Il report C1 mensile richiede almeno un evento con biglietti emessi.');
    }
    // Per giornaliero, genera un report vuoto con warning nel log
    console.warn('[generateC1Xml] Report giornaliero senza eventi/abbonamenti - generazione report vuoto');
  }

  let eventsXml = '';
  const DEFAULT_SECTOR_KEY = '__DEFAULT__';
  let totalTicketsCount = 0;
  let totalRevenue = 0;

  for (const eventContext of events) {
    const { ticketedEvent, eventRecord, location, sectors, tickets } = eventContext;
    if (!eventRecord) continue;

    const venueName = location?.name || 'N/D';
    const rawVenueCode = ticketedEvent.siaeLocationCode || location?.siaeLocationCode || '0000000000001';
    const venueCode = rawVenueCode.replace(/\D/g, '').padStart(13, '0').substring(0, 13);

    const eventDate = new Date(eventRecord.startDatetime || reportDate);
    const eventDateStr = formatSiaeDateCompact(eventDate);
    const eventTimeStr = formatSiaeTimeHHMM(eventDate);

    const ticketsBySector: Map<string, C1TicketData[]> = new Map();
    for (const ticket of tickets) {
      const sectorKey = ticket.sectorId || DEFAULT_SECTOR_KEY;
      if (!ticketsBySector.has(sectorKey)) {
        ticketsBySector.set(sectorKey, []);
      }
      ticketsBySector.get(sectorKey)!.push(ticket);
    }

    let sectorsXml = '';
    for (const [sectorKey, sectorTickets] of Array.from(ticketsBySector.entries())) {
      let codiceOrdine = normalizeSiaeCodiceOrdine(null);
      let capacity = ticketedEvent.capacity || 100;

      if (sectorKey !== DEFAULT_SECTOR_KEY) {
        const sector = sectors.find(s => s.id === sectorKey);
        if (sector) {
          codiceOrdine = normalizeSiaeCodiceOrdine(sector.sectorCode || sector.orderCode);
          capacity = sector.capacity || capacity;
        }
      }

      const ticketsByType: Map<string, C1TicketData[]> = new Map();
      for (const ticket of sectorTickets) {
        const tipoTitolo = normalizeSiaeTipoTitolo(ticket.ticketTypeCode, ticket.isComplimentary);
        if (tipoTitolo === 'ABB') continue;
        if (!ticketsByType.has(tipoTitolo)) {
          ticketsByType.set(tipoTitolo, []);
        }
        ticketsByType.get(tipoTitolo)!.push(ticket);
      }

      let titoliAccessoXml = '';
      let totalOmaggiIva = 0;

      for (const [tipoTitolo, typeTickets] of Array.from(ticketsByType.entries())) {
        const validTickets = typeTickets.filter((t: C1TicketData) =>
          !isCancelledStatus(t.status) && !t.cancellationReasonCode && !t.cancellationDate
        );

        if (validTickets.length === 0) continue;

        const quantita = validTickets.length;
        totalTicketsCount += quantita;

        const corrispettivoLordo = toCentesimi(validTickets.reduce((sum: number, t: C1TicketData) => sum + parseFloat(String(t.grossAmount || '0')), 0));
        const prevendita = toCentesimi(validTickets.reduce((sum: number, t: C1TicketData) => sum + parseFloat(String(t.prevendita || '0')), 0));
        const ivaCorrispettivo = toCentesimi(validTickets.reduce((sum: number, t: C1TicketData) => sum + parseFloat(String(t.vatAmount || '0')), 0));
        const ivaPrevendita = toCentesimi(validTickets.reduce((sum: number, t: C1TicketData) => sum + parseFloat(String(t.prevenditaVat || '0')), 0));
        const importoPrestazione = toCentesimi(validTickets.reduce((sum: number, t: C1TicketData) => sum + parseFloat(String(t.serviceAmount || '0')), 0));

        totalRevenue += corrispettivoLordo;

        if (tipoTitolo === 'O1') {
          totalOmaggiIva += ivaCorrispettivo;
        }

        titoliAccessoXml += `
                <TitoliAccesso>
                    <TipoTitolo>${escapeXml(tipoTitolo)}</TipoTitolo>
                    <Quantita>${quantita}</Quantita>
                    <CorrispettivoLordo>${corrispettivoLordo}</CorrispettivoLordo>
                    <Prevendita>${prevendita}</Prevendita>
                    <IVACorrispettivo>${ivaCorrispettivo}</IVACorrispettivo>
                    <IVAPrevendita>${ivaPrevendita}</IVAPrevendita>
                    <ImportoPrestazione>${importoPrestazione}</ImportoPrestazione>
                </TitoliAccesso>`;
      }

      if (isMonthly) {
        sectorsXml += `
            <OrdineDiPosto>
                <CodiceOrdine>${escapeXml(codiceOrdine)}</CodiceOrdine>
                <Capienza>${capacity}</Capienza>
                <IVAEccedenteOmaggi>${totalOmaggiIva}</IVAEccedenteOmaggi>${titoliAccessoXml}
            </OrdineDiPosto>`;
      } else {
        sectorsXml += `
            <OrdineDiPosto>
                <CodiceOrdine>${escapeXml(codiceOrdine)}</CodiceOrdine>
                <Capienza>${capacity}</Capienza>${titoliAccessoXml}
            </OrdineDiPosto>`;
      }
    }

    if (sectorsXml === '') {
      if (isMonthly) {
        sectorsXml = `
            <OrdineDiPosto>
                <CodiceOrdine>${normalizeSiaeCodiceOrdine(null)}</CodiceOrdine>
                <Capienza>${ticketedEvent.capacity || 100}</Capienza>
                <IVAEccedenteOmaggi>0</IVAEccedenteOmaggi>
            </OrdineDiPosto>`;
      } else {
        sectorsXml = `
            <OrdineDiPosto>
                <CodiceOrdine>${normalizeSiaeCodiceOrdine(null)}</CodiceOrdine>
                <Capienza>${ticketedEvent.capacity || 100}</Capienza>
            </OrdineDiPosto>`;
      }
    }

    const tipoTassazione = ticketedEvent.taxType || 'S';
    const incidenza = tipoTassazione === 'I' ? (ticketedEvent.entertainmentIncidence ?? 100) : 0;
    const imponibileIntrattenimenti = 0;
    const genreCode = mapToSiaeTipoGenere(ticketedEvent.genreCode);
    const incidenzaGenere = ticketedEvent.genreIncidence ?? 0;
    const eventName = eventRecord.name || 'Evento';

    const genreNum = parseInt(genreCode);
    const requiresPerformer = (genreNum >= 5 && genreNum <= 9) || (genreNum >= 45 && genreNum <= 59);

    let autoreXml = '';
    let esecutoreXml = '';
    if (requiresPerformer) {
      if (ticketedEvent.author) {
        autoreXml = `
                        <Autore>${escapeXml(ticketedEvent.author)}</Autore>`;
      }
      const performer = ticketedEvent.performer || eventName;
      esecutoreXml = `
                        <Esecutore>${escapeXml(performer)}</Esecutore>`;
    }

    let intrattenimentoXml: string;
    if (isMonthly) {
      intrattenimentoXml = `
            <Intrattenimento>
                <TipoTassazione valore="${escapeXml(tipoTassazione)}"/>
                <Incidenza>${incidenza}</Incidenza>
                <ImponibileIntrattenimenti>${imponibileIntrattenimenti}</ImponibileIntrattenimenti>
            </Intrattenimento>`;
    } else {
      if (tipoTassazione === 'I' && incidenza > 0) {
        intrattenimentoXml = `
            <Intrattenimento>
                <TipoTassazione valore="${escapeXml(tipoTassazione)}"/>
                <Incidenza>${incidenza}</Incidenza>
            </Intrattenimento>`;
      } else {
        intrattenimentoXml = `
            <Intrattenimento>
                <TipoTassazione valore="${escapeXml(tipoTassazione)}"/>
            </Intrattenimento>`;
      }
    }

    eventsXml += `
        <Evento>${intrattenimentoXml}
            <Locale>
                <Denominazione>${escapeXml(venueName)}</Denominazione>
                <CodiceLocale>${escapeXml(venueCode)}</CodiceLocale>
            </Locale>
            <DataEvento>${eventDateStr}</DataEvento>
            <OraEvento>${eventTimeStr}</OraEvento>
            <MultiGenere>
                <TipoGenere>${escapeXml(genreCode)}</TipoGenere>
                <IncidenzaGenere>${incidenzaGenere}</IncidenzaGenere>
                <TitoliOpere>
                    <Titolo>${escapeXml(eventName)}</Titolo>${autoreXml}${esecutoreXml}
                </TitoliOpere>
            </MultiGenere>${sectorsXml}
        </Evento>`;
  }

  let abbonamentiXml = '';
  if (subscriptions.length > 0) {
    const subsByCode: Map<string, C1SubscriptionData[]> = new Map();
    for (const sub of subscriptions) {
      const code = sub.subscriptionCode;
      if (!subsByCode.has(code)) {
        subsByCode.set(code, []);
      }
      subsByCode.get(code)!.push(sub);
    }

    for (const [subCode, subs] of Array.from(subsByCode.entries())) {
      const firstSub = subs[0];
      const validTo = new Date(firstSub.validTo || new Date());
      const validitaStr = formatSiaeDateCompact(validTo);

      let codiceOrdine = normalizeSiaeCodiceOrdine(null);
      if (firstSub.sectorId) {
        for (const event of events) {
          const sector = event.sectors.find(s => s.id === firstSub.sectorId);
          if (sector) {
            codiceOrdine = normalizeSiaeCodiceOrdine(sector.sectorCode || sector.orderCode);
            break;
          }
        }
      }

      const tipoTitolo = normalizeSiaeTipoTitolo(firstSub.ticketTypeCode, firstSub.isComplimentary);
      const subTipoTassazione = firstSub.taxType || 'S';
      const turno = firstSub.turnType || 'F';

      const emittedSubs = subs.filter((s: C1SubscriptionData) => s.status === 'active');
      const cancelledSubs = subs.filter((s: C1SubscriptionData) => s.status === 'cancelled');

      const emessiQuantita = emittedSubs.length;
      const emessiCorrispettivo = toCentesimi(emittedSubs.reduce((sum: number, s: C1SubscriptionData) => sum + parseFloat(String(s.totalAmount || '0')), 0));
      const emessiIva = toCentesimi(emittedSubs.reduce((sum: number, s: C1SubscriptionData) => sum + parseFloat(String(s.rateoVat || '0')), 0));

      const annullatiQuantita = cancelledSubs.length;
      const annullatiCorrispettivo = toCentesimi(cancelledSubs.reduce((sum: number, s: C1SubscriptionData) => sum + parseFloat(String(s.totalAmount || '0')), 0));
      const annullatiIva = toCentesimi(cancelledSubs.reduce((sum: number, s: C1SubscriptionData) => sum + parseFloat(String(s.rateoVat || '0')), 0));

      abbonamentiXml += `
        <Abbonamenti>
            <CodiceAbbonamento>${escapeXml(subCode)}</CodiceAbbonamento>
            <Validita>${validitaStr}</Validita>
            <TipoTassazione valore="${subTipoTassazione}"/>
            <Turno valore="${turno}"/>
            <CodiceOrdine>${codiceOrdine}</CodiceOrdine>
            <TipoTitolo>${tipoTitolo}</TipoTitolo>
            <QuantitaEventiAbilitati>${firstSub.eventsCount || 1}</QuantitaEventiAbilitati>
            <AbbonamentiEmessi>
                <Quantita>${emessiQuantita}</Quantita>
                <CorrispettivoLordo>${emessiCorrispettivo}</CorrispettivoLordo>
                <Prevendita>0</Prevendita>
                <IVACorrispettivo>${emessiIva}</IVACorrispettivo>
                <IVAPrevendita>0</IVAPrevendita>
            </AbbonamentiEmessi>
            <AbbonamentiAnnullati>
                <Quantita>${annullatiQuantita}</Quantita>
                <CorrispettivoLordo>${annullatiCorrispettivo}</CorrispettivoLordo>
                <Prevendita>0</Prevendita>
                <IVACorrispettivo>${annullatiIva}</IVACorrispettivo>
                <IVAPrevendita>0</IVAPrevendita>
            </AbbonamentiAnnullati>
        </Abbonamenti>`;
    }
  }

  const titolareName = businessName;
  const organizerName = businessName;
  const organizerTaxId = taxId;
  const organizerType = 'G';
  const rootElement = isMonthly ? 'RiepilogoMensile' : 'RiepilogoGiornaliero';

  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<${rootElement} Sostituzione="${sostituzione}" ${periodAttrName}="${periodAttrValue}" DataGenerazione="${dataGenAttr}" OraGenerazione="${oraGen}" ProgressivoGenerazione="${progressivePadded}">
    <Titolare>
        <Denominazione>${escapeXml(titolareName)}</Denominazione>
        <CodiceFiscale>${escapeXml(taxId)}</CodiceFiscale>
        <SistemaEmissione>${escapeXml(resolvedSystemCode)}</SistemaEmissione>
    </Titolare>
    <Organizzatore>
        <Denominazione>${escapeXml(organizerName)}</Denominazione>
        <CodiceFiscale>${escapeXml(organizerTaxId)}</CodiceFiscale>
        <TipoOrganizzatore valore="${organizerType}"/>${eventsXml}${abbonamentiXml}
    </Organizzatore>
</${rootElement}>`;

  return {
    xml,
    stats: {
      ticketsCount: totalTicketsCount,
      totalRevenue: totalRevenue / 100,
      eventsCount: events.length,
      subscriptionsCount: subscriptions.length
    }
  };
}


================================================================================
FILE: server/siae-scheduler.ts
================================================================================
import { db } from "./db";
import { siaeTicketedEvents, siaeTransmissions, siaeTransmissionSettings, events, companies, siaeEventSectors, siaeTickets, siaeResales } from "@shared/schema";
import { eq, and, sql, gte, lt, desc, lte } from "drizzle-orm";
import { siaeStorage } from "./siae-storage";
import { storage } from "./storage";
import type { SiaeTransmissionSettings } from "@shared/schema";
import { sendSiaeTransmissionEmail } from "./email-service";
import { isBridgeConnected, requestXmlSignature, getCachedEfffData } from "./bridge-relay";
import { escapeXml, formatSiaeDateCompact, formatSiaeTimeCompact, formatSiaeTimeHHMM, generateSiaeFileName, generateSiaeSubject, mapToSiaeTipoGenere, generateRCAXml, normalizeSiaeTipoTitolo, normalizeSiaeCodiceOrdine, validateSystemCodeConsistency, validatePreTransmission, resolveSystemCode, resolveSystemCodeForSmime, autoCorrectSiaeXml, SIAE_SYSTEM_CODE_DEFAULT, generateC1Xml, validateSiaeSystemCode, type RCAParams, type C1XmlParams, type C1EventContext, type C1SectorData, type C1TicketData, type C1SubscriptionData } from './siae-utils';
import { calculateTransmissionStats, calculateFileHash } from './siae-routes';

// Configurazione SIAE secondo Allegato B e C - Provvedimento Agenzia delle Entrate 04/03/2008
const SIAE_TEST_MODE = process.env.SIAE_TEST_MODE === 'true';
const SIAE_TEST_EMAIL = process.env.SIAE_TEST_EMAIL || 'servertest2@batest.siae.it';
// FIX 2026-01-15: Rimossa costante SIAE_SYSTEM_CODE locale - usare resolveSystemCode() per coerenza
const SIAE_VERSION = 'V.01.00';

function log(message: string) {
  const formattedTime = new Date().toLocaleTimeString("it-IT", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });
  console.log(`${formattedTime} [SIAE-Scheduler] ${message}`);
}

// Funzione generateSiaeFileName e generateSiaeSubject importate da ./siae-utils.ts
// Usata per nomi file e subject email (formato unificato)

/**
 * Genera subject email conforme a SIAE
 * @deprecated Usare generateSiaeSubject da siae-utils.ts direttamente
 * 
 * FIX 2026-01-16: Usa la funzione centralizzata per garantire coerenza
 * tra subject email e nome file allegato (errore SIAE 0603)
 */
export function generateSiaeEmailSubject(date: Date, systemCode: string, sequenceNumber: number): string {
  // Delega alla funzione centralizzata che garantisce coerenza con il nome file
  return generateSiaeSubject('rca', date, sequenceNumber, systemCode);
}

/**
 * Mappa codice genere evento a codice SIAE (2 caratteri numerici)
 * Re-export dalla funzione centralizzata in siae-utils.ts
 * @deprecated Usa mapToSiaeTipoGenere direttamente da siae-utils.ts
 */
export function mapGenreToSiae(genreCode: string | null): string {
  return mapToSiaeTipoGenere(genreCode);
}

/**
 * Determina tipo SpettacoloIntrattenimento secondo specifiche SIAE
 * S=spettacolo, I=intrattenimento, P=spettacolo digitale, N=intrattenimento digitale
 */
export function getSpettacoloIntrattenimentoCode(taxType: string | null, isDigital: boolean = false): string {
  if (taxType === 'S') return isDigital ? 'P' : 'S';
  return isDigital ? 'N' : 'I';
}

// Funzione per ottenere il progressivo giornaliero per evitare collisioni
async function getNextProgressivo(ticketedEventId: string, transmissionType: string, periodDate: Date): Promise<number> {
  const dateStr = periodDate.toISOString().split('T')[0];
  const startOfDay = new Date(dateStr + 'T00:00:00.000Z');
  const endOfDay = new Date(dateStr + 'T23:59:59.999Z');

  const existing = await db.select()
    .from(siaeTransmissions)
    .where(and(
      eq(siaeTransmissions.ticketedEventId, ticketedEventId),
      eq(siaeTransmissions.transmissionType, transmissionType),
      gte(siaeTransmissions.periodDate, startOfDay),
      lt(siaeTransmissions.periodDate, endOfDay)
    ));

  return existing.length + 1;
}

// Ottiene le impostazioni trasmissione globali (singleton)
async function getGlobalTransmissionSettings(): Promise<SiaeTransmissionSettings | null> {
  const [settings] = await db.select()
    .from(siaeTransmissionSettings)
    .where(eq(siaeTransmissionSettings.id, 'global'));
  return settings || null;
}

// Verifica se è passato l'intervallo richiesto dall'ultimo invio
function shouldSendBasedOnInterval(lastSentAt: Date | null, intervalDays: number): boolean {
  if (!lastSentAt) return true; // Mai inviato, procedi
  
  const now = new Date();
  const daysSinceLast = Math.floor((now.getTime() - lastSentAt.getTime()) / (1000 * 60 * 60 * 24));
  return daysSinceLast >= intervalDays;
}

// Verifica se un evento è terminato da N giorni
function eventEndedDaysAgo(eventEndDate: Date, delayDays: number): boolean {
  const now = new Date();
  const endDate = new Date(eventEndDate);
  const daysSinceEnd = Math.floor((now.getTime() - endDate.getTime()) / (1000 * 60 * 60 * 24));
  return daysSinceEnd >= delayDays;
}

// Verifica se oggi è il giorno del mese configurato per invio mensile
function isTodayMonthlyRecurringDay(recurringDay: number): boolean {
  const now = new Date();
  return now.getDate() === recurringDay;
}

async function generateC1ReportData(ticketedEvent: any, reportType: 'giornaliero' | 'mensile', reportDate: Date, progressivo: number = 1) {
  const company = await storage.getCompany(ticketedEvent.companyId);
  const sectors = await siaeStorage.getSiaeEventSectors(ticketedEvent.id);
  const allTickets = await siaeStorage.getSiaeTicketsByEvent(ticketedEvent.id);
  const eventRecord = await storage.getEvent(ticketedEvent.eventId);

  const isMonthly = reportType === 'mensile';
  const refDate = reportDate;
  const today = refDate.toISOString().split('T')[0];

  const getTicketPrice = (t: any) => Number(t.ticketPrice) || Number(t.grossAmount) || Number(t.priceAtPurchase) || 0;
  
  let filteredTickets: any[];
  if (isMonthly) {
    const startOfMonth = new Date(refDate.getFullYear(), refDate.getMonth(), 1);
    const endOfMonth = new Date(refDate.getFullYear(), refDate.getMonth() + 1, 0, 23, 59, 59);
    filteredTickets = allTickets.filter(t => {
      const ticketDate = new Date(t.createdAt!);
      return ticketDate >= startOfMonth && ticketDate <= endOfMonth;
    });
  } else {
    filteredTickets = allTickets.filter(t => {
      const ticketDate = t.createdAt?.toISOString().split('T')[0];
      return ticketDate === today;
    });
  }

  const activeTickets = filteredTickets.filter(t => t.status === 'emesso' || t.status === 'used');
  // Include both regular cancellations and resale annulments for SIAE compliance
  const cancelledTickets = filteredTickets.filter(t => 
    t.status === 'annullato' || t.status === 'annullato_rivendita'
  );

  // Recupera abbonamenti per il periodo
  let subscriptions: any[] = [];
  try {
    const allSubscriptions = await siaeStorage.getSiaeSubscriptionsByCompany(ticketedEvent.companyId);
    if (isMonthly) {
      const startOfMonth = new Date(refDate.getFullYear(), refDate.getMonth(), 1);
      const endOfMonth = new Date(refDate.getFullYear(), refDate.getMonth() + 1, 0, 23, 59, 59);
      subscriptions = allSubscriptions.filter(s => {
        const subDate = new Date(s.createdAt!);
        return subDate >= startOfMonth && subDate <= endOfMonth;
      });
    } else {
      subscriptions = allSubscriptions.filter(s => {
        const subDate = s.createdAt?.toISOString().split('T')[0];
        return subDate === today;
      });
    }
  } catch (e: any) {
    log(`Errore recupero abbonamenti: ${e.message}`);
  }

  const totalTicketRevenue = activeTickets.reduce((sum, t) => sum + getTicketPrice(t), 0);
  const totalSubRevenue = subscriptions.reduce((sum, s) => sum + (Number(s.price) || 0), 0);

  return {
    ticketedEvent,
    company,
    eventRecord,
    sectors,
    reportType,
    reportDate,
    progressivo,
    activeTicketsCount: activeTickets.length,
    cancelledTicketsCount: cancelledTickets.length,
    totalRevenue: totalTicketRevenue,
    subscriptions,
    filteredTickets: activeTickets,
  };
}

/**
 * Genera XML in formato conforme a DTD SIAE
 * FIX 2026-01-16: Supporta tre formati distinti:
 * - 'giornaliero' -> RiepilogoGiornaliero (RMG) con Data="YYYYMMDD"
 * - 'mensile' -> RiepilogoMensile (RPM) con Mese="YYYYMM"  
 * - 'rca' -> RiepilogoControlloAccessi (RCA) - formato legacy per singoli eventi
 * 
 * Allegato B - Provvedimento Agenzia delle Entrate 04/03/2008
 * 
 * @param reportData - Dati del report incluso xmlReportType per selezionare il formato
 */
function generateXMLContent(reportData: any): string {
  const { 
    ticketedEvent, 
    company, 
    eventRecord, 
    sectors, 
    reportType, 
    reportDate, 
    activeTicketsCount, 
    cancelledTicketsCount, 
    totalRevenue, 
    filteredTickets, 
    progressivo = 1,
    cachedEfffData = null,
    resolvedSystemCode = null,
    xmlReportType = null,
    nomeFile = null
  } = reportData;
  
  const now = new Date();
  if (!resolvedSystemCode) {
    console.error(`[SIAE-SCHEDULER] CRITICAL: resolvedSystemCode non fornito a generateXMLContent!`);
    console.error(`[SIAE-SCHEDULER] Caller DEVE usare resolveSystemCode() PRIMA di chiamare generateXMLContent`);
    throw new Error(
      'RESOLVED_SYSTEM_CODE_REQUIRED: resolvedSystemCode è obbligatorio. ' +
      'Usare resolveSystemCode(cachedEfff, siaeConfig) prima di chiamare generateXMLContent.'
    );
  }
  const systemCode: string = resolvedSystemCode;
  const taxId = cachedEfffData?.partnerCodFis || company?.taxId || 'XXXXXXXXXXXXXXXX';
  const businessName = cachedEfffData?.partnerName || ticketedEvent.businessName || company?.name || 'N/A';
  
  const dataGenerazione = formatSiaeDateCompact(now);
  const oraGenerazione = formatSiaeTimeCompact(now);
  
  const effectiveReportType: 'giornaliero' | 'mensile' | 'rca' = xmlReportType || reportType || 'rca';
  
  if (effectiveReportType === 'giornaliero' || effectiveReportType === 'mensile') {
    const eventContext: C1EventContext = {
      ticketedEvent: {
        id: ticketedEvent.id,
        companyId: ticketedEvent.companyId,
        eventId: ticketedEvent.eventId,
        siaeLocationCode: ticketedEvent.siaeLocationCode,
        capacity: ticketedEvent.capacity,
        taxType: ticketedEvent.taxType,
        entertainmentIncidence: ticketedEvent.entertainmentIncidence,
        genreCode: ticketedEvent.genreCode,
        genreIncidence: ticketedEvent.genreIncidence,
        author: ticketedEvent.author,
        performer: ticketedEvent.performer,
        organizerType: ticketedEvent.organizerType,
      },
      eventRecord: eventRecord ? {
        id: eventRecord.id,
        name: eventRecord.name,
        startDatetime: eventRecord.startDatetime,
        locationId: eventRecord.locationId,
      } : null,
      location: reportData.location || null,
      sectors: (sectors || []).map((s: any): C1SectorData => ({
        id: s.id,
        sectorCode: s.sectorCode || s.orderCode,
        orderCode: s.orderCode,
        capacity: s.capacity,
      })),
      tickets: (filteredTickets || []).map((t: any): C1TicketData => ({
        id: t.id,
        ticketedEventId: t.ticketedEventId,
        sectorId: t.sectorId,
        status: t.status,
        ticketTypeCode: t.ticketTypeCode,
        isComplimentary: t.isComplimentary,
        grossAmount: t.ticketPrice || t.grossAmount,
        prevendita: t.prevendita,
        vatAmount: t.vatAmount,
        prevenditaVat: t.prevenditaVat,
        serviceAmount: t.serviceAmount,
        cancellationReasonCode: t.cancellationReasonCode,
        cancellationDate: t.cancellationDate,
      })),
    };
    
    const c1Subscriptions: C1SubscriptionData[] = (reportData.subscriptions || []).map((s: any): C1SubscriptionData => ({
      id: s.id,
      subscriptionCode: s.subscriptionCode || 'ABB001',
      ticketedEventId: s.ticketedEventId,
      sectorId: s.sectorId,
      validTo: s.validTo,
      createdAt: s.createdAt,
      taxType: s.taxType,
      turnType: s.turnType,
      ticketTypeCode: s.ticketTypeCode,
      isComplimentary: s.isComplimentary,
      status: s.status,
      totalAmount: s.totalAmount,
      rateoVat: s.rateoVat,
      eventsCount: s.eventsCount,
    }));
    
    const c1Params: C1XmlParams = {
      reportKind: effectiveReportType,
      companyId: company?.id || ticketedEvent.companyId,
      reportDate: reportDate,
      resolvedSystemCode: systemCode,
      progressivo: progressivo,
      taxId: taxId,
      businessName: businessName,
      events: [eventContext],
      subscriptions: c1Subscriptions,
    };
    
    const result = generateC1Xml(c1Params);
    return result.xml;
  }
  
  const dataRiepilogo = formatSiaeDateCompact(reportDate);
  const eventDateTime = eventRecord?.startDatetime ? new Date(eventRecord.startDatetime) : reportDate;
  const dataEvento = formatSiaeDateCompact(eventDateTime);
  const oraEvento = formatSiaeTimeHHMM(eventDateTime);
  const tipoGenere = mapGenreToSiae(ticketedEvent.genreCode);
  const spettacoloIntrattenimento = getSpettacoloIntrattenimentoCode(ticketedEvent.taxType);
  const incidenzaIntrattenimento = ticketedEvent.entertainmentIncidence || 100;
  const codiceLocale = (ticketedEvent.siaeLocationCode || '').padStart(13, '0').substring(0, 13);
  const totalRevenueInCents = Math.round(totalRevenue * 100);
  const ivaAmount = Math.round(totalRevenueInCents * 0.10);
  
  let capienzaTotale = 0;
  if (sectors && sectors.length > 0) {
    capienzaTotale = sectors.reduce((sum: number, s: any) => sum + (s.capacity || 0), 0);
  } else {
    capienzaTotale = 100;
  }

  let xml = `<?xml version="1.0" encoding="UTF-8"?>
<RiepilogoControlloAccessi Sostituzione="N">
  <Titolare>
    <DenominazioneTitolareCA>${escapeXml(businessName)}</DenominazioneTitolareCA>
    <CFTitolareCA>${escapeXml(taxId)}</CFTitolareCA>
    <CodiceSistemaCA>${escapeXml(systemCode)}</CodiceSistemaCA>
    <DataRiepilogo>${dataRiepilogo}</DataRiepilogo>
    <DataGenerazioneRiepilogo>${dataGenerazione}</DataGenerazioneRiepilogo>
    <OraGenerazioneRiepilogo>${oraGenerazione}</OraGenerazioneRiepilogo>
    <ProgressivoRiepilogo>${progressivo}</ProgressivoRiepilogo>
  </Titolare>
  <Evento>
    <CFOrganizzatore>${escapeXml(taxId)}</CFOrganizzatore>
    <DenominazioneOrganizzatore>${escapeXml(businessName)}</DenominazioneOrganizzatore>
    <TipologiaOrganizzatore>${ticketedEvent.organizerType || 'G'}</TipologiaOrganizzatore>
    <SpettacoloIntrattenimento>${spettacoloIntrattenimento}</SpettacoloIntrattenimento>
    <IncidenzaIntrattenimento>${incidenzaIntrattenimento}</IncidenzaIntrattenimento>
    <DenominazioneLocale>${escapeXml(ticketedEvent.eventLocation || eventRecord?.locationId || 'Locale')}</DenominazioneLocale>
    <CodiceLocale>${codiceLocale}</CodiceLocale>
    <DataEvento>${dataEvento}</DataEvento>
    <OraEvento>${oraEvento}</OraEvento>
    <TipoGenere>${tipoGenere}</TipoGenere>
    <TitoloEvento>${escapeXml(eventRecord?.name || ticketedEvent.eventTitle || 'Evento')}</TitoloEvento>
    <Autore></Autore>
    <Esecutore></Esecutore>
    <NazionalitaFilm></NazionalitaFilm>
    <NumOpereRappresentate>1</NumOpereRappresentate>
    <SistemaEmissione CFTitolare="${escapeXml(taxId)}" CodiceSistema="${escapeXml(systemCode)}">`;

  if (sectors && sectors.length > 0) {
    for (const sector of sectors) {
      const sectorTickets = filteredTickets.filter((t: any) => t.sectorId === sector.id);
      const sectorCancelled = reportData.cancelledTickets?.filter((t: any) => t.sectorId === sector.id)?.length || 0;
      const sectorRevenue = sectorTickets.reduce((sum: number, t: any) => {
        return sum + (Number(t.ticketPrice) || Number(t.grossAmount) || 0);
      }, 0);
      const sectorRevenueInCents = Math.round(sectorRevenue * 100);
      
      xml += `
      <Titoli>
        <CodiceOrdinePosto>${escapeXml(sector.orderCode || 'A0')}</CodiceOrdinePosto>
        <Capienza>${sector.capacity || 0}</Capienza>
        <TotaleTipoTitolo>
          <TipoTitolo>IN</TipoTitolo>
          <TotaleTitoliLTA>${sectorTickets.length}</TotaleTitoliLTA>
          <TotaleTitoliNoAccessoTradiz>0</TotaleTitoliNoAccessoTradiz>
          <TotaleTitoliNoAccessoDigitali>0</TotaleTitoliNoAccessoDigitali>
          <TotaleTitoliLTAAccessoTradiz>${sectorTickets.length}</TotaleTitoliLTAAccessoTradiz>
          <TotaleTitoliLTAAccessoDigitali>0</TotaleTitoliLTAAccessoDigitali>
          <TotaleCorrispettiviLordi>${sectorRevenueInCents}</TotaleCorrispettiviLordi>
          <TotaleDirittiPrevendita>0</TotaleDirittiPrevendita>
          <TotaleIVACorrispettivi>${Math.round(sectorRevenueInCents * 0.10)}</TotaleIVACorrispettivi>
          <TotaleIVADirittiPrevendita>0</TotaleIVADirittiPrevendita>
        </TotaleTipoTitolo>
        <TotaleTitoliAnnullati>
          <TipoTitolo>IN</TipoTitolo>
          <TotaleTitoliAnnull>${sectorCancelled}</TotaleTitoliAnnull>
          <TotaleCorrispettiviLordiAnnull>0</TotaleCorrispettiviLordiAnnull>
          <TotaleDirittiPrevenditaAnnull>0</TotaleDirittiPrevenditaAnnull>
          <TotaleIVACorrispettiviAnnull>0</TotaleIVACorrispettiviAnnull>
          <TotaleIVADirittiPrevenditaAnnull>0</TotaleIVADirittiPrevenditaAnnull>
        </TotaleTitoliAnnullati>
      </Titoli>`;
    }
  } else {
    xml += `
      <Titoli>
        <CodiceOrdinePosto>A0</CodiceOrdinePosto>
        <Capienza>${capienzaTotale}</Capienza>
        <TotaleTipoTitolo>
          <TipoTitolo>IN</TipoTitolo>
          <TotaleTitoliLTA>${activeTicketsCount}</TotaleTitoliLTA>
          <TotaleTitoliNoAccessoTradiz>0</TotaleTitoliNoAccessoTradiz>
          <TotaleTitoliNoAccessoDigitali>0</TotaleTitoliNoAccessoDigitali>
          <TotaleTitoliLTAAccessoTradiz>${activeTicketsCount}</TotaleTitoliLTAAccessoTradiz>
          <TotaleTitoliLTAAccessoDigitali>0</TotaleTitoliLTAAccessoDigitali>
          <TotaleCorrispettiviLordi>${totalRevenueInCents}</TotaleCorrispettiviLordi>
          <TotaleDirittiPrevendita>0</TotaleDirittiPrevendita>
          <TotaleIVACorrispettivi>${ivaAmount}</TotaleIVACorrispettivi>
          <TotaleIVADirittiPrevendita>0</TotaleIVADirittiPrevendita>
        </TotaleTipoTitolo>
        <TotaleTitoliAnnullati>
          <TipoTitolo>IN</TipoTitolo>
          <TotaleTitoliAnnull>${cancelledTicketsCount}</TotaleTitoliAnnull>
          <TotaleCorrispettiviLordiAnnull>0</TotaleCorrispettiviLordiAnnull>
          <TotaleDirittiPrevenditaAnnull>0</TotaleDirittiPrevenditaAnnull>
          <TotaleIVACorrispettiviAnnull>0</TotaleIVACorrispettiviAnnull>
          <TotaleIVADirittiPrevenditaAnnull>0</TotaleIVADirittiPrevenditaAnnull>
        </TotaleTitoliAnnullati>
      </Titoli>`;
  }

  const subscriptions = reportData.subscriptions || [];
  if (subscriptions.length > 0) {
    const totalSubRevenue = subscriptions.reduce((sum: number, s: any) => sum + (Number(s.price) || 0), 0);
    const totalSubRevenueInCents = Math.round(totalSubRevenue * 100);
    const subIvaAmount = Math.round(totalSubRevenueInCents * 0.10);
    
    xml += `
      <Abbonamenti>
        <TotaleAbbonamenti>${subscriptions.length}</TotaleAbbonamenti>
        <TotaleCorrispettiviLordiAbb>${totalSubRevenueInCents}</TotaleCorrispettiviLordiAbb>
        <TotaleIVAAbb>${subIvaAmount}</TotaleIVAAbb>
      </Abbonamenti>`;
  }

  xml += `
    </SistemaEmissione>
  </Evento>
</RiepilogoControlloAccessi>`;
  
  return xml;
}

async function checkExistingTransmission(ticketedEventId: string, transmissionType: string, periodDate: Date): Promise<boolean> {
  const dateStr = periodDate.toISOString().split('T')[0];
  const startOfDay = new Date(dateStr + 'T00:00:00.000Z');
  const endOfDay = new Date(dateStr + 'T23:59:59.999Z');

  const existing = await db.select()
    .from(siaeTransmissions)
    .where(and(
      eq(siaeTransmissions.ticketedEventId, ticketedEventId),
      eq(siaeTransmissions.transmissionType, transmissionType),
      gte(siaeTransmissions.periodDate, startOfDay),
      lt(siaeTransmissions.periodDate, endOfDay)
    ))
    .limit(1);

  return existing.length > 0;
}

async function sendDailyReports() {
  log('Avvio job invio report giornalieri RCA (RiepilogoControlloAccessi)...');
  
  try {
    // Carica settings globali UNA volta per run
    const settings = await getGlobalTransmissionSettings();
    
    // Verifica se invio automatico globale è abilitato
    if (settings && !settings.autoSendEnabled) {
      log('Auto-invio disabilitato globalmente, skip job giornaliero');
      return;
    }
    if (settings && !settings.dailyEnabled) {
      log('Invio giornaliero disabilitato globalmente, skip');
      return;
    }
    
    // Verifica intervallo giorni (default 5 se non impostato)
    const intervalDays = settings?.dailyIntervalDays || 5;
    if (settings?.lastDailySentAt && !shouldSendBasedOnInterval(settings.lastDailySentAt, intervalDays)) {
      log(`Non passati ${intervalDays} giorni dall'ultimo invio giornaliero, skip`);
      return;
    }
    
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);
    
    const endOfYesterday = new Date(yesterday);
    endOfYesterday.setHours(23, 59, 59, 999);

    const ticketedEventsWithEvents = await db.select({
      ticketedEvent: siaeTicketedEvents,
      event: events,
    })
    .from(siaeTicketedEvents)
    .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id))
    .where(and(
      eq(siaeTicketedEvents.autoSendReports, true),
      gte(events.endDatetime, yesterday),
      lt(events.endDatetime, endOfYesterday)
    ));

    log(`Trovati ${ticketedEventsWithEvents.length} eventi conclusi ieri con auto-invio abilitato`);

    for (const { ticketedEvent, event } of ticketedEventsWithEvents) {
      try {
        
        const alreadySent = await checkExistingTransmission(ticketedEvent.id, 'daily', yesterday);
        if (alreadySent) {
          log(`Evento ${ticketedEvent.id} - Report giornaliero già inviato, skip`);
          continue;
        }

        // Calcola il progressivo per questa trasmissione
        const progressivo = await getNextProgressivo(ticketedEvent.id, 'daily', yesterday);
        const reportData = await generateC1ReportData(ticketedEvent, 'giornaliero', yesterday, progressivo);
        // Add EFFF data from Smart Card if available
        const cachedEfff = getCachedEfffData();
        
        // FIX 2026-01-15: Carica siaeConfig per ottenere il systemCode corretto
        // ticketedEvent NON ha systemCode - è nella tabella siaeSystemConfig
        const siaeConfigDaily = await siaeStorage.getSiaeSystemConfig(ticketedEvent.companyId);
        
        // FIX 2026-01-18: TUTTI i report sono firmati S/MIME, usa resolveSystemCodeForSmime
        // Questo garantisce coerenza tra XML e Smart Card (errori SIAE 0600/0603)
        const siaeConfigForResolve = { systemCode: siaeConfigDaily?.systemCode || undefined };
        const smimeResult = resolveSystemCodeForSmime(cachedEfff, siaeConfigForResolve);
        if (!smimeResult.success || !smimeResult.systemCode) {
          log(`BLOCCO TRASMISSIONE RMG: ${smimeResult.error}`);
          log(`Suggerimento: Collegare la Smart Card tramite Desktop Bridge prima dell'invio`);
          continue; // Salta - Smart Card richiesta per S/MIME
        }
        const systemCode = smimeResult.systemCode;
        if (smimeResult.warning) {
          log(`WARNING RMG: ${smimeResult.warning}`);
        }
        log(`FIX 2026-01-18: Resolved systemCode=${systemCode} from ${smimeResult.source} for daily report`);
        
        // FIX 2026-01-16: Valida codice sistema PRIMA della generazione XML
        // Il codice default EVENT4U1 NON è registrato presso SIAE e causa errore 0600
        const systemCodePreValidation = validateSiaeSystemCode(systemCode);
        if (!systemCodePreValidation.valid) {
          log(`BLOCCO TRASMISSIONE RMG: Codice sistema non valido - ${systemCodePreValidation.error}`);
          log(`Suggerimento: ${systemCodePreValidation.isDefault 
            ? 'Configurare il codice sistema SIAE in Impostazioni > SIAE > Configurazione Sistema' 
            : 'Verificare il formato del codice sistema'}`);
          continue; // Salta questo evento, non inviare con codice non valido
        }
        
        // RMG = Riepilogo Giornaliero: genera nome file PRIMA di generateXMLContent per coerenza
        let fileName = generateSiaeFileName('giornaliero', yesterday, progressivo, null, systemCode);
        
        // FIX 2026-01-16: Passa xmlReportType='giornaliero' e nomeFile per generare RiepilogoGiornaliero
        // invece di RiepilogoControlloAccessi (previene errori SIAE 0600/0603)
        // NOTA: fileName già contiene l'estensione .xsi, non aggiungere di nuovo!
        let xmlContent = generateXMLContent({ 
          ...reportData, 
          cachedEfffData: cachedEfff, 
          resolvedSystemCode: systemCode,
          xmlReportType: 'giornaliero',
          nomeFile: fileName
        });
        
        // AUTO-CORREZIONE PREVENTIVA: Correggi automaticamente errori comuni prima dell'invio
        const autoCorrectionDaily = autoCorrectSiaeXml(xmlContent);
        if (autoCorrectionDaily.corrections.length > 0) {
          log(`AUTO-CORREZIONE: Applicate ${autoCorrectionDaily.corrections.length} correzioni automatiche per RMG:`);
          for (const corr of autoCorrectionDaily.corrections) {
            log(`  - ${corr.field}: ${corr.reason} (previene errore SIAE ${corr.siaeErrorPrevented})`);
          }
          xmlContent = autoCorrectionDaily.correctedXml;
        }
        if (autoCorrectionDaily.uncorrectableErrors.length > 0) {
          log(`ERRORI NON CORREGGIBILI: ${autoCorrectionDaily.uncorrectableErrors.map(e => e.message).join('; ')}`);
        }
        
        // FIX 2026-01-18: Validazione DTD pre-trasmissione obbligatoria per scheduler
        const dailyDtdValidation = await validatePreTransmission(xmlContent, systemCode, 'giornaliero', yesterday);
        if (!dailyDtdValidation.canTransmit) {
          log(`BLOCCO TRASMISSIONE RMG: Validazione DTD fallita - ${dailyDtdValidation.errors.map(e => `[${e.siaeErrorCode || 'ERR'}] ${e.message}`).join('; ')}`);
          continue; // Salta - XML non valido
        }
        if (dailyDtdValidation.warnings.length > 0) {
          log(`WARNING RMG DTD: ${dailyDtdValidation.warnings.map(w => w.message).join('; ')}`);
        }
        
        let fileExtension = '.xsi'; // Default per non firmato
        let signatureFormat: 'cades' | 'xmldsig' | null = null;

        // Calculate transmission statistics
        // FIX 2026-01-18: Cast per proprietà tipoTassazione non presente nel tipo base
        const dailyStats = await calculateTransmissionStats(
          reportData.filteredTickets || [],
          ticketedEvent.companyId,
          ticketedEvent.id,
          (ticketedEvent as any).tipoTassazione,
          ticketedEvent.entertainmentIncidence
        );
        const dailyFileHash = calculateFileHash(xmlContent);

        // FIX 2026-01-15: Salva systemCode per garantire coerenza nei reinvii (errori SIAE 0600/0603)
        const transmission = await siaeStorage.createSiaeTransmission({
          companyId: ticketedEvent.companyId,
          ticketedEventId: ticketedEvent.id,
          transmissionType: 'daily',
          periodDate: yesterday,
          scheduleType: 'daily',
          fileName: fileName.replace(fileExtension, ''),
          fileExtension,
          fileContent: xmlContent,
          status: 'pending',
          ticketsCount: reportData.activeTicketsCount,
          ticketsCancelled: reportData.cancelledTicketsCount,
          totalAmount: reportData.totalRevenue.toFixed(2),
          systemCode: systemCode, // FIX: Salva codice per reinvii futuri
          fileHash: dailyFileHash,
          totalIva: dailyStats.totalIva.toFixed(2),
          totalEsenti: dailyStats.totalEsenti.toFixed(2),
          totalImpostaIntrattenimento: dailyStats.totalImpostaIntrattenimento.toFixed(2),
          cfOrganizzatore: siaeConfigDaily?.taxId || '',
          ticketsChanged: dailyStats.ticketsChanged,
          ticketsResold: dailyStats.ticketsResold,
        });

        log(`Evento ${ticketedEvent.id} (${event.name}) - Report RMG giornaliero creato: ${fileName}`);

        // Tenta firma digitale se il bridge è connesso
        let signatureInfo = '';
        let p7mBase64: string | undefined;
        let signedXmlContent: string | undefined;
        
        try {
          if (isBridgeConnected()) {
            log(`Bridge connesso, tentativo firma digitale...`);
            const signatureResult = await requestXmlSignature(xmlContent);
            
            // Supporta sia CAdES-BES (nuovo) che XMLDSig (legacy)
            if (signatureResult.p7mBase64) {
              // CAdES-BES: mantieni il P7M Base64 separato
              p7mBase64 = signatureResult.p7mBase64;
              signatureFormat = 'cades';
              signatureInfo = ` (firmato CAdES-BES ${signatureResult.algorithm || 'SHA-256'})`;
              log(`Firma CAdES-BES creata alle ${signatureResult.signedAt}`);
            } else if (signatureResult.signedXml) {
              // Legacy XMLDSig (deprecato) - SIAE NON ACCETTA questo formato!
              signedXmlContent = signatureResult.signedXml;
              signatureFormat = 'xmldsig';
              signatureInfo = ' (firmato XMLDSig - DEPRECATO E RIFIUTATO DA SIAE!)';
              log(`ATTENZIONE: Firma XMLDSig creata alle ${signatureResult.signedAt} - QUESTO FORMATO NON E ACCETTATO DA SIAE! Aggiornare il bridge a v3.14+`);
            }
            
            // Aggiorna nome file: .p7m solo per CAdES-BES, altrimenti .xsi
            fileExtension = signatureFormat === 'cades' ? '.p7m' : '.xsi';
            fileName = generateSiaeFileName('giornaliero', yesterday, progressivo, signatureFormat, systemCode);
            
            // Aggiorna trasmissione con firma e contenuto appropriato
            await siaeStorage.updateSiaeTransmission(transmission.id, {
              fileContent: signedXmlContent || xmlContent, // XML originale o XMLDSig firmato
              fileName: fileName.replace(fileExtension, ''),
              fileExtension,
              p7mContent: p7mBase64 || null, // Salva P7M Base64 per resend offline
              signatureFormat: signatureFormat,
              signedAt: new Date(),
            });
          } else {
            log(`Bridge non connesso, invio XML non firmato`);
          }
        } catch (signError: any) {
          log(`ATTENZIONE: Firma digitale fallita, invio non firmato: ${signError.message}`);
        }

        // ==================== VALIDAZIONE COERENZA CODICE SISTEMA ====================
        // FIX 2026-01-15: Blocca invio se codice sistema XML != codice sistema nome file
        // NOTA: Valida sempre XML originale (stringa), non il payload firmato CAdES (Buffer binario)
        const systemCodeValidation = validateSystemCodeConsistency(xmlContent, systemCode);
        
        if (!systemCodeValidation.valid) {
          log(`ERRORE evento ${ticketedEvent.id}: ${systemCodeValidation.error}`);
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'error',
            errorMessage: systemCodeValidation.error || 'Codice sistema non coerente',
          });
          continue; // Skip questo evento, procedi con il prossimo
        }
        log(`Evento ${ticketedEvent.id} - Coerenza codice sistema verificata: XML=${systemCodeValidation.xmlSystemCode}, filename=${systemCodeValidation.filenameSystemCode}`);
        // ============================================================================

        // ==================== VALIDAZIONE PRE-TRASMISSIONE COMPLETA ====================
        // FIX 2026-01-15: Validazione centralizzata pre-trasmissione (async per DTD validator)
        const preValidation = await validatePreTransmission(xmlContent, systemCode, 'giornaliero', yesterday);
        if (!preValidation.canTransmit) {
          log(`ERRORE validazione pre-trasmissione evento ${ticketedEvent.id}: ${preValidation.errors.map(e => e.message).join('; ')}`);
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'error',
            errorMessage: preValidation.errors.map(e => `[${e.siaeErrorCode || 'UNKNOWN'}] ${e.message}`).join('; '),
          });
          continue;
        }
        log(`Evento ${ticketedEvent.id} - Validazione pre-trasmissione OK`);
        // ============================================================================

        // Invio automatico email a SIAE con nuovo formato subject
        try {
          await sendSiaeTransmissionEmail({
            to: SIAE_TEST_EMAIL,
            companyName: reportData.company?.name || 'N/A',
            transmissionType: 'daily',
            periodDate: yesterday,
            ticketsCount: reportData.activeTicketsCount,
            totalAmount: reportData.totalRevenue.toFixed(2),
            xmlContent: signedXmlContent || xmlContent, // XML originale o XMLDSig firmato
            transmissionId: transmission.id,
            systemCode: systemCode,
            sequenceNumber: progressivo,
            p7mBase64: p7mBase64, // CAdES-BES P7M per allegato email
            signatureFormat: signatureFormat || undefined,
            signWithSmime: true,
            requireSignature: true,
          });

          // Aggiorna status a 'sent'
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'sent',
            sentAt: new Date(),
          });
          
          // Aggiorna lastDailySentAt nelle impostazioni globali
          await db.update(siaeTransmissionSettings)
            .set({ lastDailySentAt: new Date() })
            .where(eq(siaeTransmissionSettings.id, 'global'));
          
          log(`Evento ${ticketedEvent.id} - Email inviata a ${SIAE_TEST_EMAIL}${signatureInfo}, status aggiornato a 'sent'`);
        } catch (emailError: any) {
          log(`ERRORE invio email per evento ${ticketedEvent.id}: ${emailError.message}`);
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'error',
            errorMessage: emailError.message,
          });
        }
      } catch (eventError: any) {
        log(`ERRORE per evento ${ticketedEvent.id}: ${eventError.message}`);
      }
    }

    log('Job invio report giornalieri completato');
  } catch (error: any) {
    log(`ERRORE job giornaliero: ${error.message}`);
  }
}

async function sendMonthlyReports() {
  log('Avvio job invio report mensili RCA...');
  
  try {
    // Carica settings globali UNA volta per run
    const settings = await getGlobalTransmissionSettings();
    
    // Verifica se invio automatico globale è abilitato
    if (settings && !settings.autoSendEnabled) {
      log('Auto-invio disabilitato globalmente, skip job mensile');
      return;
    }
    if (settings && !settings.monthlyEnabled) {
      log('Invio mensile disabilitato globalmente, skip');
      return;
    }
    
    // Verifica se è il giorno configurato per l'invio mensile
    const recurringDay = settings?.monthlyRecurringDay || 1;
    if (!isTodayMonthlyRecurringDay(recurringDay)) {
      log(`Oggi non è il giorno ${recurringDay} del mese, skip job mensile`);
      return;
    }
    
    const now = new Date();
    const previousMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const endOfPreviousMonth = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59);

    const ticketedEventsWithTickets = await db.select({
      ticketedEvent: siaeTicketedEvents,
    })
    .from(siaeTicketedEvents)
    .innerJoin(siaeTickets, eq(siaeTicketedEvents.id, siaeTickets.ticketedEventId))
    .where(and(
      eq(siaeTicketedEvents.autoSendReports, true),
      gte(siaeTickets.createdAt, previousMonth),
      lt(siaeTickets.createdAt, endOfPreviousMonth)
    ))
    .groupBy(siaeTicketedEvents.id);

    log(`Trovati ${ticketedEventsWithTickets.length} eventi con attività nel mese precedente`);

    for (const { ticketedEvent } of ticketedEventsWithTickets) {
      try {
        const alreadySent = await checkExistingTransmission(ticketedEvent.id, 'monthly', previousMonth);
        if (alreadySent) {
          log(`Evento ${ticketedEvent.id} - Report mensile già inviato, skip`);
          continue;
        }

        // Calcola il progressivo per questa trasmissione mensile
        const progressivo = await getNextProgressivo(ticketedEvent.id, 'monthly', previousMonth);
        const reportData = await generateC1ReportData(ticketedEvent, 'mensile', previousMonth, progressivo);
        // Add EFFF data from Smart Card if available
        const cachedEfff = getCachedEfffData();
        
        // FIX 2026-01-15: Carica siaeConfig per ottenere il systemCode corretto
        // ticketedEvent NON ha systemCode - è nella tabella siaeSystemConfig
        const siaeConfigMonthly = await siaeStorage.getSiaeSystemConfig(ticketedEvent.companyId);
        
        // FIX 2026-01-18: TUTTI i report sono firmati S/MIME, usa resolveSystemCodeForSmime
        // Questo garantisce coerenza tra XML e Smart Card (errori SIAE 0600/0603)
        const siaeConfigForResolve = { systemCode: siaeConfigMonthly?.systemCode || undefined };
        const smimeResultMonthly = resolveSystemCodeForSmime(cachedEfff, siaeConfigForResolve);
        if (!smimeResultMonthly.success || !smimeResultMonthly.systemCode) {
          log(`BLOCCO TRASMISSIONE RPM: ${smimeResultMonthly.error}`);
          log(`Suggerimento: Collegare la Smart Card tramite Desktop Bridge prima dell'invio`);
          continue; // Salta - Smart Card richiesta per S/MIME
        }
        const systemCode = smimeResultMonthly.systemCode;
        if (smimeResultMonthly.warning) {
          log(`WARNING RPM: ${smimeResultMonthly.warning}`);
        }
        log(`FIX 2026-01-18: Resolved systemCode=${systemCode} from ${smimeResultMonthly.source} for monthly report`);
        
        // FIX 2026-01-16: Valida codice sistema PRIMA della generazione XML
        // Il codice default EVENT4U1 NON è registrato presso SIAE e causa errore 0600
        const systemCodePreValidationMonthly = validateSiaeSystemCode(systemCode);
        if (!systemCodePreValidationMonthly.valid) {
          log(`BLOCCO TRASMISSIONE RPM: Codice sistema non valido - ${systemCodePreValidationMonthly.error}`);
          log(`Suggerimento: ${systemCodePreValidationMonthly.isDefault 
            ? 'Configurare il codice sistema SIAE in Impostazioni > SIAE > Configurazione Sistema' 
            : 'Verificare il formato del codice sistema'}`);
          continue; // Salta questo evento, non inviare con codice non valido
        }
        
        // RPM = Riepilogo Mensile: genera nome file PRIMA di generateXMLContent per coerenza
        let fileName = generateSiaeFileName('mensile', previousMonth, progressivo, null, systemCode);
        
        // FIX 2026-01-16: Passa xmlReportType='mensile' e nomeFile per generare RiepilogoMensile
        // invece di RiepilogoControlloAccessi (previene errori SIAE 0600/0603)
        // NOTA: fileName già contiene l'estensione .xsi, non aggiungere di nuovo!
        const xmlContent = generateXMLContent({ 
          ...reportData, 
          cachedEfffData: cachedEfff, 
          resolvedSystemCode: systemCode,
          xmlReportType: 'mensile',
          nomeFile: fileName
        });
        
        // FIX 2026-01-18: Validazione DTD pre-trasmissione obbligatoria per scheduler
        const monthlyDtdValidation = await validatePreTransmission(xmlContent, systemCode, 'mensile', previousMonth);
        if (!monthlyDtdValidation.canTransmit) {
          log(`BLOCCO TRASMISSIONE RPM: Validazione DTD fallita - ${monthlyDtdValidation.errors.map(e => `[${e.siaeErrorCode || 'ERR'}] ${e.message}`).join('; ')}`);
          continue; // Salta - XML non valido
        }
        if (monthlyDtdValidation.warnings.length > 0) {
          log(`WARNING RPM DTD: ${monthlyDtdValidation.warnings.map(w => w.message).join('; ')}`);
        }
        
        let fileExtension = '.xsi'; // Default per non firmato
        let signatureFormat: 'cades' | 'xmldsig' | null = null;

        // Calculate transmission statistics
        // FIX 2026-01-18: Cast per proprietà tipoTassazione non presente nel tipo base
        const monthlyStats = await calculateTransmissionStats(
          reportData.filteredTickets || [],
          ticketedEvent.companyId,
          ticketedEvent.id,
          (ticketedEvent as any).tipoTassazione,
          ticketedEvent.entertainmentIncidence
        );
        const monthlyFileHash = calculateFileHash(xmlContent);

        // FIX 2026-01-15: Salva systemCode per garantire coerenza nei reinvii (errori SIAE 0600/0603)
        const transmission = await siaeStorage.createSiaeTransmission({
          companyId: ticketedEvent.companyId,
          ticketedEventId: ticketedEvent.id,
          transmissionType: 'monthly',
          periodDate: previousMonth,
          scheduleType: 'monthly',
          fileName: fileName.replace(fileExtension, ''),
          fileExtension,
          fileContent: xmlContent,
          status: 'pending',
          ticketsCount: reportData.activeTicketsCount,
          ticketsCancelled: reportData.cancelledTicketsCount,
          totalAmount: reportData.totalRevenue.toFixed(2),
          systemCode: systemCode, // FIX: Salva codice per reinvii futuri
          fileHash: monthlyFileHash,
          totalIva: monthlyStats.totalIva.toFixed(2),
          totalEsenti: monthlyStats.totalEsenti.toFixed(2),
          totalImpostaIntrattenimento: monthlyStats.totalImpostaIntrattenimento.toFixed(2),
          cfOrganizzatore: siaeConfigMonthly?.taxId || '',
          ticketsChanged: monthlyStats.ticketsChanged,
          ticketsResold: monthlyStats.ticketsResold,
        });

        log(`Evento ${ticketedEvent.id} - Report RPM mensile creato: ${fileName}`);

        // Tenta firma digitale se il bridge è connesso
        let signatureInfo = '';
        let p7mBase64: string | undefined;
        let signedXmlContent: string | undefined;
        
        try {
          if (isBridgeConnected()) {
            log(`Bridge connesso, tentativo firma digitale per report mensile...`);
            const signatureResult = await requestXmlSignature(xmlContent);
            
            // Supporta sia CAdES-BES (nuovo) che XMLDSig (legacy)
            if (signatureResult.p7mBase64) {
              // CAdES-BES: mantieni il P7M Base64 separato
              p7mBase64 = signatureResult.p7mBase64;
              signatureFormat = 'cades';
              signatureInfo = ` (firmato CAdES-BES ${signatureResult.algorithm || 'SHA-256'})`;
              log(`Firma mensile CAdES-BES creata alle ${signatureResult.signedAt}`);
            } else if (signatureResult.signedXml) {
              // Legacy XMLDSig (deprecato) - SIAE NON ACCETTA questo formato!
              signedXmlContent = signatureResult.signedXml;
              signatureFormat = 'xmldsig';
              signatureInfo = ' (firmato XMLDSig - DEPRECATO E RIFIUTATO DA SIAE!)';
              log(`ATTENZIONE: Firma mensile XMLDSig creata alle ${signatureResult.signedAt} - QUESTO FORMATO NON E ACCETTATO DA SIAE! Aggiornare il bridge a v3.14+`);
            }
            
            // Aggiorna nome file: .p7m solo per CAdES-BES, altrimenti .xsi
            fileExtension = signatureFormat === 'cades' ? '.p7m' : '.xsi';
            fileName = generateSiaeFileName('mensile', previousMonth, progressivo, signatureFormat, systemCode);
            
            // Aggiorna trasmissione con firma e contenuto appropriato
            await siaeStorage.updateSiaeTransmission(transmission.id, {
              fileContent: signedXmlContent || xmlContent, // XML originale o XMLDSig firmato
              fileName: fileName.replace(fileExtension, ''),
              fileExtension,
              p7mContent: p7mBase64 || null, // Salva P7M Base64 per resend offline
              signatureFormat: signatureFormat,
              signedAt: new Date(),
            });
          } else {
            log(`Bridge non connesso, invio XML mensile non firmato`);
          }
        } catch (signError: any) {
          log(`ATTENZIONE: Firma digitale report mensile fallita, invio non firmato: ${signError.message}`);
        }

        // ==================== VALIDAZIONE COERENZA CODICE SISTEMA ====================
        // FIX 2026-01-15: Blocca invio se codice sistema XML != codice sistema nome file
        // NOTA: Valida sempre XML originale (stringa), non il payload firmato CAdES (Buffer binario)
        const systemCodeValidationMonthly = validateSystemCodeConsistency(xmlContent, systemCode);
        
        if (!systemCodeValidationMonthly.valid) {
          log(`ERRORE evento ${ticketedEvent.id}: ${systemCodeValidationMonthly.error}`);
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'error',
            errorMessage: systemCodeValidationMonthly.error || 'Codice sistema non coerente',
          });
          continue; // Skip questo evento, procedi con il prossimo
        }
        log(`Evento ${ticketedEvent.id} - Coerenza codice sistema mensile verificata: XML=${systemCodeValidationMonthly.xmlSystemCode}, filename=${systemCodeValidationMonthly.filenameSystemCode}`);
        // ============================================================================

        // ==================== VALIDAZIONE PRE-TRASMISSIONE COMPLETA ====================
        // FIX 2026-01-15: Validazione centralizzata pre-trasmissione mensile (async per DTD validator)
        const preValidationMonthly = await validatePreTransmission(xmlContent, systemCode, 'mensile', previousMonth);
        if (!preValidationMonthly.canTransmit) {
          log(`ERRORE validazione pre-trasmissione mensile evento ${ticketedEvent.id}: ${preValidationMonthly.errors.map(e => e.message).join('; ')}`);
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'error',
            errorMessage: preValidationMonthly.errors.map(e => `[${e.siaeErrorCode || 'UNKNOWN'}] ${e.message}`).join('; '),
          });
          continue;
        }
        log(`Evento ${ticketedEvent.id} - Validazione pre-trasmissione mensile OK`);
        // ============================================================================

        // Invio automatico email a SIAE con nuovo formato subject
        try {
          await sendSiaeTransmissionEmail({
            to: SIAE_TEST_EMAIL,
            companyName: reportData.company?.name || 'N/A',
            transmissionType: 'monthly',
            periodDate: previousMonth,
            ticketsCount: reportData.activeTicketsCount,
            totalAmount: reportData.totalRevenue.toFixed(2),
            xmlContent: signedXmlContent || xmlContent, // XML originale o XMLDSig firmato
            transmissionId: transmission.id,
            systemCode: systemCode,
            sequenceNumber: progressivo,
            p7mBase64: p7mBase64, // CAdES-BES P7M per allegato email
            signatureFormat: signatureFormat || undefined,
            signWithSmime: true,
            requireSignature: true,
          });

          // Aggiorna status a 'sent'
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'sent',
            sentAt: new Date(),
          });
          
          // Aggiorna lastMonthlySentAt nelle impostazioni globali
          await db.update(siaeTransmissionSettings)
            .set({ lastMonthlySentAt: new Date() })
            .where(eq(siaeTransmissionSettings.id, 'global'));
          
          log(`Evento ${ticketedEvent.id} - Email mensile inviata a ${SIAE_TEST_EMAIL}${signatureInfo}, status aggiornato a 'sent'`);
        } catch (emailError: any) {
          log(`ERRORE invio email mensile per evento ${ticketedEvent.id}: ${emailError.message}`);
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'error',
            errorMessage: emailError.message,
          });
        }
      } catch (eventError: any) {
        log(`ERRORE per evento ${ticketedEvent.id}: ${eventError.message}`);
      }
    }

    log('Job invio report mensili completato');
  } catch (error: any) {
    log(`ERRORE job mensile: ${error.message}`);
  }
}

/**
 * Job per invio automatico report RCA (Riepilogo Controllo Accessi) per eventi conclusi.
 * Genera e invia RCA per eventi terminati che hanno autoSendReports abilitato.
 * Viene eseguito 24 ore dopo la chiusura dell'evento.
 */
async function sendRCAReports() {
  try {
    log('Avvio job invio report RCA per eventi conclusi (24h dopo chiusura)...');
    
    const now = new Date();
    // Cerca eventi chiusi da almeno 24 ore (ma non più di 48 ore fa per evitare reprocessing)
    const twentyFourHoursAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const fortyEightHoursAgo = new Date(now.getTime() - 48 * 60 * 60 * 1000);
    
    // Trova eventi chiusi da almeno 24 ore con ticketed events che hanno auto-invio
    const ticketedEventsWithEvents = await db.select({
      ticketedEvent: siaeTicketedEvents,
      event: events,
    })
    .from(siaeTicketedEvents)
    .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id))
    .where(and(
      eq(siaeTicketedEvents.autoSendReports, true),
      eq(events.status, 'closed'),
      // Evento terminato tra 48 e 24 ore fa (finestra per invio RCA)
      gte(events.endDatetime, fortyEightHoursAgo),
      lt(events.endDatetime, twentyFourHoursAgo)
    ));
    
    if (ticketedEventsWithEvents.length === 0) {
      log('Nessun evento concluso con auto-invio RCA abilitato');
      return;
    }
    
    log(`Trovati ${ticketedEventsWithEvents.length} eventi conclusi per invio RCA`);
    
    for (const { ticketedEvent, event } of ticketedEventsWithEvents) {
      try {
        // Verifica se esiste già una trasmissione RCA per questo evento
        const existingRCA = await db.select()
          .from(siaeTransmissions)
          .where(and(
            eq(siaeTransmissions.ticketedEventId, ticketedEvent.id),
            eq(siaeTransmissions.transmissionType, 'rca')
          ))
          .limit(1);
        
        if (existingRCA.length > 0) {
          log(`Evento ${ticketedEvent.id} - RCA già inviato, skip`);
          continue;
        }
        
        // Recupera dati necessari per generazione RCA
        const company = await storage.getCompany(ticketedEvent.companyId);
        const sectors = await siaeStorage.getSiaeEventSectors(ticketedEvent.id);
        const allTickets = await siaeStorage.getSiaeTicketsByEvent(ticketedEvent.id);
        const location = event.locationId ? await storage.getLocation(event.locationId) : null;
        const siaeConfig = await siaeStorage.getSiaeSystemConfig(ticketedEvent.companyId);
        
        // Calcola progressivo
        const allTransmissions = await siaeStorage.getSiaeTransmissionsByCompany(ticketedEvent.companyId);
        const rcaTransmissionsForEvent = allTransmissions.filter(t => 
          t.transmissionType === 'rca' && t.ticketedEventId === ticketedEvent.id
        );
        const progressivo = rcaTransmissionsForEvent.length + 1;
        
        // Prepara i ticket nel formato richiesto (SiaeTicketForLog)
        const eventDate = event.endDatetime || new Date();
        const ticketsForLog = allTickets.map((t: any, idx: number) => ({
          id: t.id,
          status: t.status,
          fiscalSealCode: t.fiscalSealCode || null,
          progressiveNumber: t.progressiveNumber || idx + 1,
          cardCode: t.cardCode || null,
          emissionChannelCode: t.emissionChannelCode || 'WEB',
          emissionDate: t.createdAt || new Date(),
          ticketTypeCode: t.ticketTypeCode || 'I1',
          sectorCode: sectors.find((s: any) => s.id === t.sectorId)?.sectorCode || '01',
          grossAmount: Number(t.ticketPrice) || Number(t.grossAmount) || Number(t.priceAtPurchase) || 0,
          netAmount: Number(t.ticketPrice) || Number(t.netAmount) || 0,
          vatAmount: 0,
          prevendita: Number(t.prevendita) || 0,
          isComplimentary: t.isComplimentary || false,
          row: t.row || null,
          seatNumber: t.seatNumber || null,
          participantFirstName: t.participantFirstName || null,
          participantLastName: t.participantLastName || null,
          originalTicketId: t.originalTicketId || null,
          replacedByTicketId: t.replacedByTicketId || null,
          originalProgressiveNumber: t.originalProgressiveNumber || null,
          cancellationReasonCode: t.cancellationReasonCode || null,
          cancellationDate: t.cancellationDate || null,
          accessDateTime: t.scannedAt || null,
          codiceTitolo: normalizeSiaeTipoTitolo(t.ticketTypeCode, t.isComplimentary) || 'I1',
          codiceOrdine: normalizeSiaeCodiceOrdine(t.sectorCode) || 'P1',
        }));
        
        // Prepara evento per RCA
        const eventForLog = {
          id: ticketedEvent.id,
          name: event.name || 'Evento',
          date: eventDate,
          startTime: event.startDatetime ? formatSiaeTimeHHMM(new Date(event.startDatetime)) : '20:00',
          endTime: event.endDatetime ? formatSiaeTimeHHMM(new Date(event.endDatetime)) : '23:59',
          genreCode: ticketedEvent.genreCode || '61',
          taxType: ticketedEvent.taxType || 'I',
          organizerName: company?.name || 'Organizzatore',
          organizerTaxId: company?.fiscalCode || company?.taxId || '',
          venueCode: location?.siaeLocationCode || '001',
          venueName: location?.name || 'Locale',
          eventLocation: location?.name || 'Locale',
        };
        
        // Configurazione sistema
        const companyTaxId = company?.fiscalCode || company?.taxId || siaeConfig?.taxId || '';
        const companyBusinessName = company?.name || siaeConfig?.businessName || 'Azienda';
        
        // FIX 2026-01-17: Per RCA (S/MIME) usare SOLO codice dalla Smart Card!
        // Usando siaeConfig.systemCode con una Smart Card diversa causa errore SIAE 0600
        const cachedEfff = getCachedEfffData();
        const siaeConfigForResolve = { systemCode: siaeConfig?.systemCode || undefined };
        
        // Per RCA, usa resolveSystemCodeForSmime che richiede Smart Card
        const systemCodeResult = resolveSystemCodeForSmime(cachedEfff, siaeConfigForResolve);
        
        if (!systemCodeResult.success || !systemCodeResult.systemCode) {
          log(`BLOCCO TRASMISSIONE RCA: ${systemCodeResult.error}`);
          log(`La Smart Card deve essere connessa e contenere un codice sistema valido.`);
          log(`cachedEfff.systemId=${cachedEfff?.systemId || '(non disponibile)'}, siaeConfig.systemCode=${siaeConfig?.systemCode || '(non configurato)'}`);
          continue; // Salta questo evento - non inviare senza codice dalla Smart Card
        }
        
        const systemCode = systemCodeResult.systemCode;
        if (systemCodeResult.warning) {
          log(`ATTENZIONE RCA: ${systemCodeResult.warning}`);
        }
        log(`FIX 2026-01-17: Resolved systemCode=${systemCode} from ${systemCodeResult.source} for RCA report`);
        
        // FIX 2026-01-16: Valida codice sistema PRIMA della generazione XML
        // Il codice default EVENT4U1 NON è registrato presso SIAE e causa errore 0600
        const systemCodePreValidationRca = validateSiaeSystemCode(systemCode);
        if (!systemCodePreValidationRca.valid) {
          log(`BLOCCO TRASMISSIONE RCA: Codice sistema non valido - ${systemCodePreValidationRca.error}`);
          log(`Suggerimento: ${systemCodePreValidationRca.isDefault 
            ? 'Configurare il codice sistema SIAE in Impostazioni > SIAE > Configurazione Sistema' 
            : 'Verificare il formato del codice sistema'}`);
          continue; // Salta questo evento, non inviare con codice non valido
        }
        
        const rcaParams: RCAParams = {
          companyId: ticketedEvent.companyId,
          eventId: ticketedEvent.id,
          event: eventForLog,
          tickets: ticketsForLog,
          systemConfig: {
            systemCode: systemCode, // FIX: Usa systemCode pre-risolto
            taxId: siaeConfig?.taxId || companyTaxId,
            businessName: siaeConfig?.businessName || companyBusinessName,
          },
          companyName: companyBusinessName,
          taxId: companyTaxId,
          progressivo: progressivo,
          venueName: location?.name || 'Locale',
        };
        
        // Genera XML RCA
        const rcaResult = generateRCAXml(rcaParams);
        
        if (!rcaResult.success) {
          log(`ERRORE generazione RCA per evento ${ticketedEvent.id}: ${rcaResult.errors.join('; ')}`);
          continue;
        }
        
        let xmlContent = rcaResult.xml;
        
        // AUTO-CORREZIONE PREVENTIVA: Correggi automaticamente errori comuni prima dell'invio
        const autoCorrectionRca = autoCorrectSiaeXml(xmlContent, eventForLog.genreCode);
        if (autoCorrectionRca.corrections.length > 0) {
          log(`AUTO-CORREZIONE: Applicate ${autoCorrectionRca.corrections.length} correzioni automatiche per RCA:`);
          for (const corr of autoCorrectionRca.corrections) {
            log(`  - ${corr.field}: ${corr.reason} (previene errore SIAE ${corr.siaeErrorPrevented})`);
          }
          xmlContent = autoCorrectionRca.correctedXml;
        }
        if (autoCorrectionRca.uncorrectableErrors.length > 0) {
          log(`ERRORI NON CORREGGIBILI: ${autoCorrectionRca.uncorrectableErrors.map(e => e.message).join('; ')}`);
        }
        
        // Nome file - usa lo stesso systemCode pre-risolto
        let fileName = generateSiaeFileName('rca', eventDate, progressivo, null, systemCode);
        let fileExtension = '.xsi';
        let signatureFormat: 'cades' | 'xmldsig' | null = null;
        
        // Calculate transmission statistics for RCA
        // FIX 2026-01-18: Usa ticketsForLog invece di eventTickets (variabile non definita)
        const rcaStats = await calculateTransmissionStats(
          ticketsForLog,
          ticketedEvent.companyId,
          ticketedEvent.id,
          (ticketedEvent as any).tipoTassazione,
          ticketedEvent.entertainmentIncidence
        );
        const rcaFileHash = calculateFileHash(xmlContent);
        
        // Crea trasmissione
        // FIX 2026-01-15: Salva systemCode per garantire coerenza nei reinvii (errori SIAE 0600/0603)
        const transmission = await siaeStorage.createSiaeTransmission({
          companyId: ticketedEvent.companyId,
          ticketedEventId: ticketedEvent.id,
          transmissionType: 'rca',
          periodDate: eventDate,
          scheduleType: 'auto',
          fileName: fileName.replace(fileExtension, ''),
          fileExtension,
          fileContent: xmlContent,
          status: 'pending',
          ticketsCount: rcaResult.ticketCount,
          ticketsCancelled: 0,
          totalAmount: ticketsForLog.reduce((sum, t) => sum + t.grossAmount, 0).toFixed(2),
          systemCode: systemCode, // FIX: Salva codice per reinvii futuri
          fileHash: rcaFileHash,
          totalIva: rcaStats.totalIva.toFixed(2),
          totalEsenti: rcaStats.totalEsenti.toFixed(2),
          totalImpostaIntrattenimento: rcaStats.totalImpostaIntrattenimento.toFixed(2),
          cfOrganizzatore: siaeConfig?.taxId || '',
          ticketsChanged: rcaStats.ticketsChanged,
          ticketsResold: rcaStats.ticketsResold,
        });
        
        log(`Evento ${ticketedEvent.id} (${event.name}) - Report RCA creato: ${fileName}`);
        
        // Tenta firma digitale
        let signatureInfo = '';
        let p7mBase64: string | undefined;
        let signedXmlContent: string | undefined;
        
        try {
          if (isBridgeConnected()) {
            log(`Bridge connesso, tentativo firma digitale RCA...`);
            const signatureResult = await requestXmlSignature(xmlContent);
            
            if (signatureResult.p7mBase64) {
              p7mBase64 = signatureResult.p7mBase64;
              signatureFormat = 'cades';
              signatureInfo = ` (firmato CAdES-BES ${signatureResult.algorithm || 'SHA-256'})`;
              log(`Firma RCA CAdES-BES creata alle ${signatureResult.signedAt}`);
            } else if (signatureResult.signedXml) {
              signedXmlContent = signatureResult.signedXml;
              signatureFormat = 'xmldsig';
              signatureInfo = ' (firmato XMLDSig - DEPRECATO)';
            }
            
            fileExtension = signatureFormat === 'cades' ? '.p7m' : '.xsi';
            fileName = generateSiaeFileName('rca', eventDate, progressivo, signatureFormat, systemCode);
            
            await siaeStorage.updateSiaeTransmission(transmission.id, {
              fileContent: signedXmlContent || xmlContent,
              fileName: fileName.replace(fileExtension, ''),
              fileExtension,
              p7mContent: p7mBase64 || null,
              signatureFormat: signatureFormat,
              signedAt: new Date(),
            });
          } else {
            log(`Bridge non connesso, invio RCA non firmato`);
          }
        } catch (signError: any) {
          log(`ATTENZIONE: Firma digitale RCA fallita, invio non firmato: ${signError.message}`);
        }
        
        // ==================== VALIDAZIONE COERENZA CODICE SISTEMA ====================
        // FIX 2026-01-15: Blocca invio se codice sistema XML != codice sistema nome file
        // NOTA: Valida sempre XML originale (stringa), non il payload firmato CAdES (Buffer binario)
        const systemCodeValidationRca = validateSystemCodeConsistency(xmlContent, systemCode);
        
        if (!systemCodeValidationRca.valid) {
          log(`ERRORE evento ${ticketedEvent.id}: ${systemCodeValidationRca.error}`);
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'error',
            errorMessage: systemCodeValidationRca.error || 'Codice sistema non coerente',
          });
          continue; // Skip questo evento, procedi con il prossimo
        }
        log(`Evento ${ticketedEvent.id} - Coerenza codice sistema RCA verificata: XML=${systemCodeValidationRca.xmlSystemCode}, filename=${systemCodeValidationRca.filenameSystemCode}`);
        // ============================================================================

        // ==================== VALIDAZIONE PRE-TRASMISSIONE COMPLETA ====================
        // FIX 2026-01-15: Validazione centralizzata pre-trasmissione RCA (async per DTD validator)
        const preValidationRca = await validatePreTransmission(xmlContent, systemCode, 'rca', eventDate);
        if (!preValidationRca.canTransmit) {
          log(`ERRORE validazione pre-trasmissione RCA evento ${ticketedEvent.id}: ${preValidationRca.errors.map(e => e.message).join('; ')}`);
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'error',
            errorMessage: preValidationRca.errors.map(e => `[${e.siaeErrorCode || 'UNKNOWN'}] ${e.message}`).join('; '),
          });
          continue;
        }
        log(`Evento ${ticketedEvent.id} - Validazione pre-trasmissione RCA OK`);
        // ============================================================================

        // Invio email
        try {
          await sendSiaeTransmissionEmail({
            to: SIAE_TEST_EMAIL,
            companyName: companyBusinessName,
            transmissionType: 'rca',
            periodDate: eventDate,
            ticketsCount: rcaResult.ticketCount,
            totalAmount: ticketsForLog.reduce((sum, t) => sum + t.grossAmount, 0).toFixed(2),
            xmlContent: signedXmlContent || xmlContent,
            transmissionId: transmission.id,
            systemCode: systemCode,
            sequenceNumber: progressivo,
            p7mBase64: p7mBase64,
            signatureFormat: signatureFormat || undefined,
            signWithSmime: true,
            requireSignature: true,
          });
          
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'sent',
            sentAt: new Date(),
          });
          
          log(`Evento ${ticketedEvent.id} - Email RCA inviata a ${SIAE_TEST_EMAIL}${signatureInfo}`);
        } catch (emailError: any) {
          log(`ERRORE invio email RCA per evento ${ticketedEvent.id}: ${emailError.message}`);
          await siaeStorage.updateSiaeTransmission(transmission.id, {
            status: 'error',
            errorMessage: emailError.message,
          });
        }
      } catch (eventError: any) {
        log(`ERRORE RCA per evento ${ticketedEvent.id}: ${eventError.message}`);
      }
    }
    
    log('Job invio report RCA completato');
  } catch (error: any) {
    log(`ERRORE job RCA: ${error.message}`);
  }
}

let dailyIntervalId: NodeJS.Timeout | null = null;
let monthlyIntervalId: NodeJS.Timeout | null = null;
let eventCloseIntervalId: NodeJS.Timeout | null = null;
let resaleExpirationIntervalId: NodeJS.Timeout | null = null;
let rcaIntervalId: NodeJS.Timeout | null = null;

/**
 * Chiude automaticamente gli eventi la cui data/ora di fine è passata.
 * Cambia lo status da "ongoing" a "closed" quando end_datetime < NOW()
 */
async function autoCloseExpiredEvents() {
  try {
    const now = new Date();
    
    // Trova eventi con status 'ongoing' o 'scheduled' che sono già terminati
    const expiredEvents = await db.select()
      .from(events)
      .where(and(
        sql`${events.status} IN ('ongoing', 'scheduled')`,
        lt(events.endDatetime, now)
      ));
    
    if (expiredEvents.length === 0) {
      return; // Nessun evento da chiudere
    }
    
    log(`Trovati ${expiredEvents.length} eventi terminati da chiudere automaticamente`);
    
    for (const event of expiredEvents) {
      try {
        await db.update(events)
          .set({ 
            status: 'closed',
            updatedAt: now
          })
          .where(eq(events.id, event.id));
        
        log(`Evento "${event.name}" (ID: ${event.id}) chiuso automaticamente - fine: ${event.endDatetime}`);
      } catch (updateError: any) {
        log(`ERRORE chiusura evento ${event.id}: ${updateError.message}`);
      }
    }
    
    log(`Chiusura automatica completata: ${expiredEvents.length} eventi aggiornati`);
  } catch (error: any) {
    log(`ERRORE job chiusura eventi: ${error.message}`);
  }
}

/**
 * Rilascia le riservazioni scadute (reservedUntil < now).
 * Rimette il biglietto in vendita se l'utente non ha completato il checkout.
 */
async function releaseExpiredReservations() {
  try {
    const now = new Date();
    
    const result = await db.update(siaeResales)
      .set({
        status: 'listed',
        buyerId: null,
        reservedAt: null,
        reservedUntil: null,
        stripeCheckoutSessionId: null,
        updatedAt: now,
      })
      .where(and(
        eq(siaeResales.status, 'reserved'),
        lt(siaeResales.reservedUntil, now)
      ))
      .returning();
    
    if (result.length > 0) {
      log(`Rilasciate ${result.length} riservazioni scadute - biglietti tornati in vendita`);
    }
  } catch (error: any) {
    log(`ERRORE rilascio riservazioni scadute: ${error.message}`);
  }
}

/**
 * Scade automaticamente i biglietti in rivendita 1 ora prima dell'inizio evento.
 * Cambia lo status da "listed" a "expired" per proteggere venditore e acquirente.
 */
async function autoExpireResales() {
  try {
    const now = new Date();
    const oneHourFromNow = new Date(now.getTime() + 60 * 60 * 1000);
    
    // Trova resales con status 'listed' i cui eventi iniziano in meno di 1 ora
    // Join: siaeResales -> siaeTickets -> siaeTicketedEvents -> events
    const expiringResales = await db.select({
      resaleId: siaeResales.id,
      eventName: events.name,
      eventStart: events.startDatetime,
    })
    .from(siaeResales)
    .innerJoin(siaeTickets, eq(siaeResales.originalTicketId, siaeTickets.id))
    .innerJoin(siaeTicketedEvents, eq(siaeTickets.ticketedEventId, siaeTicketedEvents.id))
    .innerJoin(events, eq(siaeTicketedEvents.eventId, events.id))
    .where(and(
      eq(siaeResales.status, 'listed'),
      lte(events.startDatetime, oneHourFromNow)
    ));
    
    if (expiringResales.length === 0) {
      return; // Nessun resale da scadere
    }
    
    log(`Trovati ${expiringResales.length} biglietti in rivendita da far scadere (evento inizia in meno di 1 ora)`);
    
    for (const resale of expiringResales) {
      try {
        await db.update(siaeResales)
          .set({ 
            status: 'expired',
            expiresAt: now,
            updatedAt: now
          })
          .where(eq(siaeResales.id, resale.resaleId));
        
        log(`Rivendita ${resale.resaleId} scaduta - evento "${resale.eventName}" inizia alle ${resale.eventStart}`);
      } catch (updateError: any) {
        log(`ERRORE scadenza rivendita ${resale.resaleId}: ${updateError.message}`);
      }
    }
    
    log(`Scadenza automatica rivendite completata: ${expiringResales.length} biglietti rimossi dal marketplace`);
  } catch (error: any) {
    log(`ERRORE job scadenza rivendite: ${error.message}`);
  }
}

function checkAndRunDailyJob() {
  const now = new Date();
  const hour = now.getHours();
  const minute = now.getMinutes();

  if (hour === 2 && minute === 0) {
    sendDailyReports();
  }
}

function checkAndRunMonthlyJob() {
  const now = new Date();
  const day = now.getDate();
  const hour = now.getHours();
  const minute = now.getMinutes();

  if (day === 1 && hour === 3 && minute === 0) {
    sendMonthlyReports();
  }
}

export function initSiaeScheduler() {
  log('Inizializzazione scheduler SIAE (formato RiepilogoControlloAccessi)...');

  if (dailyIntervalId) clearInterval(dailyIntervalId);
  if (monthlyIntervalId) clearInterval(monthlyIntervalId);
  if (eventCloseIntervalId) clearInterval(eventCloseIntervalId);
  if (resaleExpirationIntervalId) clearInterval(resaleExpirationIntervalId);
  if (rcaIntervalId) clearInterval(rcaIntervalId);

  dailyIntervalId = setInterval(checkAndRunDailyJob, 60 * 1000);
  monthlyIntervalId = setInterval(checkAndRunMonthlyJob, 60 * 1000);
  
  // Job per chiudere automaticamente gli eventi terminati - ogni 5 minuti
  eventCloseIntervalId = setInterval(autoCloseExpiredEvents, 5 * 60 * 1000);
  
  // Job per scadenza automatica rivendite 1h prima evento - ogni 5 minuti
  resaleExpirationIntervalId = setInterval(autoExpireResales, 5 * 60 * 1000);
  
  // Job per rilascio riservazioni scadute - ogni minuto
  setInterval(releaseExpiredReservations, 60 * 1000);
  
  // Job per invio automatico RCA 24 ore dopo chiusura eventi - ogni ora
  rcaIntervalId = setInterval(sendRCAReports, 60 * 60 * 1000);
  
  // Esegui subito al primo avvio per chiudere eventi già scaduti e scadere rivendite
  autoCloseExpiredEvents();
  autoExpireResales();
  releaseExpiredReservations();

  log('Scheduler SIAE inizializzato:');
  log('  - Job RMG giornaliero: ogni notte alle 02:00');
  log('  - Job RPM mensile: primo giorno del mese alle 03:00');
  log('  - Job RCA evento: ogni ora (24h dopo chiusura evento)');
  log('  - Job chiusura eventi: ogni 5 minuti');
  log('  - Job scadenza rivendite: ogni 5 minuti (1h prima evento)');
  log('  - Job rilascio riservazioni: ogni minuto');
  log(`  - System Code Default: ${SIAE_SYSTEM_CODE_DEFAULT} (usa resolveSystemCode per coerenza)`);
  log(`  - Test Mode: ${SIAE_TEST_MODE}`);
}

export function stopSiaeScheduler() {
  if (dailyIntervalId) {
    clearInterval(dailyIntervalId);
    dailyIntervalId = null;
  }
  if (monthlyIntervalId) {
    clearInterval(monthlyIntervalId);
    monthlyIntervalId = null;
  }
  if (eventCloseIntervalId) {
    clearInterval(eventCloseIntervalId);
    eventCloseIntervalId = null;
  }
  if (resaleExpirationIntervalId) {
    clearInterval(resaleExpirationIntervalId);
    resaleExpirationIntervalId = null;
  }
  if (rcaIntervalId) {
    clearInterval(rcaIntervalId);
    rcaIntervalId = null;
  }
  log('Scheduler SIAE fermato');
}

export { sendDailyReports, sendMonthlyReports, sendRCAReports };


================================================================================
FILE: server/siae-xml-validator.ts
================================================================================
/**
 * SIAE XML Validator - Validates XML against official SIAE DTD specifications
 * Based on official SIAE PHP library DTD files v0039
 */

interface ValidationError {
  code: string;
  message: string;
  element?: string;
  expected?: string;
  found?: string;
}

interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationError[];
}

// DTD Element definitions extracted from official SIAE DTD files
const DTD_DEFINITIONS = {
  // RiepilogoGiornaliero (RMG) - Daily Report
  RiepilogoGiornaliero: {
    attributes: {
      required: ['Sostituzione', 'Data', 'DataGenerazione', 'OraGenerazione', 'ProgressivoGenerazione'],
      optional: [],
      values: {
        Sostituzione: ['N', 'S']
      }
    },
    children: {
      required: ['Titolare'],
      optional: ['Organizzatore'],
      order: ['Titolare', 'Organizzatore']
    }
  },

  // RiepilogoMensile (RPM) - Monthly Report  
  RiepilogoMensile: {
    attributes: {
      required: ['Sostituzione', 'Mese', 'DataGenerazione', 'OraGenerazione', 'ProgressivoGenerazione'],
      optional: [],
      values: {
        Sostituzione: ['N', 'S']
      }
    },
    children: {
      required: ['Titolare'],
      optional: ['Organizzatore'],
      order: ['Titolare', 'Organizzatore']
    }
  },

  // RiepilogoControlloAccessi (RCA) - Access Control Summary
  RiepilogoControlloAccessi: {
    attributes: {
      required: ['Sostituzione'],
      optional: [],
      values: {
        Sostituzione: ['N', 'S']
      }
    },
    children: {
      required: ['Titolare', 'Evento'],
      optional: [],
      order: ['Titolare', 'Evento']
    }
  },

  // Common elements
  Titolare: {
    children: {
      required: ['Denominazione', 'CodiceFiscale', 'SistemaEmissione'],
      optional: [],
      order: ['Denominazione', 'CodiceFiscale', 'SistemaEmissione']
    }
  },

  // RCA-specific Titolare (different structure)
  TitolareCA: {
    children: {
      required: ['DenominazioneTitolareCA', 'CFTitolareCA', 'CodiceSistemaCA', 'DataRiepilogo', 'DataGenerazioneRiepilogo', 'OraGenerazioneRiepilogo', 'ProgressivoRiepilogo'],
      optional: [],
      order: ['DenominazioneTitolareCA', 'CFTitolareCA', 'CodiceSistemaCA', 'DataRiepilogo', 'DataGenerazioneRiepilogo', 'OraGenerazioneRiepilogo', 'ProgressivoRiepilogo']
    }
  },

  Organizzatore: {
    children: {
      required: ['Denominazione', 'CodiceFiscale', 'TipoOrganizzatore'],
      optional: ['Evento', 'Abbonamenti', 'AltriProventiGenerici'],
      order: ['Denominazione', 'CodiceFiscale', 'TipoOrganizzatore', 'Evento', 'Abbonamenti', 'AltriProventiGenerici']
    }
  },

  TipoOrganizzatore: {
    attributes: {
      required: ['valore'],
      optional: [],
      values: {
        valore: ['E', 'P', 'G']
      }
    },
    empty: true
  },

  Evento: {
    children: {
      required: ['Intrattenimento', 'Locale', 'DataEvento', 'OraEvento', 'MultiGenere', 'OrdineDiPosto'],
      optional: ['AltriProventiEvento'],
      order: ['Intrattenimento', 'Locale', 'DataEvento', 'OraEvento', 'MultiGenere', 'OrdineDiPosto', 'AltriProventiEvento']
    }
  },

  // RCA-specific Evento (flat structure)
  EventoCA: {
    children: {
      required: ['CFOrganizzatore', 'DenominazioneOrganizzatore', 'TipologiaOrganizzatore', 'SpettacoloIntrattenimento', 'IncidenzaIntrattenimento', 'DenominazioneLocale', 'CodiceLocale', 'DataEvento', 'OraEvento', 'TipoGenere', 'TitoloEvento', 'Autore', 'Esecutore', 'NazionalitaFilm', 'NumOpereRappresentate', 'SistemaEmissione'],
      optional: [],
      order: ['CFOrganizzatore', 'DenominazioneOrganizzatore', 'TipologiaOrganizzatore', 'SpettacoloIntrattenimento', 'IncidenzaIntrattenimento', 'DenominazioneLocale', 'CodiceLocale', 'DataEvento', 'OraEvento', 'TipoGenere', 'TitoloEvento', 'Autore', 'Esecutore', 'NazionalitaFilm', 'NumOpereRappresentate', 'SistemaEmissione']
    }
  },

  Intrattenimento: {
    children: {
      required: ['TipoTassazione'],
      optional: ['Incidenza', 'ImponibileIntrattenimenti'], // ImponibileIntrattenimenti only for RPM
      order: ['TipoTassazione', 'Incidenza', 'ImponibileIntrattenimenti']
    }
  },

  TipoTassazione: {
    attributes: {
      required: ['valore'],
      optional: [],
      values: {
        valore: ['S', 'I']
      }
    },
    empty: true
  },

  Locale: {
    children: {
      required: ['Denominazione', 'CodiceLocale'],
      optional: [],
      order: ['Denominazione', 'CodiceLocale']
    }
  },

  MultiGenere: {
    children: {
      required: ['TipoGenere', 'IncidenzaGenere', 'TitoliOpere'],
      optional: [],
      order: ['TipoGenere', 'IncidenzaGenere', 'TitoliOpere']
    }
  },

  TitoliOpere: {
    children: {
      required: ['Titolo'],
      optional: ['ProduttoreCinema', 'Autore', 'Esecutore', 'Nazionalita', 'Distributore'],
      order: ['Titolo', 'ProduttoreCinema', 'Autore', 'Esecutore', 'Nazionalita', 'Distributore']
    }
  },

  // OrdineDiPosto for RMG (no IVAEccedenteOmaggi)
  OrdineDiPostoRMG: {
    children: {
      required: ['CodiceOrdine', 'Capienza'],
      optional: ['TitoliAccesso', 'TitoliAnnullati', 'TitoliAccessoIVAPreassolta', 'TitoliIVAPreassoltaAnnullati', 'BigliettiAbbonamento', 'BigliettiAbbonamentoAnnullati'],
      order: ['CodiceOrdine', 'Capienza', 'TitoliAccesso', 'TitoliAnnullati', 'TitoliAccessoIVAPreassolta', 'TitoliIVAPreassoltaAnnullati', 'BigliettiAbbonamento', 'BigliettiAbbonamentoAnnullati']
    }
  },

  // OrdineDiPosto for RPM (IVAEccedenteOmaggi required)
  OrdineDiPostoRPM: {
    children: {
      required: ['CodiceOrdine', 'Capienza', 'IVAEccedenteOmaggi'],
      optional: ['TitoliAccesso', 'TitoliAnnullati', 'TitoliAccessoIVAPreassolta', 'TitoliIVAPreassoltaAnnullati', 'BigliettiAbbonamento', 'BigliettiAbbonamentoAnnullati', 'AbbonamentiFissi'],
      order: ['CodiceOrdine', 'Capienza', 'IVAEccedenteOmaggi', 'TitoliAccesso', 'TitoliAnnullati', 'TitoliAccessoIVAPreassolta', 'TitoliIVAPreassoltaAnnullati', 'BigliettiAbbonamento', 'BigliettiAbbonamentoAnnullati', 'AbbonamentiFissi']
    }
  },

  TitoliAccesso: {
    children: {
      required: ['TipoTitolo', 'Quantita', 'CorrispettivoLordo', 'Prevendita', 'IVACorrispettivo', 'IVAPrevendita', 'ImportoPrestazione'],
      optional: [],
      order: ['TipoTitolo', 'Quantita', 'CorrispettivoLordo', 'Prevendita', 'IVACorrispettivo', 'IVAPrevendita', 'ImportoPrestazione']
    }
  },

  Turno: {
    attributes: {
      required: ['valore'],
      optional: [],
      values: {
        valore: ['F', 'L']
      }
    },
    empty: true
  },

  // RCA specific elements
  SistemaEmissione: {
    children: {
      required: ['CodiceSistemaEmissione'],
      optional: ['Titoli', 'Abbonamenti'],
      order: ['CodiceSistemaEmissione', 'Titoli', 'Abbonamenti']
    }
  },

  Titoli: {
    children: {
      required: ['CodiceOrdinePosto', 'Capienza', 'TotaleTipoTitolo'],
      optional: [],
      order: ['CodiceOrdinePosto', 'Capienza', 'TotaleTipoTitolo']
    }
  },

  TotaleTipoTitolo: {
    children: {
      required: ['TipoTitolo', 'TotaleTitoliLTA', 'TotaleTitoliNoAccessoTradiz', 'TotaleTitoliNoAccessoDigitali', 'TotaleTitoliAutomatizzatiTradiz', 'TotaleTitoliAutomatizzatiDigitali', 'TotaleTitoliManualiTradiz', 'TotaleTitoliManualiDigitali', 'TotaleTitoliAnnullatiTradiz', 'TotaleTitoliAnnullatiDigitali', 'TotaleTitoliDaspatiTradiz', 'TotaleTitoliDaspatiDigitali', 'TotaleTitoliRubatiTradiz', 'TotaleTitoliRubatiDigitali', 'TotaleTitoliBLTradiz', 'TotaleTitoliBLDigitali'],
      optional: [],
      order: ['TipoTitolo', 'TotaleTitoliLTA', 'TotaleTitoliNoAccessoTradiz', 'TotaleTitoliNoAccessoDigitali', 'TotaleTitoliAutomatizzatiTradiz', 'TotaleTitoliAutomatizzatiDigitali', 'TotaleTitoliManualiTradiz', 'TotaleTitoliManualiDigitali', 'TotaleTitoliAnnullatiTradiz', 'TotaleTitoliAnnullatiDigitali', 'TotaleTitoliDaspatiTradiz', 'TotaleTitoliDaspatiDigitali', 'TotaleTitoliRubatiTradiz', 'TotaleTitoliRubatiDigitali', 'TotaleTitoliBLTradiz', 'TotaleTitoliBLDigitali']
    }
  }
};

// Simple XML parser for validation
function parseXMLElement(xml: string): { tag: string; attributes: Record<string, string>; children: string[]; content: string } | null {
  const tagMatch = xml.match(/^<(\w+)([^>]*)>/);
  if (!tagMatch) return null;

  const tag = tagMatch[1];
  const attrString = tagMatch[2];
  
  // Parse attributes
  const attributes: Record<string, string> = {};
  const attrRegex = /(\w+)="([^"]*)"/g;
  let attrMatch;
  while ((attrMatch = attrRegex.exec(attrString)) !== null) {
    attributes[attrMatch[1]] = attrMatch[2];
  }

  // Find children elements
  const children: string[] = [];
  const childRegex = /<(\w+)[\s>]/g;
  let childMatch;
  // Skip the root element itself
  let remaining = xml.substring(tagMatch[0].length);
  while ((childMatch = childRegex.exec(remaining)) !== null) {
    if (!children.includes(childMatch[1])) {
      children.push(childMatch[1]);
    }
  }

  return { tag, attributes, children, content: xml };
}

// Get all direct child element names from XML
function getDirectChildren(xml: string, parentTag: string): string[] {
  const children: string[] = [];
  
  // Find the content between opening and closing tags
  const openTag = `<${parentTag}`;
  const closeTag = `</${parentTag}>`;
  
  const startIdx = xml.indexOf(openTag);
  if (startIdx === -1) return children;
  
  const endOfOpenTag = xml.indexOf('>', startIdx);
  if (endOfOpenTag === -1) return children;
  
  const endIdx = xml.lastIndexOf(closeTag);
  if (endIdx === -1) return children;
  
  const content = xml.substring(endOfOpenTag + 1, endIdx);
  
  // Find all direct child tags (simplified - counts first level only)
  let depth = 0;
  let currentTag = '';
  let inTag = false;
  
  for (let i = 0; i < content.length; i++) {
    const char = content[i];
    
    if (char === '<') {
      if (content[i + 1] === '/') {
        depth--;
      } else if (content[i + 1] !== '?' && content[i + 1] !== '!') {
        if (depth === 0) {
          inTag = true;
          currentTag = '';
        }
        depth++;
      }
    } else if (inTag && (char === ' ' || char === '>' || char === '/')) {
      if (currentTag && !children.includes(currentTag)) {
        children.push(currentTag);
      }
      inTag = false;
    } else if (inTag) {
      currentTag += char;
    }
  }
  
  return children;
}

// Check if element exists in XML
function hasElement(xml: string, elementName: string): boolean {
  const regex = new RegExp(`<${elementName}[\\s>]`);
  return regex.test(xml);
}

// Get attribute value from root element
function getRootAttribute(xml: string, attrName: string): string | null {
  const match = xml.match(new RegExp(`${attrName}="([^"]*)"`));
  return match ? match[1] : null;
}

// Get all attributes from root element
function getRootAttributes(xml: string): Record<string, string> {
  const attributes: Record<string, string> = {};
  // Remove newlines for simpler matching
  const xmlClean = xml.replace(/[\r\n]+/g, ' ');
  const rootMatch = xmlClean.match(/^<\?xml[^?]*\?>\s*<(\w+)([^>]*)>/);
  if (!rootMatch) {
    const altMatch = xml.match(/^<(\w+)([^>]*)>/);
    if (altMatch) {
      const attrString = altMatch[2];
      const attrRegex = /(\w+)="([^"]*)"/g;
      let match;
      while ((match = attrRegex.exec(attrString)) !== null) {
        attributes[match[1]] = match[2];
      }
    }
  } else {
    const attrString = rootMatch[2];
    const attrRegex = /(\w+)="([^"]*)"/g;
    let match;
    while ((match = attrRegex.exec(attrString)) !== null) {
      attributes[match[1]] = match[2];
    }
  }
  return attributes;
}

// Count occurrences of an element
function countElements(xml: string, elementName: string): number {
  const regex = new RegExp(`<${elementName}[\\s>]`, 'g');
  const matches = xml.match(regex);
  return matches ? matches.length : 0;
}

/**
 * Validate RMG (RiepilogoGiornaliero) XML
 */
export function validateRMG(xml: string): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationError[] = [];

  // Check root element
  if (!xml.includes('<RiepilogoGiornaliero')) {
    errors.push({
      code: 'INVALID_ROOT',
      message: 'Root element must be RiepilogoGiornaliero',
      expected: 'RiepilogoGiornaliero',
      found: 'Unknown'
    });
    return { valid: false, errors, warnings };
  }

  // Check required attributes
  const rootAttrs = getRootAttributes(xml);
  const requiredAttrs = ['Sostituzione', 'Data', 'DataGenerazione', 'OraGenerazione', 'ProgressivoGenerazione'];
  
  for (const attr of requiredAttrs) {
    if (!rootAttrs[attr]) {
      errors.push({
        code: 'MISSING_ATTRIBUTE',
        message: `Missing required attribute: ${attr}`,
        element: 'RiepilogoGiornaliero',
        expected: attr
      });
    }
  }

  // Check for invalid NomeFile attribute (not in official DTD)
  if (rootAttrs['NomeFile']) {
    warnings.push({
      code: 'INVALID_ATTRIBUTE',
      message: 'NomeFile attribute is not in official DTD v0039 - may cause validation errors',
      element: 'RiepilogoGiornaliero',
      found: 'NomeFile'
    });
  }

  // Validate Sostituzione value
  if (rootAttrs['Sostituzione'] && !['N', 'S'].includes(rootAttrs['Sostituzione'])) {
    errors.push({
      code: 'INVALID_ATTRIBUTE_VALUE',
      message: 'Sostituzione must be N or S',
      element: 'RiepilogoGiornaliero',
      expected: 'N or S',
      found: rootAttrs['Sostituzione']
    });
  }

  // Check Data format (YYYYMMDD)
  if (rootAttrs['Data'] && !/^\d{8}$/.test(rootAttrs['Data'])) {
    errors.push({
      code: 'INVALID_DATE_FORMAT',
      message: 'Data must be in YYYYMMDD format',
      element: 'RiepilogoGiornaliero',
      expected: 'YYYYMMDD',
      found: rootAttrs['Data']
    });
  }

  // Check required elements
  if (!hasElement(xml, 'Titolare')) {
    errors.push({
      code: 'MISSING_ELEMENT',
      message: 'Missing required element: Titolare',
      element: 'RiepilogoGiornaliero',
      expected: 'Titolare'
    });
  }

  // Check MultiGenere is present (required for events)
  if (hasElement(xml, 'Evento') && !hasElement(xml, 'MultiGenere')) {
    errors.push({
      code: 'MISSING_ELEMENT',
      message: 'MultiGenere is required for each Evento',
      element: 'Evento',
      expected: 'MultiGenere'
    });
  }

  // Check IVAEccedenteOmaggi should NOT be present in RMG
  if (hasElement(xml, 'IVAEccedenteOmaggi')) {
    errors.push({
      code: 'INVALID_ELEMENT',
      message: 'IVAEccedenteOmaggi should NOT be present in RiepilogoGiornaliero (only for RiepilogoMensile)',
      element: 'OrdineDiPosto',
      found: 'IVAEccedenteOmaggi'
    });
  }

  // Check Titolare structure
  if (hasElement(xml, 'Titolare')) {
    if (!hasElement(xml, 'Denominazione')) {
      errors.push({
        code: 'MISSING_ELEMENT',
        message: 'Missing Denominazione in Titolare',
        element: 'Titolare',
        expected: 'Denominazione'
      });
    }
    if (!hasElement(xml, 'CodiceFiscale')) {
      errors.push({
        code: 'MISSING_ELEMENT',
        message: 'Missing CodiceFiscale in Titolare',
        element: 'Titolare',
        expected: 'CodiceFiscale'
      });
    }
    if (!hasElement(xml, 'SistemaEmissione')) {
      errors.push({
        code: 'MISSING_ELEMENT',
        message: 'Missing SistemaEmissione in Titolare',
        element: 'Titolare',
        expected: 'SistemaEmissione'
      });
    }
  }

  return { valid: errors.length === 0, errors, warnings };
}

/**
 * Validate RPM (RiepilogoMensile) XML
 */
export function validateRPM(xml: string): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationError[] = [];

  // Check root element
  if (!xml.includes('<RiepilogoMensile')) {
    errors.push({
      code: 'INVALID_ROOT',
      message: 'Root element must be RiepilogoMensile',
      expected: 'RiepilogoMensile',
      found: 'Unknown'
    });
    return { valid: false, errors, warnings };
  }

  // Check required attributes
  const rootAttrs = getRootAttributes(xml);
  const requiredAttrs = ['Sostituzione', 'Mese', 'DataGenerazione', 'OraGenerazione', 'ProgressivoGenerazione'];
  
  for (const attr of requiredAttrs) {
    if (!rootAttrs[attr]) {
      errors.push({
        code: 'MISSING_ATTRIBUTE',
        message: `Missing required attribute: ${attr}`,
        element: 'RiepilogoMensile',
        expected: attr
      });
    }
  }

  // Check for invalid NomeFile attribute
  if (rootAttrs['NomeFile']) {
    warnings.push({
      code: 'INVALID_ATTRIBUTE',
      message: 'NomeFile attribute is not in official DTD v0039 - may cause validation errors',
      element: 'RiepilogoMensile',
      found: 'NomeFile'
    });
  }

  // Validate Sostituzione value
  if (rootAttrs['Sostituzione'] && !['N', 'S'].includes(rootAttrs['Sostituzione'])) {
    errors.push({
      code: 'INVALID_ATTRIBUTE_VALUE',
      message: 'Sostituzione must be N or S',
      element: 'RiepilogoMensile',
      expected: 'N or S',
      found: rootAttrs['Sostituzione']
    });
  }

  // Check Mese format (YYYYMM)
  if (rootAttrs['Mese'] && !/^\d{6}$/.test(rootAttrs['Mese'])) {
    errors.push({
      code: 'INVALID_DATE_FORMAT',
      message: 'Mese must be in YYYYMM format',
      element: 'RiepilogoMensile',
      expected: 'YYYYMM',
      found: rootAttrs['Mese']
    });
  }

  // Check required elements
  if (!hasElement(xml, 'Titolare')) {
    errors.push({
      code: 'MISSING_ELEMENT',
      message: 'Missing required element: Titolare',
      element: 'RiepilogoMensile',
      expected: 'Titolare'
    });
  }

  // Check MultiGenere is present (required for events)
  if (hasElement(xml, 'Evento') && !hasElement(xml, 'MultiGenere')) {
    errors.push({
      code: 'MISSING_ELEMENT',
      message: 'MultiGenere is required for each Evento',
      element: 'Evento',
      expected: 'MultiGenere'
    });
  }

  // Check IVAEccedenteOmaggi MUST be present in RPM OrdineDiPosto
  if (hasElement(xml, 'OrdineDiPosto') && !hasElement(xml, 'IVAEccedenteOmaggi')) {
    errors.push({
      code: 'MISSING_ELEMENT',
      message: 'IVAEccedenteOmaggi is REQUIRED in OrdineDiPosto for RiepilogoMensile',
      element: 'OrdineDiPosto',
      expected: 'IVAEccedenteOmaggi'
    });
  }

  return { valid: errors.length === 0, errors, warnings };
}

/**
 * Validate RCA (RiepilogoControlloAccessi) XML
 */
export function validateRCA(xml: string): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationError[] = [];

  // Check root element
  if (!xml.includes('<RiepilogoControlloAccessi')) {
    errors.push({
      code: 'INVALID_ROOT',
      message: 'Root element must be RiepilogoControlloAccessi',
      expected: 'RiepilogoControlloAccessi',
      found: 'Unknown'
    });
    return { valid: false, errors, warnings };
  }

  // Check required attributes
  const rootAttrs = getRootAttributes(xml);
  
  if (!rootAttrs['Sostituzione']) {
    errors.push({
      code: 'MISSING_ATTRIBUTE',
      message: 'Missing required attribute: Sostituzione',
      element: 'RiepilogoControlloAccessi',
      expected: 'Sostituzione'
    });
  }

  // Validate Sostituzione value
  if (rootAttrs['Sostituzione'] && !['N', 'S'].includes(rootAttrs['Sostituzione'])) {
    errors.push({
      code: 'INVALID_ATTRIBUTE_VALUE',
      message: 'Sostituzione must be N or S',
      element: 'RiepilogoControlloAccessi',
      expected: 'N or S',
      found: rootAttrs['Sostituzione']
    });
  }

  // Check required Titolare element with RCA-specific children
  if (!hasElement(xml, 'Titolare')) {
    errors.push({
      code: 'MISSING_ELEMENT',
      message: 'Missing required element: Titolare',
      element: 'RiepilogoControlloAccessi',
      expected: 'Titolare'
    });
  } else {
    // Check RCA-specific Titolare children
    const rcaTitolareElements = [
      'DenominazioneTitolareCA',
      'CFTitolareCA', 
      'CodiceSistemaCA',
      'DataRiepilogo',
      'DataGenerazioneRiepilogo',
      'OraGenerazioneRiepilogo',
      'ProgressivoRiepilogo'
    ];
    
    for (const elem of rcaTitolareElements) {
      if (!hasElement(xml, elem)) {
        errors.push({
          code: 'MISSING_ELEMENT',
          message: `Missing required element in Titolare: ${elem}`,
          element: 'Titolare',
          expected: elem
        });
      }
    }
  }

  // Check required Evento element
  if (!hasElement(xml, 'Evento')) {
    errors.push({
      code: 'MISSING_ELEMENT',
      message: 'At least one Evento is required',
      element: 'RiepilogoControlloAccessi',
      expected: 'Evento'
    });
  }

  // Check SistemaEmissione in Evento
  if (hasElement(xml, 'Evento') && !hasElement(xml, 'SistemaEmissione')) {
    errors.push({
      code: 'MISSING_ELEMENT',
      message: 'SistemaEmissione is required in Evento',
      element: 'Evento',
      expected: 'SistemaEmissione'
    });
  }

  return { valid: errors.length === 0, errors, warnings };
}

/**
 * Auto-detect report type and validate
 */
export function validateSiaeXML(xml: string): ValidationResult & { reportType: string } {
  // Detect report type
  if (xml.includes('<RiepilogoGiornaliero')) {
    return { ...validateRMG(xml), reportType: 'RMG' };
  } else if (xml.includes('<RiepilogoMensile')) {
    return { ...validateRPM(xml), reportType: 'RPM' };
  } else if (xml.includes('<RiepilogoControlloAccessi')) {
    return { ...validateRCA(xml), reportType: 'RCA' };
  } else {
    return {
      valid: false,
      errors: [{
        code: 'UNKNOWN_REPORT_TYPE',
        message: 'Unable to detect SIAE report type. Expected RiepilogoGiornaliero, RiepilogoMensile, or RiepilogoControlloAccessi',
        expected: 'RiepilogoGiornaliero | RiepilogoMensile | RiepilogoControlloAccessi'
      }],
      warnings: [],
      reportType: 'UNKNOWN'
    };
  }
}

/**
 * Format validation result for logging/display
 */
export function formatValidationResult(result: ValidationResult & { reportType?: string }): string {
  const lines: string[] = [];
  
  lines.push(`=== SIAE XML Validation Result ===`);
  lines.push(`Report Type: ${result.reportType || 'Unknown'}`);
  lines.push(`Valid: ${result.valid ? '✅ YES' : '❌ NO'}`);
  
  if (result.errors.length > 0) {
    lines.push(`\nErrors (${result.errors.length}):`);
    for (const error of result.errors) {
      lines.push(`  ❌ [${error.code}] ${error.message}`);
      if (error.element) lines.push(`     Element: ${error.element}`);
      if (error.expected) lines.push(`     Expected: ${error.expected}`);
      if (error.found) lines.push(`     Found: ${error.found}`);
    }
  }
  
  if (result.warnings.length > 0) {
    lines.push(`\nWarnings (${result.warnings.length}):`);
    for (const warning of result.warnings) {
      lines.push(`  ⚠️ [${warning.code}] ${warning.message}`);
      if (warning.element) lines.push(`     Element: ${warning.element}`);
      if (warning.found) lines.push(`     Found: ${warning.found}`);
    }
  }
  
  return lines.join('\n');
}

export type { ValidationResult, ValidationError };


================================================================================
FILE: server/bridge-relay.ts
================================================================================
import { WebSocketServer, WebSocket } from 'ws';
import type { Server } from 'http';
import type { IncomingMessage } from 'http';
import { parse as parseCookie } from 'cookie';
import { createHash } from 'crypto';
import { db } from './db';
import { companies, sessions } from '@shared/schema';
import { eq } from 'drizzle-orm';
import type { SiaeCardEfffData } from './siae-utils';

interface BridgeConnection {
  ws: WebSocket;
  connectedAt: Date;
  lastPing: Date;
}

// Master token from environment - used by the single Event Four You desktop app
const MASTER_TOKEN = process.env.SIAE_MASTER_TOKEN || '';

// Single global bridge (Event Four You's desktop app)
let globalBridge: BridgeConnection | null = null;

// Cached status from bridge - sent immediately to new clients
let cachedBridgeStatus: any = null;
let cachedBridgeStatusTimestamp: Date | null = null;

// Pending status request promise for synchronous status fetching
let pendingStatusRequest: {
  resolve: (status: any) => void;
  reject: (error: Error) => void;
  timeout: NodeJS.Timeout;
} | null = null;

const STATUS_REQUEST_TIMEOUT = 3000; // 3 seconds timeout for status request
const STATUS_MAX_AGE = 30000; // 30 seconds - consider status stale after this

interface ClientConnection {
  ws: WebSocket;
  userId: string;
  companyId: string;
  connectedAt: Date;
  lastPing: Date;
}

interface BridgeMessage {
  type: string;
  token?: string;
  companyId?: string;
  toCompanyId?: string;
  fromCompanyId?: string;
  fromUserId?: string;
  payload?: any;
  requestId?: string;
}

// Keep track of clients by company for routing responses
const activeClients = new Map<string, ClientConnection[]>();

const HEARTBEAT_INTERVAL = 15000;  // 15 seconds (aligned with desktop app)
const CONNECTION_TIMEOUT = 20000;  // 20 seconds (15s + 5s grace period)

// DEBUG: Get bridge status for diagnostics
export function getBridgeDebugStatus(): {
  globalBridgeExists: boolean;
  globalBridgeWsState: number | null;
  globalBridgeWsStateString: string | null;
  globalBridgeConnectedAt: string | null;
  globalBridgeLastPing: string | null;
  cachedBridgeStatus: any;
  cachedBridgeStatusTimestamp: string | null;
  cachedBridgeStatusAge: number | null;
  isStatusFresh: boolean;
  activeClientsCount: number;
  masterTokenConfigured: boolean;
} {
  const wsStateStrings: Record<number, string> = {
    0: 'CONNECTING',
    1: 'OPEN',
    2: 'CLOSING',
    3: 'CLOSED'
  };
  
  const statusAge = cachedBridgeStatusTimestamp 
    ? Date.now() - cachedBridgeStatusTimestamp.getTime() 
    : null;
  
  let clientCount = 0;
  activeClients.forEach(clients => clientCount += clients.length);
  
  return {
    globalBridgeExists: !!globalBridge,
    globalBridgeWsState: globalBridge?.ws?.readyState ?? null,
    globalBridgeWsStateString: globalBridge?.ws?.readyState !== undefined 
      ? wsStateStrings[globalBridge.ws.readyState] || 'UNKNOWN' 
      : null,
    globalBridgeConnectedAt: globalBridge?.connectedAt?.toISOString() ?? null,
    globalBridgeLastPing: globalBridge?.lastPing?.toISOString() ?? null,
    cachedBridgeStatus: cachedBridgeStatus,
    cachedBridgeStatusTimestamp: cachedBridgeStatusTimestamp?.toISOString() ?? null,
    cachedBridgeStatusAge: statusAge,
    isStatusFresh: isStatusFresh(),
    activeClientsCount: clientCount,
    masterTokenConfigured: !!MASTER_TOKEN
  };
}

export function setupBridgeRelay(server: Server): void {
  const wss = new WebSocketServer({ noServer: true });
  
  console.log(`[Bridge] ============================================`);
  console.log(`[Bridge] BRIDGE RELAY STARTUP`);
  console.log(`[Bridge] MASTER_TOKEN configured: ${!!MASTER_TOKEN}`);
  console.log(`[Bridge] MASTER_TOKEN first 8 chars: ${MASTER_TOKEN?.substring(0, 8) || 'NONE'}...`);
  console.log(`[Bridge] ============================================`);

  server.on('upgrade', async (request: IncomingMessage, socket, head) => {
    const url = new URL(request.url || '', `http://${request.headers.host}`);
    
    console.log(`[Bridge] HTTP Upgrade request received: path=${url.pathname}`);
    
    // Only handle /ws/bridge - let other handlers manage their paths
    if (url.pathname === '/ws/bridge') {
      console.log(`[Bridge] Handling upgrade for /ws/bridge`);
      wss.handleUpgrade(request, socket, head, (ws) => {
        wss.emit('connection', ws, request);
      });
    } else {
      console.log(`[Bridge] Ignoring upgrade for path: ${url.pathname}`);
    }
    // Don't destroy socket for other paths - they may be handled by other WebSocket servers
  });

  wss.on('connection', async (ws: WebSocket, request: IncomingMessage) => {
    const remoteAddr = request.socket.remoteAddress;
    const userAgent = request.headers['user-agent']?.substring(0, 50) || 'unknown';
    console.log(`[Bridge] ============================================`);
    console.log(`[Bridge] NEW WEBSOCKET CONNECTION`);
    console.log(`[Bridge] Remote address: ${remoteAddr}`);
    console.log(`[Bridge] User-Agent: ${userAgent}...`);
    console.log(`[Bridge] Current globalBridge exists: ${!!globalBridge}`);
    console.log(`[Bridge] Current globalBridge ws state: ${globalBridge?.ws?.readyState ?? 'N/A'}`);
    console.log(`[Bridge] ============================================`);
    
    let connectionType: 'bridge' | 'client' | null = null;
    let connectionInfo: { userId?: string; companyId?: string; effectiveCompanyId?: string } = {};

    const cookies = request.headers.cookie ? parseCookie(request.headers.cookie) : {};
    const sessionId = cookies['connect.sid'];
    
    console.log(`[Bridge] Raw cookie header: ${request.headers.cookie ? request.headers.cookie.substring(0, 100) + '...' : 'NONE'}`);
    console.log(`[Bridge] Cookie received: ${sessionId ? 'yes (connect.sid present)' : 'no cookie'}`);
    
    if (!sessionId) {
      console.log(`[Bridge] WARNING: No session cookie! WebSocket connection without authentication.`);
      console.log(`[Bridge] This could mean: 1) User not logged in, 2) Cookie not being sent, 3) CORS/SameSite issue`);
    }

    if (sessionId) {
      const session = await getSessionData(sessionId);
      console.log(`[Bridge] Session lookup result: ${session ? 'found' : 'not found'}`);
      console.log(`[Bridge] Session passport.user: ${session?.passport?.user ? 'present' : 'missing'}`);
      
      if (session?.passport?.user) {
        connectionType = 'client';
        // User ID can be in different locations depending on auth method:
        // - Classic login: session.passport.user.id
        // - Replit OAuth: session.passport.user.claims.sub
        const user = session.passport.user;
        const userId = user.id || user.claims?.sub || 'unknown';
        const companyId = user.companyId;
        
        connectionInfo = {
          userId,
          companyId,
        };
        // Super admin doesn't have companyId, but should still receive bridge status
        // Use a special "super_admin" company key for routing
        const effectiveCompanyId = connectionInfo.companyId || (user.role === 'super_admin' ? 'super_admin' : null);
        connectionInfo.effectiveCompanyId = effectiveCompanyId || undefined;
        
        console.log(`[Bridge] Client connected: userId=${connectionInfo.userId}, companyId=${connectionInfo.companyId}, effectiveCompanyId=${effectiveCompanyId}, role=${user.role}`);
        
        if (effectiveCompanyId && connectionInfo.userId) {
          addClient(effectiveCompanyId, connectionInfo.userId, ws);
          
          // Check if global bridge is connected (single Event Four You app)
          const bridgeConnected = globalBridge !== null && globalBridge.ws.readyState === WebSocket.OPEN;
          console.log(`[Bridge] Sending connection_status to client: bridgeConnected=${bridgeConnected}`);
          ws.send(JSON.stringify({
            type: 'connection_status',
            bridgeConnected,
            connected: bridgeConnected, // Also send as 'connected' for compatibility
            message: bridgeConnected ? 'Bridge desktop app is connected' : 'Bridge desktop app is not connected',
          }));
          
          // Send cached status immediately if available (no waiting for polling)
          if (cachedBridgeStatus && bridgeConnected) {
            console.log(`[Bridge] Sending cached status to new client immediately`);
            ws.send(JSON.stringify(cachedBridgeStatus));
          }
        } else {
          console.log(`[Bridge] WARNING: Cannot add client - missing effectiveCompanyId or userId`);
          // Still send connection status even if we can't track the client
          const bridgeConnected = globalBridge !== null && globalBridge.ws.readyState === WebSocket.OPEN;
          ws.send(JSON.stringify({
            type: 'connection_status',
            bridgeConnected,
            connected: bridgeConnected,
            message: bridgeConnected ? 'Bridge desktop app is connected' : 'Bridge desktop app is not connected',
          }));
        }
      }
    }

    ws.on('message', async (data: Buffer) => {
      try {
        const message: BridgeMessage = JSON.parse(data.toString());
        console.log(`[Bridge] Message received: type=${message.type}`);

        if (message.type === 'bridge_register') {
          const result = await handleBridgeRegistration(ws, message);
          if (result.success) {
            connectionType = 'bridge';
            console.log(`[Bridge] Global bridge registered successfully`);
          }
          return;
        }

        // Respond to ping with pong (critical for keeping bridge connection alive)
        if (message.type === 'ping') {
          try {
            ws.send(JSON.stringify({ type: 'pong' }));
          } catch (e) {
            // Ignore send errors
          }
          return;
        }

        if (message.type === 'pong') {
          if (connectionType === 'bridge' && globalBridge) {
            globalBridge.lastPing = new Date();
          } else if (connectionType === 'client' && connectionInfo.effectiveCompanyId && connectionInfo.userId) {
            // Use effectiveCompanyId (handles super_admin case)
            const clients = activeClients.get(connectionInfo.effectiveCompanyId);
            if (clients) {
              const client = clients.find(c => c.userId === connectionInfo.userId);
              if (client) {
                client.lastPing = new Date();
                console.log(`[Bridge] Pong received from userId=${connectionInfo.userId}, lastPing updated`);
              }
            }
          }
          return;
        }

        if (connectionType === 'client' && connectionInfo.effectiveCompanyId) {
          // Forward to global bridge with company info for routing response
          forwardToBridge(connectionInfo.effectiveCompanyId, message, connectionInfo.userId);
        } else if (connectionType === 'bridge') {
          // Messages from the bridge
          if (message.type === 'status') {
            // Cache the status for new clients with timestamp
            cachedBridgeStatus = message;
            cachedBridgeStatusTimestamp = new Date();
            
            // Resolve any pending status request
            if (pendingStatusRequest) {
              clearTimeout(pendingStatusRequest.timeout);
              pendingStatusRequest.resolve(message);
              pendingStatusRequest = null;
              console.log(`[Bridge] Resolved pending status request`);
            }
            
            // Bridge status update - broadcast to ALL clients
            console.log(`[Bridge] Broadcasting status update to all clients:`, JSON.stringify(message).substring(0, 500));
            console.log(`[Bridge] Status payload details:`, JSON.stringify(message.payload, null, 2));
            broadcastToAllClients(message);
          } else if (message.type === 'STATUS_RESPONSE') {
            // Handle fresh status response from desktop app (for payment verification)
            console.log(`[Bridge] STATUS_RESPONSE received: requestId=${message.requestId}`);
            console.log(`[Bridge] STATUS_RESPONSE payload:`, JSON.stringify(message.payload, null, 2));
            
            const payload = message.payload || {};
            // FIX: Treat response as success if no explicit error is present
            // Desktop bridge may not send explicit success:true flag
            const hasExplicitError = !!payload.error;
            const isSuccess = payload.success === true || (!hasExplicitError && (payload.readerConnected !== undefined || payload.cardInserted !== undefined || payload.bridgeConnected !== undefined));
            const hasError = hasExplicitError;
            
            console.log(`[Bridge] STATUS_RESPONSE evaluation: hasExplicitError=${hasExplicitError}, isSuccess=${isSuccess}, payload keys: ${Object.keys(payload).join(',')}`);
            
            // Only update cached status with fresh data if response is successful
            // This prevents transient errors from corrupting known-good state
            if (isSuccess) {
              cachedBridgeStatus = {
                type: 'status',
                data: {
                  bridgeConnected: payload.bridgeConnected ?? false,
                  readerConnected: payload.readerConnected ?? false,
                  cardInserted: payload.cardInserted ?? false,
                  pinVerified: payload.pinVerified ?? false,
                  demoMode: payload.demoMode ?? false,
                  timestamp: payload.timestamp || Date.now()
                },
                payload: payload
              };
              cachedBridgeStatusTimestamp = new Date();
              console.log(`[Bridge] Cached status updated from successful STATUS_RESPONSE`);
            } else {
              console.log(`[Bridge] STATUS_RESPONSE indicates failure, preserving previous cached status`);
            }
            
            // Handle pending status request - reject on failure, resolve on success
            if (pendingStatusRequest) {
              clearTimeout(pendingStatusRequest.timeout);
              if (hasError) {
                const errorMsg = payload.error || 'Status request failed';
                console.log(`[Bridge] Rejecting pending status request: ${errorMsg}`);
                pendingStatusRequest.reject(new Error(errorMsg));
              } else {
                pendingStatusRequest.resolve({
                  type: 'status',
                  data: cachedBridgeStatus?.data || payload,
                  payload: payload
                });
                console.log(`[Bridge] Resolved pending status request from STATUS_RESPONSE`);
              }
              pendingStatusRequest = null;
            }
          } else if (message.type === 'SEAL_RESPONSE') {
            // Handle seal response from desktop app (for server-side seal requests)
            console.log(`[Bridge] Seal response received: requestId=${message.requestId}`);
            console.log(`[Bridge] Seal payload: ${JSON.stringify(message.payload)}`);
            console.log(`[Bridge] Seal data: ${JSON.stringify(message.payload?.seal)}`);
            handleSealResponse(
              message.requestId || '',
              message.payload?.success ?? false,
              message.payload?.seal,
              message.payload?.error
            );
            // Also forward to clients if there's a toCompanyId
            if (message.toCompanyId) {
              forwardToClients(message.toCompanyId as string, message);
            }
          } else if (message.type === 'SIGNATURE_RESPONSE') {
            // Handle XML signature response from desktop app (for digital signing)
            console.log(`[Bridge] XML Signature response received: requestId=${message.requestId}`);
            handleSignatureResponse(
              message.requestId || '',
              message.payload?.success ?? false,
              message.payload?.signatureData,
              message.payload?.error
            );
            // Also forward to clients if there's a toCompanyId
            if (message.toCompanyId) {
              forwardToClients(message.toCompanyId as string, message);
            }
          } else if (message.type === 'SMIME_SIGNATURE_RESPONSE') {
            // Handle S/MIME signature response from desktop app (for SIAE email signing)
            console.log(`[Bridge] S/MIME Signature response received: requestId=${message.requestId}`);
            handleSmimeSignatureResponse(
              message.requestId || '',
              message.payload?.success ?? false,
              message.payload?.signatureData,
              message.payload?.error
            );
            // Also forward to clients if there's a toCompanyId
            if (message.toCompanyId) {
              forwardToClients(message.toCompanyId as string, message);
            }
          } else if (message.type === 'EFFF_RESPONSE') {
            // Handle EFFF read response from desktop app (Smart Card anagrafica data)
            console.log(`[Bridge] EFFF response received: requestId=${message.requestId}`);
            handleEfffResponse(
              message.requestId || '',
              message.payload?.success ?? false,
              message.payload?.efffData,
              message.payload?.error
            );
            // Also forward to clients if there's a toCompanyId
            if (message.toCompanyId) {
              forwardToClients(message.toCompanyId as string, message);
            }
          } else if (message.toCompanyId) {
            // Response to specific client request
            forwardToClients(message.toCompanyId as string, message);
          }
        }

      } catch (error) {
        console.error('[Bridge] Error processing message:', error);
        ws.send(JSON.stringify({
          type: 'error',
          message: 'Failed to process message',
        }));
      }
    });

    ws.on('close', (code: number, reason: Buffer) => {
      const reasonStr = reason?.toString() || 'no reason';
      console.log(`[Bridge] ============================================`);
      console.log(`[Bridge] CONNECTION CLOSED`);
      console.log(`[Bridge] Type: ${connectionType}`);
      console.log(`[Bridge] Close code: ${code}`);
      console.log(`[Bridge] Close reason: ${reasonStr}`);
      console.log(`[Bridge] Remote address: ${remoteAddr}`);
      console.log(`[Bridge] ============================================`);
      
      if (connectionType === 'bridge') {
        console.log(`[Bridge] GLOBAL BRIDGE DISCONNECTED - clearing state`);
        globalBridge = null;
        cachedBridgeStatus = null; // Clear cached status when bridge disconnects
        cachedBridgeStatusTimestamp = null;
        
        // Reject any pending status request
        if (pendingStatusRequest) {
          clearTimeout(pendingStatusRequest.timeout);
          pendingStatusRequest.reject(new Error('Bridge disconnected'));
          pendingStatusRequest = null;
        }
        
        // Notify ALL clients that bridge disconnected
        console.log(`[Bridge] Notifying all clients of bridge disconnection`);
        notifyAllClientsOfBridgeStatus(false);
        console.log(`[Bridge] Global bridge disconnected`);
      } else if (connectionType === 'client' && connectionInfo.effectiveCompanyId && connectionInfo.userId) {
        // Use effectiveCompanyId for cleanup (handles super_admin case)
        removeClient(connectionInfo.effectiveCompanyId, connectionInfo.userId);
        console.log(`[Bridge] Client disconnected: userId=${connectionInfo.userId}`);
      }
    });

    ws.on('error', (error) => {
      console.error('[Bridge] WebSocket error:', error);
    });
  });

  setInterval(() => {
    const now = new Date();

    // Check global bridge timeout
    if (globalBridge) {
      if (now.getTime() - globalBridge.lastPing.getTime() > CONNECTION_TIMEOUT) {
        console.log(`[Bridge] Global bridge timeout`);
        globalBridge.ws.terminate();
        globalBridge = null;
        notifyAllClientsOfBridgeStatus(false);
      } else {
        globalBridge.ws.send(JSON.stringify({ type: 'ping' }));
      }
    }

    activeClients.forEach((clients, companyId) => {
      clients.forEach((client, index) => {
        if (now.getTime() - client.lastPing.getTime() > CONNECTION_TIMEOUT) {
          console.log(`[Bridge] Client timeout: userId=${client.userId}`);
          client.ws.terminate();
          clients.splice(index, 1);
        } else {
          client.ws.send(JSON.stringify({ type: 'ping' }));
        }
      });
      
      if (clients.length === 0) {
        activeClients.delete(companyId);
      }
    });
  }, HEARTBEAT_INTERVAL);

  console.log('[Bridge] WebSocket relay bridge initialized');
}

async function getSessionData(sessionId: string): Promise<any | null> {
  try {
    // Log the raw session ID from cookie
    console.log(`[Bridge] Raw session ID from cookie: ${sessionId?.substring(0, 30)}...`);
    
    // URL-decode the session ID first (browser sends it URL-encoded)
    const decodedSessionId = decodeURIComponent(sessionId);
    console.log(`[Bridge] URL-decoded session ID: ${decodedSessionId?.substring(0, 30)}...`);
    
    // Remove 's:' prefix and signature
    const cleanSessionId = decodedSessionId.replace(/^s:/, '').split('.')[0];
    console.log(`[Bridge] Clean session ID for DB lookup: ${cleanSessionId}`);
    
    const result = await db
      .select()
      .from(sessions)
      .where(eq(sessions.sid, cleanSessionId))
      .limit(1);

    console.log(`[Bridge] DB lookup returned ${result.length} rows`);
    
    if (result.length > 0 && result[0].sess) {
      const sess = result[0].sess as any;
      console.log(`[Bridge] Session data: role=${sess?.passport?.user?.role}, companyId=${sess?.passport?.user?.companyId}, hasClaimsSub=${!!sess?.passport?.user?.claims?.sub}`);
      return sess;
    }
    return null;
  } catch (error) {
    console.error('[Bridge] Error fetching session:', error);
    return null;
  }
}

async function handleBridgeRegistration(
  ws: WebSocket,
  message: BridgeMessage
): Promise<{ success: boolean; error?: string }> {
  const { token } = message;

  if (!token) {
    ws.send(JSON.stringify({
      type: 'bridge_register_response',
      success: false,
      error: 'Token is required',
    }));
    return { success: false, error: 'Token is required' };
  }

  // Validate against master token from environment
  if (!MASTER_TOKEN) {
    console.error('[Bridge] SIAE_MASTER_TOKEN not configured on server');
    ws.send(JSON.stringify({
      type: 'bridge_register_response',
      success: false,
      error: 'Server not configured',
    }));
    return { success: false, error: 'Server not configured' };
  }

  console.log(`[Bridge] Registration attempt with master token: ${token?.substring(0, 8)}...`);
  
  if (token !== MASTER_TOKEN) {
    console.log(`[Bridge] Registration failed: Invalid master token`);
    ws.send(JSON.stringify({
      type: 'bridge_register_response',
      success: false,
      error: 'Invalid token',
    }));
    return { success: false, error: 'Invalid token' };
  }

  // Close existing bridge if any
  if (globalBridge) {
    console.log(`[Bridge] Replacing existing global bridge`);
    globalBridge.ws.terminate();
  }

  // Set as global bridge
  globalBridge = {
    ws,
    connectedAt: new Date(),
    lastPing: new Date(),
  };

  ws.send(JSON.stringify({
    type: 'bridge_register_response',
    success: true,
    message: 'Bridge registered successfully',
  }));

  // Notify all clients that bridge is now connected
  notifyAllClientsOfBridgeStatus(true);

  console.log(`[Bridge] Global bridge registered successfully`);
  return { success: true };
}

function addClient(companyId: string, userId: string, ws: WebSocket): void {
  if (!activeClients.has(companyId)) {
    activeClients.set(companyId, []);
  }
  
  const clients = activeClients.get(companyId)!;
  const existingIndex = clients.findIndex(c => c.userId === userId);
  
  if (existingIndex >= 0) {
    clients[existingIndex].ws.terminate();
    clients.splice(existingIndex, 1);
  }
  
  clients.push({
    ws,
    userId,
    companyId,
    connectedAt: new Date(),
    lastPing: new Date(),
  });
}

function removeClient(companyId: string, userId: string): void {
  const clients = activeClients.get(companyId);
  if (clients) {
    const index = clients.findIndex(c => c.userId === userId);
    if (index >= 0) {
      clients.splice(index, 1);
    }
    if (clients.length === 0) {
      activeClients.delete(companyId);
    }
  }
}

function notifyAllClientsOfBridgeStatus(connected: boolean): void {
  const message = JSON.stringify({
    type: 'bridge_status',
    connected,
    message: connected ? 'Bridge desktop app connected' : 'Bridge desktop app disconnected',
  });
  
  // Notify ALL clients across all companies
  activeClients.forEach((clients) => {
    clients.forEach(client => {
      if (client.ws.readyState === WebSocket.OPEN) {
        client.ws.send(message);
      }
    });
  });
}

function broadcastToAllClients(message: BridgeMessage): void {
  const messageStr = JSON.stringify(message);
  let clientCount = 0;
  
  // Broadcast to ALL clients across all companies
  activeClients.forEach((clients) => {
    clients.forEach(client => {
      if (client.ws.readyState === WebSocket.OPEN) {
        try {
          client.ws.send(messageStr);
          clientCount++;
        } catch (e) {
          console.error('[Bridge] Error broadcasting to client:', e);
        }
      }
    });
  });
  
  console.log(`[Bridge] Broadcasted message type=${message.type} to ${clientCount} clients`);
}

function forwardToBridge(companyId: string, message: BridgeMessage, userId?: string): void {
  if (globalBridge && globalBridge.ws.readyState === WebSocket.OPEN) {
    // Include company info so bridge knows where to route response
    globalBridge.ws.send(JSON.stringify({
      ...message,
      fromUserId: userId,
      fromCompanyId: companyId,
    }));
  } else {
    console.log(`[Bridge] Global bridge not connected`);
  }
}

function forwardToClients(companyId: string, message: BridgeMessage): void {
  const clients = activeClients.get(companyId);
  if (clients) {
    const messageStr = JSON.stringify(message);
    clients.forEach(client => {
      if (client.ws.readyState === WebSocket.OPEN) {
        client.ws.send(messageStr);
      }
    });
  }
}

export function isBridgeConnected(): boolean {
  return globalBridge !== null && globalBridge.ws.readyState === WebSocket.OPEN;
}

export function getCachedBridgeStatus(): any {
  const connected = isBridgeConnected();
  if (!connected) {
    return {
      bridgeConnected: false,
      readerConnected: false,
      cardInserted: false,
      readerName: null,
      cardSerial: null
    };
  }
  
  // Return cached status or default if no status received yet
  if (cachedBridgeStatus) {
    // Desktop app sends { type: 'status', data: {...} }
    const statusData = cachedBridgeStatus.data || cachedBridgeStatus.payload || {};
    return {
      ...statusData,
      bridgeConnected: true, // Always true when bridge is connected - must come AFTER spread to prevent override
    };
  }
  
  return {
    bridgeConnected: true,
    readerConnected: false,
    cardInserted: false,
    readerName: null,
    cardSerial: null
  };
}

export function getActiveBridgesCount(): number {
  return globalBridge ? 1 : 0;
}

export function getActiveClientsCount(): number {
  let count = 0;
  activeClients.forEach(clients => {
    count += clients.length;
  });
  return count;
}

// ==================== SEAL REQUEST BROKER ====================
// Pending seal requests waiting for response from desktop bridge
interface PendingSealRequest {
  resolve: (seal: FiscalSealData) => void;
  reject: (error: Error) => void;
  timeout: NodeJS.Timeout;
  createdAt: Date;
}

export interface FiscalSealData {
  sealCode: string;
  sealNumber: string;
  serialNumber: string;
  counter: number;
  mac: string;
  dateTime: string;
}

const pendingSealRequests = new Map<string, PendingSealRequest>();

const SEAL_REQUEST_TIMEOUT = 5000; // 5 seconds for better UX

// Generate UUID for request tracking
function generateRequestId(): string {
  return `seal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// Request a fresh status from the desktop bridge
async function requestFreshStatus(): Promise<any> {
  console.log(`[Bridge] Requesting fresh status from desktop bridge`);
  
  if (!globalBridge || globalBridge.ws.readyState !== WebSocket.OPEN) {
    throw new Error('Bridge not connected');
  }
  
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      if (pendingStatusRequest) {
        pendingStatusRequest = null;
        console.log(`[Bridge] Status request timeout`);
        reject(new Error('Status request timeout'));
      }
    }, STATUS_REQUEST_TIMEOUT);
    
    pendingStatusRequest = { resolve, reject, timeout };
    
    // Send status request to bridge
    const requestId = `status-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    try {
      globalBridge!.ws.send(JSON.stringify({
        type: 'STATUS_REQUEST',
        requestId,
        timestamp: new Date().toISOString()
      }));
      console.log(`[Bridge] Sent STATUS_REQUEST to desktop bridge, requestId=${requestId}`);
    } catch (error) {
      clearTimeout(timeout);
      pendingStatusRequest = null;
      reject(error);
    }
  });
}

// Check if cached status is fresh enough
function isStatusFresh(): boolean {
  if (!cachedBridgeStatusTimestamp) return false;
  const age = Date.now() - cachedBridgeStatusTimestamp.getTime();
  return age < STATUS_MAX_AGE;
}

// Ensure we have fresh status before checking card readiness (async version)
export async function ensureCardReadyForSeals(): Promise<{ ready: boolean; error: string | null }> {
  console.log(`[Bridge] ensureCardReadyForSeals called`);
  
  // If no bridge connected, fail fast
  if (!globalBridge || globalBridge.ws.readyState !== WebSocket.OPEN) {
    console.log(`[Bridge] Bridge not connected`);
    return { ready: false, error: 'App desktop Event4U non connessa' };
  }
  
  // If status is stale or missing, request a fresh one
  if (!cachedBridgeStatus || !isStatusFresh()) {
    console.log(`[Bridge] Status is stale or missing, requesting fresh status`);
    try {
      await requestFreshStatus();
      console.log(`[Bridge] Got fresh status`);
    } catch (error: any) {
      // Distinguish between transport errors and reader/card errors
      const errorMessage = error?.message || String(error);
      console.log(`[Bridge] Failed to get fresh status: ${errorMessage}`);
      
      // If this is a timeout, we can try with cached status as a fallback
      // But for definitive reader/card errors, we must fail fast
      if (errorMessage.includes('timeout') && cachedBridgeStatus) {
        console.log(`[Bridge] Timeout getting fresh status, using cached status as fallback`);
        // Continue to check cached status
      } else {
        // This is a definitive error from the desktop app - propagate it
        return { ready: false, error: errorMessage || 'Impossibile verificare stato Smart Card' };
      }
    }
  }
  
  // Now check the status
  return isCardReadyForSeals();
}

// Check if card is ready for seal emission (sync version - uses cached status)
export function isCardReadyForSeals(): { ready: boolean; error: string | null } {
  console.log(`[Bridge] isCardReadyForSeals called`);
  console.log(`[Bridge] globalBridge exists: ${!!globalBridge}`);
  console.log(`[Bridge] cachedBridgeStatus: ${JSON.stringify(cachedBridgeStatus)}`);
  
  if (!globalBridge || globalBridge.ws.readyState !== WebSocket.OPEN) {
    console.log(`[Bridge] Bridge not connected`);
    return { ready: false, error: 'App desktop Event4U non connessa' };
  }
  
  // Desktop app sends { type: 'status', data: {...} } or { type: 'status', payload: {...} }
  // Handle multiple nesting levels
  const status = cachedBridgeStatus?.data?.payload || 
                 cachedBridgeStatus?.payload?.data ||
                 cachedBridgeStatus?.data || 
                 cachedBridgeStatus?.payload || 
                 cachedBridgeStatus;
  console.log(`[Bridge] Extracted status: ${JSON.stringify(status)}`);
  
  if (!status) {
    console.log(`[Bridge] No status available`);
    return { ready: false, error: 'Stato lettore sconosciuto' };
  }
  
  // Handle different field naming conventions from desktop app
  const readerConnected = status.readerConnected ?? status.isReaderConnected ?? status.reader_connected ?? status.readerDetected ?? false;
  const cardInserted = status.cardInserted ?? status.isCardInserted ?? status.card_inserted ?? status.cardPresent ?? false;
  
  console.log(`[Bridge] Normalized values: readerConnected=${readerConnected}, cardInserted=${cardInserted}`);
  
  if (!readerConnected) {
    console.log(`[Bridge] Reader not connected`);
    return { ready: false, error: 'Lettore Smart Card non rilevato' };
  }
  
  if (!cardInserted) {
    console.log(`[Bridge] Card not inserted`);
    return { ready: false, error: 'Smart Card SIAE non inserita' };
  }
  
  console.log(`[Bridge] Card ready for seals!`);
  return { ready: true, error: null };
}

// Request a fiscal seal from the desktop bridge
export async function requestFiscalSeal(priceInCents: number): Promise<FiscalSealData> {
  console.log(`[Bridge] requestFiscalSeal called with priceInCents=${priceInCents}`);
  console.log(`[Bridge] globalBridge exists: ${!!globalBridge}`);
  if (globalBridge) {
    console.log(`[Bridge] globalBridge.ws.readyState: ${globalBridge.ws.readyState} (OPEN=1)`);
  }
  
  // Check if bridge is connected
  if (!globalBridge || globalBridge.ws.readyState !== WebSocket.OPEN) {
    console.log(`[Bridge] ERROR: Bridge not connected or not open`);
    throw new Error('SEAL_BRIDGE_OFFLINE: App desktop Event4U non connessa. Impossibile generare sigillo fiscale.');
  }
  
  // Check if card is ready
  const cardReady = isCardReadyForSeals();
  console.log(`[Bridge] Card ready check: ${JSON.stringify(cardReady)}`);
  if (!cardReady.ready) {
    throw new Error(`SEAL_CARD_NOT_READY: ${cardReady.error}`);
  }
  
  const requestId = generateRequestId();
  const price = priceInCents / 100;
  
  console.log(`[Bridge] Requesting fiscal seal: requestId=${requestId}, price=${price}, sending to bridge...`);
  
  return new Promise<FiscalSealData>((resolve, reject) => {
    // Set timeout
    const timeout = setTimeout(() => {
      pendingSealRequests.delete(requestId);
      console.log(`[Bridge] Seal request timeout: requestId=${requestId}`);
      reject(new Error('SEAL_TIMEOUT: Timeout generazione sigillo fiscale. Riprovare.'));
    }, SEAL_REQUEST_TIMEOUT);
    
    // Store pending request
    pendingSealRequests.set(requestId, {
      resolve,
      reject,
      timeout,
      createdAt: new Date()
    });
    
    // Send request to bridge
    try {
      const sealMessage = {
        type: 'REQUEST_FISCAL_SEAL',
        requestId,
        payload: {
          price,
          timestamp: new Date().toISOString()
        }
      };
      console.log(`[Bridge] Sending seal request to bridge: ${JSON.stringify(sealMessage)}`);
      globalBridge!.ws.send(JSON.stringify(sealMessage));
      console.log(`[Bridge] Seal request sent successfully, waiting for response...`);
    } catch (sendError: any) {
      console.log(`[Bridge] ERROR sending seal request: ${sendError.message}`);
      clearTimeout(timeout);
      pendingSealRequests.delete(requestId);
      reject(new Error('SEAL_SEND_ERROR: Errore invio richiesta sigillo'));
    }
  });
}

// Handle seal response from bridge (called when bridge sends SEAL_RESPONSE)
export function handleSealResponse(requestId: string, success: boolean, seal?: any, error?: string): void {
  const pending = pendingSealRequests.get(requestId);
  if (!pending) {
    console.log(`[Bridge] No pending request for seal response: requestId=${requestId}`);
    return;
  }
  
  clearTimeout(pending.timeout);
  pendingSealRequests.delete(requestId);
  
  if (success && seal) {
    console.log(`[Bridge] Seal request completed: requestId=${requestId}, counter=${seal.counter}`);
    
    // Get serialNumber from seal response, with fallback to cached cardSerial
    // The C# bridge may return "0000000000000000" instead of actual serial
    let serialNumber = seal.serialNumber;
    const isInvalidSerial = !serialNumber || serialNumber === '0000000000000000' || serialNumber.match(/^0+$/);
    
    if (isInvalidSerial) {
      // Try to get cardSerial from cached bridge status
      const status = cachedBridgeStatus?.data?.payload || 
                     cachedBridgeStatus?.payload?.data ||
                     cachedBridgeStatus?.data || 
                     cachedBridgeStatus?.payload || 
                     cachedBridgeStatus;
      const cachedSerial = status?.cardSerial;
      
      if (cachedSerial && cachedSerial !== '0000000000000000') {
        console.log(`[Bridge] Using cached cardSerial as fallback: ${cachedSerial} (original was: ${serialNumber})`);
        serialNumber = cachedSerial;
      } else {
        console.log(`[Bridge] WARNING: Invalid serialNumber and no valid cached cardSerial available`);
      }
    }
    
    pending.resolve({
      sealCode: seal.sealCode || seal.mac,
      sealNumber: seal.sealNumber || `${serialNumber}-${seal.counter}`,
      serialNumber: serialNumber,
      counter: seal.counter,
      mac: seal.mac,
      dateTime: seal.dateTime
    });
  } else {
    console.log(`[Bridge] Seal request failed: requestId=${requestId}, error=${error}`);
    pending.reject(new Error(`SEAL_ERROR: ${error || 'Errore generazione sigillo'}`));
  }
}

// Get pending seal requests count (for monitoring)
export function getPendingSealRequestsCount(): number {
  return pendingSealRequests.size;
}

// ==================== XML SIGNATURE BROKER ====================
// Error codes for smart card / digital signature operations
// These are used for structured error handling and user-friendly messages
export enum SignatureErrorCode {
  // Bridge connection errors
  BRIDGE_OFFLINE = 'SIGNATURE_BRIDGE_OFFLINE',
  BRIDGE_SEND_ERROR = 'SIGNATURE_SEND_ERROR',
  BRIDGE_TIMEOUT = 'SIGNATURE_TIMEOUT',
  
  // Smart card errors
  CARD_NOT_READY = 'SIGNATURE_CARD_NOT_READY',
  CARD_NOT_FOUND = 'SIGNATURE_CARD_NOT_FOUND',
  CARD_DISCONNECTED = 'SIGNATURE_CARD_DISCONNECTED',
  CARD_READER_ERROR = 'SIGNATURE_CARD_READER_ERROR',
  
  // PIN errors
  PIN_REQUIRED = 'SIGNATURE_PIN_REQUIRED',
  PIN_INCORRECT = 'SIGNATURE_PIN_INCORRECT',
  PIN_LOCKED = 'SIGNATURE_PIN_LOCKED',
  PIN_CANCELLED = 'SIGNATURE_PIN_CANCELLED',
  
  // Certificate errors
  CERT_EXPIRED = 'SIGNATURE_CERT_EXPIRED',
  CERT_NOT_FOUND = 'SIGNATURE_CERT_NOT_FOUND',
  CERT_INVALID = 'SIGNATURE_CERT_INVALID',
  CERT_REVOKED = 'SIGNATURE_CERT_REVOKED',
  
  // Signature errors
  SIGNATURE_FAILED = 'SIGNATURE_FAILED',
  SIGNATURE_CANCELLED = 'SIGNATURE_CANCELLED',
  
  // Generic error
  UNKNOWN_ERROR = 'SIGNATURE_UNKNOWN_ERROR'
}

// Map bridge error messages to structured error codes
export function parseSignatureError(errorMessage: string): { code: SignatureErrorCode; message: string } {
  const errorLower = errorMessage.toLowerCase();
  
  // PIN errors
  if (errorLower.includes('pin') && (errorLower.includes('wrong') || errorLower.includes('incorrect') || errorLower.includes('errato'))) {
    return { code: SignatureErrorCode.PIN_INCORRECT, message: 'PIN errato. Verificare il PIN e riprovare.' };
  }
  if (errorLower.includes('pin') && (errorLower.includes('locked') || errorLower.includes('bloccato'))) {
    return { code: SignatureErrorCode.PIN_LOCKED, message: 'PIN bloccato. Contattare SIAE per sbloccare la carta.' };
  }
  if (errorLower.includes('pin') && (errorLower.includes('cancel') || errorLower.includes('annull'))) {
    return { code: SignatureErrorCode.PIN_CANCELLED, message: 'Inserimento PIN annullato dall\'utente.' };
  }
  if (errorLower.includes('pin') && errorLower.includes('requir')) {
    return { code: SignatureErrorCode.PIN_REQUIRED, message: 'Inserimento PIN richiesto per la firma.' };
  }
  
  // Card errors
  if (errorLower.includes('card') && (errorLower.includes('not found') || errorLower.includes('non trovata'))) {
    return { code: SignatureErrorCode.CARD_NOT_FOUND, message: 'Carta SIAE non trovata. Inserire la carta nel lettore.' };
  }
  if (errorLower.includes('card') && (errorLower.includes('disconnect') || errorLower.includes('removed') || errorLower.includes('rimossa'))) {
    return { code: SignatureErrorCode.CARD_DISCONNECTED, message: 'Carta SIAE scollegata durante l\'operazione. Reinserire la carta.' };
  }
  if (errorLower.includes('reader') || errorLower.includes('lettore')) {
    return { code: SignatureErrorCode.CARD_READER_ERROR, message: 'Errore lettore smart card. Verificare la connessione.' };
  }
  
  // Certificate errors
  if (errorLower.includes('certificate') && (errorLower.includes('expired') || errorLower.includes('scadut'))) {
    return { code: SignatureErrorCode.CERT_EXPIRED, message: 'Certificato SIAE scaduto. Richiedere nuova carta di attivazione.' };
  }
  if (errorLower.includes('certificate') && (errorLower.includes('not found') || errorLower.includes('non trovato'))) {
    return { code: SignatureErrorCode.CERT_NOT_FOUND, message: 'Certificato non trovato sulla carta SIAE.' };
  }
  if (errorLower.includes('certificate') && (errorLower.includes('invalid') || errorLower.includes('non valido'))) {
    return { code: SignatureErrorCode.CERT_INVALID, message: 'Certificato SIAE non valido.' };
  }
  if (errorLower.includes('certificate') && (errorLower.includes('revoked') || errorLower.includes('revocato'))) {
    return { code: SignatureErrorCode.CERT_REVOKED, message: 'Certificato SIAE revocato. Contattare SIAE.' };
  }
  
  // Signature specific
  if (errorLower.includes('cancel') || errorLower.includes('annull')) {
    return { code: SignatureErrorCode.SIGNATURE_CANCELLED, message: 'Operazione di firma annullata.' };
  }
  if (errorLower.includes('fail') || errorLower.includes('error') || errorLower.includes('errore')) {
    return { code: SignatureErrorCode.SIGNATURE_FAILED, message: 'Firma digitale fallita. Riprovare.' };
  }
  
  // Default
  return { code: SignatureErrorCode.UNKNOWN_ERROR, message: errorMessage || 'Errore sconosciuto durante la firma.' };
}

// Signature audit log entry type
export interface SignatureAuditEntry {
  requestId: string;
  operation: 'xml_signature' | 'smime_signature';
  status: 'requested' | 'completed' | 'failed' | 'timeout';
  errorCode?: SignatureErrorCode;
  errorMessage?: string;
  xmlLength?: number;
  certificateSerial?: string;
  signerEmail?: string;
  requestedAt: Date;
  completedAt?: Date;
  durationMs?: number;
}

// In-memory audit log (last 100 entries) - for debugging and monitoring
const signatureAuditLog: SignatureAuditEntry[] = [];
const MAX_AUDIT_LOG_ENTRIES = 100;

function addSignatureAuditEntry(entry: SignatureAuditEntry): void {
  signatureAuditLog.unshift(entry);
  if (signatureAuditLog.length > MAX_AUDIT_LOG_ENTRIES) {
    signatureAuditLog.pop();
  }
  console.log(`[Bridge-Audit] ${entry.operation}: ${entry.status} - requestId=${entry.requestId}${entry.errorCode ? ` error=${entry.errorCode}` : ''}`);
}

export function getSignatureAuditLog(): SignatureAuditEntry[] {
  return [...signatureAuditLog];
}

// Pending XML signature requests waiting for response from desktop bridge
interface PendingSignatureRequest {
  resolve: (signedXml: XmlSignatureData) => void;
  reject: (error: Error) => void;
  timeout: NodeJS.Timeout;
  createdAt: Date;
  auditEntry: SignatureAuditEntry;
}

export interface XmlSignatureData {
  // CAdES-BES format (nuovo - conforme SIAE)
  p7mBase64?: string;           // File P7M firmato in Base64 (CAdES-BES)
  format?: string;              // "CAdES-BES" per firma conforme
  algorithm?: string;           // "SHA-256" per hash conforme
  xmlContent?: string;          // XML originale (per riferimento)
  
  // Legacy XMLDSig format (obsoleto - mantenuto per retrocompatibilità)
  signedXml?: string;           // XML con firma interna (XMLDSig)
  signatureValue?: string;
  certificateData?: string;
  signedAt: string;
}

const pendingSignatureRequests = new Map<string, PendingSignatureRequest>();

const SIGNATURE_REQUEST_TIMEOUT = 30000; // 30 seconds for XML signature

// Generate UUID for signature request tracking
function generateSignatureRequestId(): string {
  return `sig_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// Request XML digital signature from the desktop bridge (SIAE smart card)
export async function requestXmlSignature(xmlContent: string): Promise<XmlSignatureData> {
  console.log(`[Bridge] requestXmlSignature called, XML length=${xmlContent.length}`);
  
  const requestId = generateSignatureRequestId();
  const requestedAt = new Date();
  
  // Create audit entry
  const auditEntry: SignatureAuditEntry = {
    requestId,
    operation: 'xml_signature',
    status: 'requested',
    xmlLength: xmlContent.length,
    requestedAt
  };
  
  // Check if bridge is connected
  if (!globalBridge || globalBridge.ws.readyState !== WebSocket.OPEN) {
    console.log(`[Bridge] ERROR: Bridge not connected for XML signature`);
    auditEntry.status = 'failed';
    auditEntry.errorCode = SignatureErrorCode.BRIDGE_OFFLINE;
    auditEntry.errorMessage = 'App desktop Event4U non connessa';
    auditEntry.completedAt = new Date();
    auditEntry.durationMs = auditEntry.completedAt.getTime() - requestedAt.getTime();
    addSignatureAuditEntry(auditEntry);
    throw new Error(`${SignatureErrorCode.BRIDGE_OFFLINE}: App desktop Event4U non connessa. Impossibile firmare XML.`);
  }
  
  // Check if card is ready
  const cardReady = isCardReadyForSeals();
  console.log(`[Bridge] Card ready check for signature: ${JSON.stringify(cardReady)}`);
  if (!cardReady.ready) {
    auditEntry.status = 'failed';
    auditEntry.errorCode = SignatureErrorCode.CARD_NOT_READY;
    auditEntry.errorMessage = cardReady.error ?? undefined;
    auditEntry.completedAt = new Date();
    auditEntry.durationMs = auditEntry.completedAt.getTime() - requestedAt.getTime();
    addSignatureAuditEntry(auditEntry);
    throw new Error(`${SignatureErrorCode.CARD_NOT_READY}: ${cardReady.error}`);
  }
  
  console.log(`[Bridge] Requesting XML signature: requestId=${requestId}`);
  addSignatureAuditEntry(auditEntry);
  
  return new Promise<XmlSignatureData>((resolve, reject) => {
    // Set timeout
    const timeout = setTimeout(() => {
      const pending = pendingSignatureRequests.get(requestId);
      if (pending) {
        pending.auditEntry.status = 'timeout';
        pending.auditEntry.errorCode = SignatureErrorCode.BRIDGE_TIMEOUT;
        pending.auditEntry.errorMessage = 'Timeout firma digitale XML';
        pending.auditEntry.completedAt = new Date();
        pending.auditEntry.durationMs = pending.auditEntry.completedAt.getTime() - pending.auditEntry.requestedAt.getTime();
        addSignatureAuditEntry(pending.auditEntry);
      }
      pendingSignatureRequests.delete(requestId);
      console.log(`[Bridge] XML signature request timeout: requestId=${requestId}`);
      reject(new Error(`${SignatureErrorCode.BRIDGE_TIMEOUT}: Timeout firma digitale XML. Riprovare.`));
    }, SIGNATURE_REQUEST_TIMEOUT);
    
    // Store pending request with audit entry
    pendingSignatureRequests.set(requestId, {
      resolve,
      reject,
      timeout,
      createdAt: requestedAt,
      auditEntry: { ...auditEntry }
    });
    
    // Send request to bridge
    try {
      const signatureMessage = {
        type: 'REQUEST_XML_SIGNATURE',
        requestId,
        payload: {
          xmlContent,
          timestamp: new Date().toISOString()
        }
      };
      console.log(`[Bridge] Sending XML signature request to bridge: requestId=${requestId}`);
      globalBridge!.ws.send(JSON.stringify(signatureMessage));
      console.log(`[Bridge] XML signature request sent successfully, waiting for response...`);
    } catch (sendError: any) {
      console.log(`[Bridge] ERROR sending XML signature request: ${sendError.message}`);
      const pending = pendingSignatureRequests.get(requestId);
      if (pending) {
        pending.auditEntry.status = 'failed';
        pending.auditEntry.errorCode = SignatureErrorCode.BRIDGE_SEND_ERROR;
        pending.auditEntry.errorMessage = sendError.message;
        pending.auditEntry.completedAt = new Date();
        pending.auditEntry.durationMs = pending.auditEntry.completedAt.getTime() - pending.auditEntry.requestedAt.getTime();
        addSignatureAuditEntry(pending.auditEntry);
      }
      clearTimeout(timeout);
      pendingSignatureRequests.delete(requestId);
      reject(new Error(`${SignatureErrorCode.BRIDGE_SEND_ERROR}: Errore invio richiesta firma`));
    }
  });
}

// Handle signature response from bridge (called when bridge sends SIGNATURE_RESPONSE)
export function handleSignatureResponse(requestId: string, success: boolean, signatureData?: any, error?: string): void {
  const pending = pendingSignatureRequests.get(requestId);
  if (!pending) {
    console.log(`[Bridge] No pending request for signature response: requestId=${requestId}`);
    return;
  }
  
  clearTimeout(pending.timeout);
  pendingSignatureRequests.delete(requestId);
  
  const completedAt = new Date();
  const durationMs = completedAt.getTime() - pending.createdAt.getTime();
  
  if (success && signatureData) {
    // Determina il formato della firma (CAdES-BES o legacy XMLDSig)
    const isCAdES = !!signatureData.p7mBase64;
    console.log(`[Bridge] XML signature request completed: requestId=${requestId}, format=${isCAdES ? 'CAdES-BES' : 'XMLDSig'}, duration=${durationMs}ms`);
    
    // INTEGRITY CHECK: Calcola SHA-256 del P7M ricevuto per diagnostica trasmissione
    if (isCAdES && signatureData.p7mBase64) {
      try {
        const p7mBuffer = Buffer.from(signatureData.p7mBase64, 'base64');
        const sha256Hash = createHash('sha256').update(p7mBuffer).digest('hex');
        console.log(`[Bridge] [INTEGRITY] P7M received from desktop:`);
        console.log(`[Bridge] [INTEGRITY]   - Size: ${p7mBuffer.length} bytes`);
        console.log(`[Bridge] [INTEGRITY]   - Base64 length: ${signatureData.p7mBase64.length} chars`);
        console.log(`[Bridge] [INTEGRITY]   - SHA-256: ${sha256Hash}`);
        
        // Verifica struttura base del P7M (PKCS#7 / CMS SignedData)
        // Il P7M deve iniziare con SEQUENCE (0x30) seguito da OID per signedData
        const firstByte = p7mBuffer[0];
        const isValidAsn1 = firstByte === 0x30; // SEQUENCE tag in DER/BER
        console.log(`[Bridge] [INTEGRITY]   - Valid ASN.1 SEQUENCE: ${isValidAsn1}`);
        
        // Check for SignedData OID (1.2.840.113549.1.7.2) at expected position
        const signedDataOid = Buffer.from([0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02]);
        const hasSignedDataOid = p7mBuffer.includes(signedDataOid);
        console.log(`[Bridge] [INTEGRITY]   - Contains signedData OID: ${hasSignedDataOid}`);
        
        if (!isValidAsn1 || !hasSignedDataOid) {
          console.log(`[Bridge] [INTEGRITY] WARNING: P7M structure may be invalid!`);
        }
      } catch (hashError: any) {
        console.log(`[Bridge] [INTEGRITY] Failed to compute SHA-256: ${hashError.message}`);
      }
    }
    
    // Update audit entry for success
    pending.auditEntry.status = 'completed';
    pending.auditEntry.completedAt = completedAt;
    pending.auditEntry.durationMs = durationMs;
    pending.auditEntry.certificateSerial = signatureData.certificateSerial;
    addSignatureAuditEntry(pending.auditEntry);
    
    // Supporta sia CAdES-BES (nuovo) che XMLDSig (legacy)
    pending.resolve({
      // CAdES-BES fields (nuovo formato conforme SIAE)
      p7mBase64: signatureData.p7mBase64,
      format: signatureData.format || (isCAdES ? 'CAdES-BES' : 'XMLDSig'),
      algorithm: signatureData.algorithm || (isCAdES ? 'SHA-256' : 'SHA-1'),
      xmlContent: signatureData.xmlContent,
      
      // Legacy XMLDSig fields (per retrocompatibilità)
      signedXml: signatureData.signedXml,
      signatureValue: signatureData.signatureValue || '',
      certificateData: signatureData.certificateData || '',
      signedAt: signatureData.signedAt || new Date().toISOString()
    });
  } else {
    // Parse the error for structured handling
    const parsedError = parseSignatureError(error || 'Errore firma digitale XML');
    console.log(`[Bridge] XML signature request failed: requestId=${requestId}, code=${parsedError.code}, error=${parsedError.message}`);
    
    // Update audit entry for failure
    pending.auditEntry.status = 'failed';
    pending.auditEntry.errorCode = parsedError.code;
    pending.auditEntry.errorMessage = parsedError.message;
    pending.auditEntry.completedAt = completedAt;
    pending.auditEntry.durationMs = durationMs;
    addSignatureAuditEntry(pending.auditEntry);
    
    pending.reject(new Error(`${parsedError.code}: ${parsedError.message}`));
  }
}

// Get pending signature requests count (for monitoring)
export function getPendingSignatureRequestsCount(): number {
  return pendingSignatureRequests.size;
}

// ==================== S/MIME EMAIL SIGNATURE BROKER ====================
// Per Allegato C SIAE - Provvedimento Agenzia Entrate 04/03/2008, sezione 1.6.2
// L'email deve essere firmata S/MIME versione 2 con la carta di attivazione SIAE
// Il mittente dell'email DEVE corrispondere all'email nel certificato della carta

export interface SmimeSignatureData {
  signedMime: string;           // Complete S/MIME signed message ready to send
  signerEmail: string;          // Email address from the signing certificate
  signerName: string;           // Common Name from the signing certificate  
  certificateSerial: string;    // Serial number of the signing certificate
  signedAt: string;             // ISO timestamp of when signature was created
  generator?: string;           // Generator type (e.g., 'SMIMESignML-native')
}

interface PendingSmimeRequest {
  resolve: (data: SmimeSignatureData) => void;
  reject: (error: Error) => void;
  timeout: NodeJS.Timeout;
  createdAt: Date;
  auditEntry: SignatureAuditEntry;
}

const pendingSmimeRequests = new Map<string, PendingSmimeRequest>();
const SMIME_REQUEST_TIMEOUT = 60000; // 60 seconds for S/MIME signature (larger emails)

function generateSmimeRequestId(): string {
  return `smime_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Parametri per S/MIME firmato con SMIMESignML
 */
interface SmimeSignatureParams {
  from: string;           // Email mittente (deve corrispondere al certificato)
  to: string;             // Email destinatario
  subject: string;        // Oggetto email
  body: string;           // Corpo email (text/html ASCII-7bit)
  attachmentBase64?: string; // Allegato in base64 (opzionale)
  attachmentName?: string;   // Nome file allegato (opzionale)
}

/**
 * Request S/MIME signature from the desktop bridge (SIAE smart card)
 * Uses SMIMESignML API from libSIAEp7.dll for proper RFC822 S/MIME creation.
 * 
 * @param params - S/MIME parameters (from, to, subject, body, attachment)
 * @param recipientEmail - Email address of the recipient (for logging/validation)
 * @returns Promise resolving to signed MIME message and certificate info
 * 
 * Per SIAE Allegato C 1.6.1:
 * - a.1. Il mittente deve essere titolare con carta di attivazione
 * - a.2. L'email deve essere firmata mediante la carta di attivazione
 * - a.3. L'indirizzo email del mittente deve corrispondere a quello nel certificato
 */
export async function requestSmimeSignature(
  params: SmimeSignatureParams | string, 
  recipientEmail: string
): Promise<SmimeSignatureData> {
  // Validazione strutturale rigorosa per il nuovo formato SMIMESignML
  const isNewFormat = typeof params === 'object' && params !== null &&
    typeof (params as SmimeSignatureParams).from === 'string' &&
    typeof (params as SmimeSignatureParams).to === 'string' &&
    typeof (params as SmimeSignatureParams).subject === 'string' &&
    (params as SmimeSignatureParams).from.length > 0 &&
    (params as SmimeSignatureParams).to.length > 0;
  
  // Se è un oggetto ma non ha i campi richiesti, rifiuta subito
  if (typeof params === 'object' && params !== null && !isNewFormat) {
    const p = params as any;
    console.error(`[Bridge] Invalid SMIMESignML params: from=${typeof p.from}, to=${typeof p.to}, subject=${typeof p.subject}`);
    throw new Error('SMIME_INVALID_PARAMS: Parametri SMIMESignML non validi. Richiesti: from, to, subject (stringhe non vuote)');
  }
  
  const mimeContent = isNewFormat ? '' : (params as string);
  
  console.log(`[Bridge] requestSmimeSignature called, format=${isNewFormat ? 'SMIMESignML' : 'legacy'}, recipient=${recipientEmail}`);
  
  const requestId = generateSmimeRequestId();
  const requestedAt = new Date();
  
  // Create audit entry for S/MIME signature
  const auditEntry: SignatureAuditEntry = {
    requestId,
    operation: 'smime_signature',
    status: 'requested',
    xmlLength: mimeContent.length,
    requestedAt
  };
  
  // Check if bridge is connected
  if (!globalBridge || globalBridge.ws.readyState !== WebSocket.OPEN) {
    console.log(`[Bridge] ERROR: Bridge not connected for S/MIME signature`);
    auditEntry.status = 'failed';
    auditEntry.errorCode = SignatureErrorCode.BRIDGE_OFFLINE;
    auditEntry.errorMessage = 'App desktop Event4U non connessa';
    auditEntry.completedAt = new Date();
    auditEntry.durationMs = auditEntry.completedAt.getTime() - requestedAt.getTime();
    addSignatureAuditEntry(auditEntry);
    throw new Error(`${SignatureErrorCode.BRIDGE_OFFLINE}: App desktop Event4U non connessa. Impossibile firmare email S/MIME.`);
  }
  
  // Check if card is ready
  const cardReady = isCardReadyForSeals();
  console.log(`[Bridge] Card ready check for S/MIME: ${JSON.stringify(cardReady)}`);
  if (!cardReady.ready) {
    auditEntry.status = 'failed';
    auditEntry.errorCode = SignatureErrorCode.CARD_NOT_READY;
    auditEntry.errorMessage = cardReady.error ?? undefined;
    auditEntry.completedAt = new Date();
    auditEntry.durationMs = auditEntry.completedAt.getTime() - requestedAt.getTime();
    addSignatureAuditEntry(auditEntry);
    throw new Error(`${SignatureErrorCode.CARD_NOT_READY}: ${cardReady.error}`);
  }
  
  console.log(`[Bridge] Requesting S/MIME signature: requestId=${requestId}`);
  addSignatureAuditEntry(auditEntry);
  
  return new Promise<SmimeSignatureData>((resolve, reject) => {
    // Set timeout
    const timeout = setTimeout(() => {
      const pending = pendingSmimeRequests.get(requestId);
      if (pending) {
        pending.auditEntry.status = 'timeout';
        pending.auditEntry.errorCode = SignatureErrorCode.BRIDGE_TIMEOUT;
        pending.auditEntry.errorMessage = 'Timeout firma S/MIME email';
        pending.auditEntry.completedAt = new Date();
        pending.auditEntry.durationMs = pending.auditEntry.completedAt.getTime() - pending.auditEntry.requestedAt.getTime();
        addSignatureAuditEntry(pending.auditEntry);
      }
      pendingSmimeRequests.delete(requestId);
      console.log(`[Bridge] S/MIME signature request timeout: requestId=${requestId}`);
      reject(new Error(`${SignatureErrorCode.BRIDGE_TIMEOUT}: Timeout firma S/MIME email. Riprovare.`));
    }, SMIME_REQUEST_TIMEOUT);
    
    // Store pending request with audit entry
    pendingSmimeRequests.set(requestId, {
      resolve,
      reject,
      timeout,
      createdAt: requestedAt,
      auditEntry: { ...auditEntry }
    });
    
    // Send request to bridge
    try {
      let smimePayload: any;
      
      if (isNewFormat) {
        // Nuovo formato: SMIMESignML con parametri separati
        const p = params as SmimeSignatureParams;
        smimePayload = {
          from: p.from,
          to: p.to,
          subject: p.subject,
          body: p.body,
          attachmentBase64: p.attachmentBase64 || '',
          attachmentName: p.attachmentName || '',
          recipientEmail,
          timestamp: new Date().toISOString()
        };
        console.log(`[Bridge] Using SMIMESignML format: from=${p.from}, to=${p.to}, subject=${p.subject?.substring(0, 50)}...`);
        console.log(`[Bridge] SIAE FILE NAME SENT TO BRIDGE: "${p.attachmentName}" (${p.attachmentName?.length || 0} chars)`);
      } else {
        // Vecchio formato: mimeContent (legacy, deprecato)
        smimePayload = {
          mimeContent,
          recipientEmail,
          timestamp: new Date().toISOString()
        };
        console.log(`[Bridge] WARNING: Using legacy mimeContent format - may cause SIAE errors`);
      }
      
      const smimeMessage = {
        type: 'REQUEST_SMIME_SIGNATURE',
        requestId,
        payload: smimePayload
      };
      console.log(`[Bridge] Sending S/MIME signature request to bridge: requestId=${requestId}`);
      globalBridge!.ws.send(JSON.stringify(smimeMessage));
      console.log(`[Bridge] S/MIME signature request sent successfully, waiting for response...`);
    } catch (sendError: any) {
      console.log(`[Bridge] ERROR sending S/MIME signature request: ${sendError.message}`);
      const pending = pendingSmimeRequests.get(requestId);
      if (pending) {
        pending.auditEntry.status = 'failed';
        pending.auditEntry.errorCode = SignatureErrorCode.BRIDGE_SEND_ERROR;
        pending.auditEntry.errorMessage = sendError.message;
        pending.auditEntry.completedAt = new Date();
        pending.auditEntry.durationMs = pending.auditEntry.completedAt.getTime() - pending.auditEntry.requestedAt.getTime();
        addSignatureAuditEntry(pending.auditEntry);
      }
      clearTimeout(timeout);
      pendingSmimeRequests.delete(requestId);
      reject(new Error(`${SignatureErrorCode.BRIDGE_SEND_ERROR}: Errore invio richiesta firma S/MIME`));
    }
  });
}

// Handle S/MIME signature response from bridge
export function handleSmimeSignatureResponse(
  requestId: string, 
  success: boolean, 
  signatureData?: any, 
  error?: string
): void {
  const pending = pendingSmimeRequests.get(requestId);
  if (!pending) {
    console.log(`[Bridge] No pending request for S/MIME signature response: requestId=${requestId}`);
    return;
  }
  
  clearTimeout(pending.timeout);
  pendingSmimeRequests.delete(requestId);
  
  const completedAt = new Date();
  const durationMs = completedAt.getTime() - pending.createdAt.getTime();
  
  if (success && signatureData) {
    console.log(`[Bridge] S/MIME signature request completed: requestId=${requestId}, signerEmail=${signatureData.signerEmail}, duration=${durationMs}ms`);
    
    // Update audit entry for success
    pending.auditEntry.status = 'completed';
    pending.auditEntry.completedAt = completedAt;
    pending.auditEntry.durationMs = durationMs;
    pending.auditEntry.signerEmail = signatureData.signerEmail;
    pending.auditEntry.certificateSerial = signatureData.certificateSerial;
    addSignatureAuditEntry(pending.auditEntry);
    
    pending.resolve({
      signedMime: signatureData.signedMime,
      signerEmail: signatureData.signerEmail || '',
      signerName: signatureData.signerName || '',
      certificateSerial: signatureData.certificateSerial || '',
      signedAt: signatureData.signedAt || new Date().toISOString(),
      generator: signatureData.generator  // 'SMIMESignML-native' se generato da libreria SIAE
    });
  } else {
    // Parse the error for structured handling
    const parsedError = parseSignatureError(error || 'Errore firma S/MIME email');
    console.log(`[Bridge] S/MIME signature request failed: requestId=${requestId}, code=${parsedError.code}, error=${parsedError.message}`);
    
    // Update audit entry for failure
    pending.auditEntry.status = 'failed';
    pending.auditEntry.errorCode = parsedError.code;
    pending.auditEntry.errorMessage = parsedError.message;
    pending.auditEntry.completedAt = completedAt;
    pending.auditEntry.durationMs = durationMs;
    addSignatureAuditEntry(pending.auditEntry);
    
    pending.reject(new Error(`${parsedError.code}: ${parsedError.message}`));
  }
}

// Get pending S/MIME requests count (for monitoring)
export function getPendingSmimeRequestsCount(): number {
  return pendingSmimeRequests.size;
}

/**
 * Get the signer email from the activation card certificate (cached from bridge status)
 * Returns null if bridge is not connected or card not ready
 * 
 * NOTA: Il bridge desktop può inviare i dati in diversi formati:
 * - { type: 'status', data: { cardEmail: '...' } }
 * - { type: 'status', payload: { cardEmail: '...' } }
 * - { data: { payload: { cardEmail: '...' } } }
 */
export function getCardSignerEmail(): string | null {
  if (!cachedBridgeStatus) return null;
  
  // Cerca l'email del certificato in tutte le possibili posizioni
  // Il bridge desktop può inviare dati in formati diversi
  const sources = [
    cachedBridgeStatus.data?.payload,
    cachedBridgeStatus.payload?.data,
    cachedBridgeStatus.data,
    cachedBridgeStatus.payload,
    cachedBridgeStatus
  ];
  
  for (const source of sources) {
    if (source) {
      const email = source.cardEmail || source.certificateEmail || source.signerEmail || source.email;
      if (email && typeof email === 'string' && email.includes('@')) {
        console.log(`[Bridge] Found card signer email: ${email}`);
        return email;
      }
    }
  }
  
  console.log(`[Bridge] Card signer email not found in cachedBridgeStatus: ${JSON.stringify(cachedBridgeStatus)}`);
  return null;
}

// ==================== EFFF Card Data Request ====================
// Lettura file EFFF dalla Smart Card SIAE
// Conforme a Descrizione_contenuto_SmartCardTestxBA-V102.pdf

interface PendingEfffRequest {
  resolve: (data: SiaeCardEfffData) => void;
  reject: (error: Error) => void;
  timeout: NodeJS.Timeout;
  createdAt: Date;
}

const pendingEfffRequests = new Map<string, PendingEfffRequest>();
const EFFF_REQUEST_TIMEOUT = 10000; // 10 seconds

function generateEfffRequestId(): string {
  return `efff_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Richiede la lettura del file EFFF dalla Smart Card tramite Desktop Bridge
 * Il file EFFF contiene 15 campi anagrafici incluso l'indirizzo email SIAE
 */
export async function requestCardEfffData(): Promise<SiaeCardEfffData> {
  console.log(`[Bridge] requestCardEfffData called`);
  
  // Check if bridge is connected
  if (!globalBridge || globalBridge.ws.readyState !== WebSocket.OPEN) {
    console.log(`[Bridge] ERROR: Bridge not connected for EFFF read`);
    throw new Error('EFFF_BRIDGE_OFFLINE: App desktop Event4U non connessa. Impossibile leggere dati Smart Card.');
  }
  
  // Check if card is ready
  const cardReady = isCardReadyForSeals();
  console.log(`[Bridge] Card ready check for EFFF: ${JSON.stringify(cardReady)}`);
  if (!cardReady.ready) {
    throw new Error(`EFFF_CARD_NOT_READY: ${cardReady.error}`);
  }
  
  const requestId = generateEfffRequestId();
  
  console.log(`[Bridge] Requesting EFFF data: requestId=${requestId}`);
  
  return new Promise<SiaeCardEfffData>((resolve, reject) => {
    const timeout = setTimeout(() => {
      pendingEfffRequests.delete(requestId);
      console.log(`[Bridge] EFFF request timeout: requestId=${requestId}`);
      reject(new Error('EFFF_TIMEOUT: Timeout lettura dati Smart Card. Riprovare.'));
    }, EFFF_REQUEST_TIMEOUT);
    
    pendingEfffRequests.set(requestId, {
      resolve,
      reject,
      timeout,
      createdAt: new Date()
    });
    
    try {
      globalBridge!.ws.send(JSON.stringify({
        type: 'READ_EFFF',
        requestId
      }));
      console.log(`[Bridge] EFFF request sent to bridge: requestId=${requestId}`);
    } catch (sendError: any) {
      clearTimeout(timeout);
      pendingEfffRequests.delete(requestId);
      reject(new Error(`EFFF_SEND_ERROR: Errore invio richiesta lettura EFFF: ${sendError.message}`));
    }
  });
}

/**
 * Gestisce la risposta EFFF dal Desktop Bridge
 */
export function handleEfffResponse(
  requestId: string,
  success: boolean,
  efffData?: Partial<SiaeCardEfffData>,
  error?: string
): void {
  const pending = pendingEfffRequests.get(requestId);
  if (!pending) {
    console.log(`[Bridge] No pending request for EFFF response: requestId=${requestId}`);
    return;
  }
  
  clearTimeout(pending.timeout);
  pendingEfffRequests.delete(requestId);
  
  const durationMs = Date.now() - pending.createdAt.getTime();
  
  if (success && efffData) {
    console.log(`[Bridge] EFFF read completed: requestId=${requestId}, systemId=${efffData.systemId}, duration=${durationMs}ms`);
    
    // Costruisci oggetto EFFF completo con valori default
    const fullEfffData: SiaeCardEfffData = {
      systemId: efffData.systemId || '',
      contactName: efffData.contactName || '',
      contactLastName: efffData.contactLastName || '',
      contactCodFis: efffData.contactCodFis || '',
      systemLocation: efffData.systemLocation || '',
      contactEmail: efffData.contactEmail || '',
      siaeEmail: efffData.siaeEmail || '',
      partnerName: efffData.partnerName || '',
      partnerCodFis: efffData.partnerCodFis || '',
      partnerRegistroImprese: efffData.partnerRegistroImprese || '',
      partnerNation: efffData.partnerNation || 'IT',
      systemApprCode: efffData.systemApprCode || '',
      systemApprDate: efffData.systemApprDate || '',
      contactRepresentationType: efffData.contactRepresentationType || 'I',
      userDataFileVersion: efffData.userDataFileVersion || '1.0.0'
    };
    
    pending.resolve(fullEfffData);
  } else {
    console.log(`[Bridge] EFFF read failed: requestId=${requestId}, error=${error}`);
    pending.reject(new Error(`EFFF_READ_ERROR: ${error || 'Errore lettura file EFFF dalla Smart Card'}`));
  }
}

/**
 * Restituisce i dati EFFF dalla cache del bridge status (se disponibili)
 * Più veloce di requestCardEfffData ma potrebbe essere stale
 */
export function getCachedEfffData(): Partial<SiaeCardEfffData> | null {
  if (!cachedBridgeStatus?.payload) return null;
  
  const payload = cachedBridgeStatus.payload;
  
  // Il Desktop Bridge può esporre i dati EFFF nel payload di status
  if (payload.efffData) {
    return payload.efffData;
  }
  
  // Fallback: costruisci da campi singoli se disponibili
  if (payload.systemId || payload.partnerName) {
    return {
      systemId: payload.systemId,
      partnerName: payload.partnerName,
      partnerCodFis: payload.partnerCodFis || payload.taxId,
      siaeEmail: payload.siaeEmail,
      contactEmail: payload.contactEmail || payload.cardEmail
    };
  }
  
  return null;
}

/**
 * Verifica se la Smart Card è di TEST analizzando il systemId
 */
export function isTestCardFromCache(): boolean | null {
  const efff = getCachedEfffData();
  if (!efff?.systemId) return null;
  return efff.systemId.toUpperCase().startsWith('P');
}

/**
 * Ottiene l'email SIAE dalla Smart Card (da cache o richiesta diretta)
 */
export async function getSiaeEmailFromCard(): Promise<string | null> {
  // Prima prova dalla cache
  const cached = getCachedEfffData();
  if (cached?.siaeEmail) {
    return cached.siaeEmail;
  }
  
  // Se non in cache, prova a leggere dalla carta
  try {
    const efff = await requestCardEfffData();
    return efff.siaeEmail || null;
  } catch (error) {
    console.log(`[Bridge] Failed to get SIAE email from card: ${error}`);
    return null;
  }
}


================================================================================
FILE: server/email-service.ts
================================================================================
import nodemailer from 'nodemailer';
import { isBridgeConnected, requestSmimeSignature, getCardSignerEmail } from './bridge-relay';

/**
 * Formatta una stringa Base64 in righe da 76 caratteri per MIME (RFC 2045)
 * CRITICO: Senza questa formattazione, righe lunghissime possono essere
 * troncate/corrotte durante la trasmissione email, causando errore SIAE 40605
 */
function formatBase64ForMime(base64: string, lineLength: number = 76): string {
  const lines: string[] = [];
  for (let i = 0; i < base64.length; i += lineLength) {
    lines.push(base64.substring(i, i + lineLength));
  }
  return lines.join('\r\n');
}

// Transporter principale per email generiche (info@eventfouryou.com)
export const emailTransporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST || 'smtp.gmail.com',
  port: parseInt(process.env.SMTP_PORT || '587'),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

emailTransporter.verify((error, success) => {
  if (error) {
    console.error('[EMAIL-SERVICE] SMTP connection failed:', error.message);
  } else {
    console.log('[EMAIL-SERVICE] SMTP server connected successfully');
  }
});

// Transporter separato per email SIAE (tickefouryou@gmail.com - corrisponde al certificato smart card)
// Usato solo per trasmissioni SIAE che richiedono firma S/MIME
const siaeSmtpUser = process.env.SIAE_SMTP_USER || process.env.SMTP_USER;
const siaeSmtpPass = process.env.SIAE_SMTP_PASS || process.env.SMTP_PASS;

export const siaeEmailTransporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST || 'smtp.gmail.com',
  port: parseInt(process.env.SMTP_PORT || '587'),
  secure: false,
  auth: {
    user: siaeSmtpUser,
    pass: siaeSmtpPass,
  },
});

// Verifica connessione SIAE SMTP solo se configurato diversamente
if (process.env.SIAE_SMTP_USER && process.env.SIAE_SMTP_USER !== process.env.SMTP_USER) {
  siaeEmailTransporter.verify((error, success) => {
    if (error) {
      console.error('[EMAIL-SERVICE] SIAE SMTP connection failed:', error.message);
    } else {
      console.log(`[EMAIL-SERVICE] SIAE SMTP connected (${process.env.SIAE_SMTP_USER})`);
    }
  });
}

interface TicketEmailOptions {
  to: string;
  subject: string;
  eventName: string;
  tickets: Array<{ id: string; html: string }>;
  pdfBuffers: Buffer[];
}

export async function sendTicketEmail(options: TicketEmailOptions): Promise<void> {
  const { to, subject, eventName, tickets, pdfBuffers } = options;

  const htmlBody = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #0a0e17;
      color: #ffffff;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 40px 20px;
    }
    .header {
      text-align: center;
      margin-bottom: 40px;
    }
    .logo {
      font-size: 32px;
      font-weight: bold;
      color: #FFD700;
      margin-bottom: 10px;
    }
    .title {
      font-size: 24px;
      color: #ffffff;
      margin-bottom: 5px;
    }
    .subtitle {
      font-size: 16px;
      color: #94A3B8;
    }
    .card {
      background-color: #151922;
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 30px;
    }
    .event-name {
      font-size: 22px;
      font-weight: bold;
      color: #FFD700;
      margin-bottom: 15px;
    }
    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid #1e2533;
    }
    .info-row:last-child {
      border-bottom: none;
    }
    .info-label {
      color: #94A3B8;
      font-size: 14px;
    }
    .info-value {
      color: #ffffff;
      font-size: 14px;
      font-weight: 500;
    }
    .tickets-section {
      margin-top: 30px;
    }
    .tickets-title {
      font-size: 18px;
      color: #ffffff;
      margin-bottom: 15px;
    }
    .ticket-item {
      background-color: #1e2533;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .ticket-icon {
      width: 40px;
      height: 40px;
      background-color: #00CED1;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #0a0e17;
      font-weight: bold;
    }
    .ticket-info {
      flex: 1;
    }
    .ticket-id {
      font-size: 14px;
      color: #ffffff;
    }
    .ticket-status {
      font-size: 12px;
      color: #00CED1;
    }
    .footer {
      text-align: center;
      margin-top: 40px;
      padding-top: 30px;
      border-top: 1px solid #1e2533;
    }
    .footer-text {
      color: #94A3B8;
      font-size: 12px;
      margin-bottom: 10px;
    }
    .footer-link {
      color: #FFD700;
      text-decoration: none;
    }
    .cta-button {
      display: inline-block;
      background-color: #FFD700;
      color: #0a0e17;
      padding: 14px 32px;
      border-radius: 8px;
      text-decoration: none;
      font-weight: bold;
      font-size: 16px;
      margin-top: 20px;
    }
    .notice {
      background-color: rgba(0, 206, 209, 0.1);
      border: 1px solid #00CED1;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
    }
    .notice-text {
      color: #00CED1;
      font-size: 14px;
      margin: 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">Event4U</div>
      <div class="title">I tuoi biglietti sono pronti!</div>
      <div class="subtitle">Grazie per il tuo acquisto</div>
    </div>

    <div class="card">
      <div class="event-name">${eventName}</div>
      <div class="info-row">
        <span class="info-label">Numero biglietti</span>
        <span class="info-value">${tickets.length}</span>
      </div>
      <div class="info-row">
        <span class="info-label">Data acquisto</span>
        <span class="info-value">${new Date().toLocaleDateString('it-IT', { day: '2-digit', month: 'long', year: 'numeric' })}</span>
      </div>
    </div>

    <div class="tickets-section">
      <div class="tickets-title">I tuoi biglietti</div>
      ${tickets.map((ticket, index) => `
        <div class="ticket-item">
          <div class="ticket-icon">${index + 1}</div>
          <div class="ticket-info">
            <div class="ticket-id">Biglietto #${ticket.id.slice(-8).toUpperCase()}</div>
            <div class="ticket-status">Allegato come PDF</div>
          </div>
        </div>
      `).join('')}
    </div>

    <div class="notice">
      <p class="notice-text">I biglietti in formato PDF sono allegati a questa email. Stampali o mostrali dal tuo smartphone all'ingresso dell'evento.</p>
    </div>

    <div class="footer">
      <p class="footer-text">Hai domande sul tuo ordine?</p>
      <p class="footer-text">Contattaci a <a href="mailto:support@event4u.it" class="footer-link">support@event4u.it</a></p>
      <p style="color: #94A3B8; font-size: 12px; margin-top: 20px;">&copy; ${new Date().getFullYear()} Event4U - Tutti i diritti riservati</p>
    </div>
  </div>
</body>
</html>
  `;

  const attachments = pdfBuffers.map((buffer, index) => ({
    filename: `biglietto-${tickets[index]?.id?.slice(-8) || index + 1}.pdf`,
    content: buffer,
    contentType: 'application/pdf',
  }));

  const mailOptions = {
    from: `"Event4U" <${process.env.SMTP_USER || 'noreply@event4u.it'}>`,
    to,
    subject,
    html: htmlBody,
    attachments,
  };

  try {
    await emailTransporter.sendMail(mailOptions);
    console.log(`[EMAIL-SERVICE] Ticket email sent successfully to ${to}`);
  } catch (error) {
    console.error('[EMAIL-SERVICE] Failed to send ticket email:', error);
    throw error;
  }
}

interface PasswordResetEmailOptions {
  to: string;
  firstName: string;
  resetLink: string;
}

export async function sendPasswordResetEmail(options: PasswordResetEmailOptions): Promise<void> {
  const { to, firstName, resetLink } = options;

  const htmlBody = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #0a0e17; color: #ffffff; margin: 0; padding: 0;">
  <div style="max-width: 600px; margin: 0 auto; padding: 40px 20px;">
    <div style="text-align: center; margin-bottom: 40px;">
      <div style="font-size: 32px; font-weight: bold; color: #FFD700; margin-bottom: 10px;">Event4U</div>
      <div style="font-size: 24px; color: #ffffff;">Reimposta la tua password</div>
    </div>

    <div style="background-color: #151922; border-radius: 12px; padding: 30px; margin-bottom: 30px;">
      <p style="color: #ffffff; margin-top: 0;">Ciao ${firstName},</p>
      <p style="color: #94A3B8;">Hai richiesto di reimpostare la password del tuo account Event4U.</p>
      
      <div style="text-align: center; margin: 30px 0;">
        <a href="${resetLink}" 
           style="display: inline-block; background-color: #FFD700; color: #0a0e17; padding: 14px 32px; text-decoration: none; border-radius: 8px; font-weight: bold; font-size: 16px;">
          Reimposta Password
        </a>
      </div>
      
      <p style="color: #94A3B8; font-size: 14px;">Questo link scadrà tra 1 ora.</p>
      <p style="color: #94A3B8; font-size: 14px;">Se non hai richiesto il reset della password, ignora questa email.</p>
    </div>

    <div style="text-align: center; padding-top: 20px; border-top: 1px solid #1e2533;">
      <p style="color: #94A3B8; font-size: 12px;">&copy; ${new Date().getFullYear()} Event4U - Tutti i diritti riservati</p>
    </div>
  </div>
</body>
</html>
  `;

  const mailOptions = {
    from: process.env.SMTP_FROM || `"Event4U" <${process.env.SMTP_USER || 'noreply@event4u.it'}>`,
    to,
    subject: "Reimposta la tua password - Event4U",
    html: htmlBody,
  };

  try {
    await emailTransporter.sendMail(mailOptions);
    console.log(`[EMAIL-SERVICE] Password reset email sent successfully to ${to}`);
  } catch (error) {
    console.error('[EMAIL-SERVICE] Failed to send password reset email:', error);
    throw error;
  }
}

// ==================== SIAE XML Transmission Email ====================
// Conforme a Allegato C - Provvedimento Agenzia delle Entrate 04/03/2008
// Usa funzioni condivise da siae-utils.ts per nomi file corretti

import { 
  generateSiaeAttachmentName, 
  generateSiaeSubject 
} from './siae-utils';

// ==================== File Naming SIAE (Allegato C) ====================
// generateSiaeAttachmentName: per nome file allegato (formato breve)
// generateSiaeSubject: per Subject email (formato completo)
// IMPORTANTE: Sono DUE formati diversi secondo la documentazione SIAE!
// 
// CRITICO: systemCode DEVE essere passato esplicitamente dal caller.
// NON usare fallback silenziosi al DEFAULT_SYSTEM_CODE - questo causa
// inconsistenze tra nome file, subject email e contenuto XML (errori SIAE 0600/0603)

interface SiaeTransmissionEmailOptions {
  to: string;
  companyName: string;
  transmissionType: 'daily' | 'monthly' | 'corrective' | 'rca';
  periodDate: Date;
  ticketsCount: number;
  totalAmount: string;
  xmlContent: string;
  transmissionId: string;
  systemCode: string;
  sequenceNumber?: number;
  signWithSmime?: boolean; // Per Allegato C SIAE - firma S/MIME con carta attivazione
  requireSignature?: boolean; // Se true, blocca invio se firma S/MIME non disponibile (default: true per RCA)
  // CAdES-BES support: se presente, il file è firmato CAdES-BES (SHA-256)
  p7mBase64?: string; // Contenuto P7M in Base64 (binario CAdES-BES)
  signatureFormat?: 'cades' | 'xmldsig'; // Formato firma (default: autodetect)
}

// Risultato dell'invio email SIAE con info sulla firma
export interface SiaeEmailResult {
  success: boolean;
  smimeSigned: boolean;
  signerEmail?: string;
  signerName?: string;
  signedAt?: string;
  error?: string;
}

/**
 * Invia email SIAE con opzione di firma S/MIME
 * Per Allegato C SIAE (Provvedimento 04/03/2008), sezione 1.6.1-1.6.2:
 * - L'email deve essere firmata S/MIME v2 con la carta di attivazione
 * - Il mittente deve corrispondere all'email nel certificato della carta
 * - Senza firma S/MIME, SIAE non invia conferma di ricezione
 */
export async function sendSiaeTransmissionEmail(options: SiaeTransmissionEmailOptions): Promise<SiaeEmailResult> {
  const { 
    to, 
    companyName, 
    transmissionType, 
    periodDate, 
    ticketsCount, 
    totalAmount, 
    xmlContent, 
    transmissionId,
    systemCode,
    sequenceNumber = 1,
    signWithSmime = false,
    requireSignature, // undefined = auto (true per RCA, false per altri)
    p7mBase64,
    signatureFormat
  } = options;
  
  // VALIDAZIONE CRITICA: systemCode DEVE essere sempre passato esplicitamente
  // Fallback silenzioso al DEFAULT_SYSTEM_CODE causa errori SIAE 0600/0603
  // (incoerenza tra nome file, subject email e contenuto XML)
  if (!systemCode || systemCode.trim() === '') {
    console.error('[EMAIL-SERVICE] CRITICAL: systemCode non fornito in sendSiaeTransmissionEmail!');
    console.error('[EMAIL-SERVICE] systemCode DEVE essere passato esplicitamente dal caller.');
    console.error('[EMAIL-SERVICE] Fallback silenzioso NON è permesso - causa errori SIAE 0600/0603');
    throw new Error(
      'SYSTEM_CODE_REQUIRED: Il parametro systemCode è obbligatorio e deve essere passato esplicitamente. ' +
      'Non è permesso usare fallback silenziosi al codice default - questo causa incoerenze tra ' +
      'nome file, subject email e contenuto XML, generando errori SIAE 0600/0603.'
    );
  }
  
  console.log(`[EMAIL-SERVICE] [SIAE-VALIDATION] systemCode=${systemCode} (esplicitamente fornito dal caller)`);

  
  // Per RCA (che genera risposta SIAE), la firma è obbligatoria di default
  const mustSign = requireSignature ?? (transmissionType === 'rca');

  // Determina se il file è firmato CAdES-BES (P7M) o XMLDSig legacy
  const isCAdES = !!p7mBase64 || signatureFormat === 'cades';
  const isXmlDsig = !isCAdES && xmlContent.includes('<Signature') && xmlContent.includes('</Signature>');
  const isSigned = isCAdES || isXmlDsig;
  
  // Mappa transmissionType al formato richiesto da generateSiaeFileName (Allegato C SIAE)
  const reportTypeMap: Record<string, 'giornaliero' | 'mensile' | 'rca' | 'log'> = {
    'daily': 'giornaliero',     // RMG - Riepilogo Mensile Giornaliero (silenzioso)
    'monthly': 'mensile',       // RPM - Riepilogo Periodico Mensile (silenzioso)
    'rca': 'rca',               // RCA - Riepilogo Controllo Accessi (genera risposta SIAE)
    'corrective': 'giornaliero', // Correttivo usa stesso formato di giornaliero
  };
  const reportType = reportTypeMap[transmissionType] || 'giornaliero';
  
  // ============================================================
  // FIX 2026-01-07: SIAE S/MIME richiede UNA SOLA firma!
  // 
  // Allegato C dice che l'allegato deve essere .xsi.p7m (CAdES)
  // MA questo si riferisce a quando si salva su CD-R (sezione 1.1)
  //
  // Per EMAIL (sezione 1.5.2), il messaggio è S/MIME SignedData.
  // SMIMESignML di libSIAEp7.dll firma l'INTERA email incluso allegato.
  // Se passiamo un P7M già firmato, otteniamo doppia firma:
  // S/MIME(P7M(XML)) = SignedData(SignedData(XML)) = ILLEGGIBILE!
  //
  // SOLUZIONE: Passare XML diretto a SMIMESignML, che crea:
  // S/MIME(email con allegato XML) = firma singola, leggibile
  //
  // Nome file: .xsi (XML) invece di .xsi.p7m (doppia firma)
  // ============================================================
  
  // Per email S/MIME, usiamo SEMPRE allegato XML diretto (non P7M)
  // SMIMESignML crea la firma S/MIME che include l'allegato
  const useRawXmlForSmime = signWithSmime;
  const effectiveSignatureFormat = useRawXmlForSmime ? null : (isCAdES ? 'cades' : (isXmlDsig ? 'xmldsig' : null));
  const fileName = generateSiaeAttachmentName(reportType, periodDate, sequenceNumber, effectiveSignatureFormat, systemCode);
  
  // Subject conforme a RFC-2822 SIAE (Sezione 1.5.3)
  // FIX 2026-01-16: Subject DEVE essere uguale al nome file senza estensione (errore 0603)
  const emailSubject = generateSiaeSubject(reportType, periodDate, sequenceNumber, systemCode);
  
  // Validazione coerenza subject/filename per prevenire errore SIAE 0603
  const fileNameBase = fileName.replace(/\.xsi(\.p7m)?$/, '');
  if (emailSubject !== fileNameBase) {
    console.error(`[EMAIL-SERVICE] CRITICAL: Subject/filename mismatch! subject="${emailSubject}" != fileNameBase="${fileNameBase}"`);
    throw new Error(`SIAE 0603: Subject email non corrisponde al nome file. subject="${emailSubject}", filename="${fileName}"`);
  }
  console.log(`[EMAIL-SERVICE] SIAE file naming: attachmentName=${fileName}, subject=${emailSubject} (coerenza verificata)`);
  console.log(`[EMAIL-SERVICE] FIX 2026-01-07: Using raw XML for S/MIME (no double signature)`);
  if (p7mBase64) {
    console.log(`[EMAIL-SERVICE] WARNING: P7M provided but ignored - S/MIME includes XML directly`);
  }

  const typeLabels: Record<string, string> = {
    'daily': 'Giornaliera (C1)',
    'monthly': 'Mensile (C1)',
    'rca': 'RCA Evento (C1)',
    'corrective': 'Correttiva (C1)'
  };
  
  // Nome report per header email - usa i nomi corretti DTD
  const reportNames: Record<string, string> = {
    'daily': 'RiepilogoGiornaliero',
    'monthly': 'RiepilogoMensile',
    'rca': 'RiepilogoControlloAccessi', // DTD: ControlloAccessi_v0001_20080626.dtd
    'corrective': 'RiepilogoGiornaliero'
  };
  const reportName = reportNames[transmissionType] || 'RiepilogoGiornaliero';

  const formatDate = (date: Date) => {
    return date.toLocaleDateString('it-IT', { day: '2-digit', month: 'long', year: 'numeric' });
  };

  // Stato S/MIME per l'HTML
  let smimeStatus = 'NON FIRMATA S/MIME';
  let smimeResult: { signed: boolean; signerEmail?: string; signerName?: string; signedAt?: string } = { signed: false };

  const htmlBody = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f5f5f5; color: #333333; margin: 0; padding: 0;">
  <div style="max-width: 600px; margin: 0 auto; padding: 40px 20px;">
    <div style="text-align: center; margin-bottom: 40px;">
      <div style="font-size: 28px; font-weight: bold; color: #1a237e; margin-bottom: 10px;">Event4U - ${reportName}</div>
      <div style="font-size: 18px; color: #666;">Trasmissione SIAE C1 - Allegato B</div>
    </div>

    <div style="background-color: #ffffff; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
      <h2 style="color: #1a237e; margin-top: 0; margin-bottom: 20px;">Riepilogo Trasmissione</h2>
      
      <table style="width: 100%; border-collapse: collapse;">
        <tr>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; color: #666;">Azienda</td>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; font-weight: 500; text-align: right;">${companyName}</td>
        </tr>
        <tr>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; color: #666;">Tipo Trasmissione</td>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; font-weight: 500; text-align: right;">${typeLabels[transmissionType] || transmissionType}</td>
        </tr>
        <tr>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; color: #666;">Data Riferimento</td>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; font-weight: 500; text-align: right;">${formatDate(periodDate)}</td>
        </tr>
        <tr>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; color: #666;">Numero Biglietti</td>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; font-weight: 500; text-align: right;">${ticketsCount}</td>
        </tr>
        <tr>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; color: #666;">Importo Totale</td>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; font-weight: 500; text-align: right; color: #2e7d32;">€${totalAmount}</td>
        </tr>
        <tr>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; color: #666;">Codice Sistema</td>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; font-weight: 500; text-align: right;">${systemCode}</td>
        </tr>
        <tr>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; color: #666;">Progressivo</td>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; font-weight: 500; text-align: right;">${String(sequenceNumber).padStart(3, '0')}</td>
        </tr>
        <tr>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; color: #666;">Firma Allegato</td>
          <td style="padding: 12px 0; border-bottom: 1px solid #eee; font-weight: 500; text-align: right;">${isSigned ? 'FIRMATA (P7M)' : 'NON FIRMATA'}</td>
        </tr>
      </table>
      
      <div style="margin-top: 25px; padding: 15px; background-color: #e8eaf6; border-radius: 4px;">
        <p style="margin: 0; font-size: 14px; color: #1a237e;">
          <strong>Nota:</strong> Il file ${reportName} è allegato con nome <code>${fileName}</code>.
        </p>
        <p style="margin: 10px 0 0 0; font-size: 12px; color: #666;">
          Formato conforme a Provvedimento Agenzia delle Entrate 04/03/2008 (Allegato B)
        </p>
      </div>
    </div>

    <div style="text-align: center; color: #999; font-size: 12px;">
      <p>&copy; ${new Date().getFullYear()} Event4U - Sistema Gestione Fiscale SIAE</p>
    </div>
  </div>
</body>
</html>
  `;

  // Prepara opzioni email base - usa SIAE SMTP per le trasmissioni (corrisponde al certificato smart card)
  const siaeSmtpUser = process.env.SIAE_SMTP_USER || process.env.SMTP_USER;
  // v3.30 FIX: Senza virgolette come da file test SIAE
  const fromAddress = process.env.SIAE_SMTP_FROM || `Event4U SIAE <${siaeSmtpUser || 'noreply@event4u.it'}>`;
  
  // Se richiesta firma S/MIME e bridge connesso, tenta di firmare l'email
  if (signWithSmime && isBridgeConnected()) {
    try {
      console.log(`[EMAIL-SERVICE] Attempting S/MIME signature for SIAE email to ${to}...`);
      
      // CRITICO: Per Allegato C SIAE 1.6.2.a.3, l'email del mittente DEVE corrispondere
      // esattamente a quella nel certificato pubblico sulla smart card.
      // Se non corrisponde, SIAE NON invia risposta di conferma.
      // L'header "From:" nel messaggio MIME firmato È IMMUTABILE dopo la firma,
      // quindi DEVE essere corretto PRIMA di inviare al bridge per la firma.
      
      // Prova a ottenere l'email dal cache dello status del bridge
      let cardEmail = getCardSignerEmail();
      
      if (cardEmail) {
        console.log(`[EMAIL-SERVICE] Card signer email (from cache): ${cardEmail}`);
      } else {
        // CRITICO: Email non nel cache - BLOCCA L'INVIO
        // Non possiamo procedere senza l'email del certificato perché:
        // 1. L'header "From:" nel messaggio MIME deve corrispondere all'email del certificato
        // 2. Dopo la firma S/MIME, gli header sono immutabili
        // 3. Se l'header "From:" non corrisponde, SIAE non risponde
        console.log(`[EMAIL-SERVICE] CRITICAL: Card email not available in bridge cache`);
        console.log(`[EMAIL-SERVICE] Cannot proceed - From header must match certificate email BEFORE signing`);
        
        // Informa l'utente di riconnettere l'app desktop per aggiornare il cache
        throw new Error(
          'EMAIL_CERTIFICATO_NON_DISPONIBILE: L\'email del certificato smart card non è disponibile. ' +
          'Riconnetti l\'app desktop Event4U (chiudi e riapri) con la smart card inserita, ' +
          'poi attendi qualche secondo e riprova. L\'app deve inviare l\'email del certificato al server.'
        );
      }
      
      // Usa SEMPRE l'email del certificato nell'header From
      // Questo garantisce che il messaggio firmato sia conforme ad Allegato C SIAE 1.6.2.a.3
      // v3.30 FIX: Rimuove virgolette dal display name - file test SIAE usa "Mario Rossi <email>" SENZA virgolette
      const certFromAddress = `Event4U SIAE <${cardEmail}>`;
      
      // ============================================================
      // FIX 2026-01-07: SEMPRE XML diretto per S/MIME!
      // 
      // SMIMESignML firma l'INTERA email (body + allegato) creando S/MIME opaco.
      // Se passiamo P7M già firmato → doppia firma → SIAE errore 40605!
      //
      // L'allegato DEVE essere XML puro (.xsi), NON P7M (.xsi.p7m)
      // SMIMESignML crea: S/MIME(email con XML allegato) = UNA sola firma
      // ============================================================
      // FIX 2026-01-15: Usa 'latin1' invece di 'utf-8' per encoding ISO-8859-1
      // L'XML dichiara encoding="ISO-8859-1" quindi i byte devono corrispondere.
      // Usando utf-8, caratteri accentati diventano multi-byte causando errore SIAE 40605.
      const attachmentBase64Content = Buffer.from(xmlContent, 'latin1').toString('base64');
      console.log(`[EMAIL-SERVICE] FIX 2026-01-15: Using latin1 encoding for ISO-8859-1 XML attachment`);
      
      // INTEGRITY CHECK: Log SHA-256 prima dell'invio per diagnostica trasmissione
      try {
        const crypto = await import('crypto');
        const buffer = Buffer.from(xmlContent, 'latin1');
        const sha256Hash = crypto.createHash('sha256').update(buffer).digest('hex');
        console.log(`[EMAIL-SERVICE] [INTEGRITY] Attachment pre-send check:`);
        console.log(`[EMAIL-SERVICE] [INTEGRITY]   - Type: XML (raw, for S/MIME signing)`);
        console.log(`[EMAIL-SERVICE] [INTEGRITY]   - Size: ${buffer.length} bytes`);
        console.log(`[EMAIL-SERVICE] [INTEGRITY]   - Base64 length: ${attachmentBase64Content.length} chars`);
        console.log(`[EMAIL-SERVICE] [INTEGRITY]   - SHA-256: ${sha256Hash}`);
      } catch (hashError: any) {
        console.log(`[EMAIL-SERVICE] [INTEGRITY] Failed to compute SHA-256: ${hashError.message}`);
      }
      
      // Corpo email semplice (text/plain per SMIMESignML)
      // SMIMESignML richiede testo ASCII-7bit nel body
      const plainBody = [
        `Trasmissione SIAE RCA - ${reportName}`,
        ``,
        `Data: ${new Date().toLocaleDateString('it-IT')}`,
        `Evento: ${reportName}`,
        `Transmission ID: ${transmissionId}`,
        `System Code: ${systemCode}`,
        `Sequence: ${sequenceNumber}`,
        ``,
        `Il file ${fileName} e' allegato a questa email.`,
        `Formato conforme a Provvedimento Agenzia delle Entrate 04/03/2008 (Allegato B)`,
        ``,
        `Event4U - Sistema Gestione Fiscale SIAE`
      ].join('\r\n');
      
      // Richiedi firma S/MIME al Desktop Bridge con SMIMESignML
      const smimeData = await requestSmimeSignature({
        from: certFromAddress,
        to: to,
        subject: emailSubject,
        body: plainBody,
        attachmentBase64: attachmentBase64Content,
        attachmentName: fileName
      }, to);
      
      // Valida che il bridge abbia restituito un payload S/MIME valido
      if (!smimeData.signedMime || smimeData.signedMime.length < 100) {
        throw new Error('SMIME_INVALID_RESPONSE: Bridge ha restituito un payload S/MIME non valido');
      }
      
      // Log primi 800 caratteri per debug header - importante per diagnosticare problema To/Subject
      console.log(`[EMAIL-SERVICE] S/MIME payload preview (first 800 chars):\n${smimeData.signedMime.substring(0, 800)}`);
      
      // DIAGNOSTICA: Verifica presenza header nel messaggio S/MIME
      // NOTA: NON modifichiamo il messaggio firmato - qualsiasi modifica invalida la firma
      // Se gli header mancano, il problema è nel bridge desktop che deve essere corretto
      const hasToHeader = smimeData.signedMime.toLowerCase().includes('\nto:') || smimeData.signedMime.toLowerCase().startsWith('to:');
      const hasSubjectHeader = smimeData.signedMime.toLowerCase().includes('\nsubject:') || smimeData.signedMime.toLowerCase().startsWith('subject:');
      const hasFromHeader = smimeData.signedMime.toLowerCase().includes('\nfrom:') || smimeData.signedMime.toLowerCase().startsWith('from:');
      
      console.log(`[EMAIL-SERVICE] S/MIME header check: From=${hasFromHeader}, To=${hasToHeader}, Subject=${hasSubjectHeader}`);
      
      if (!hasToHeader || !hasSubjectHeader) {
        console.log(`[EMAIL-SERVICE] WARNING: Bridge S/MIME payload missing headers!`);
        console.log(`[EMAIL-SERVICE] IMPORTANT: Headers cannot be added after signing - fix needed in bridge desktop`);
        console.log(`[EMAIL-SERVICE] Email will be sent but recipient may see "(no subject)" and BCC routing`);
      }
      
      // ============================================================
      // VALIDAZIONE S/MIME (2026-01-06)
      // Ora usiamo SMIMESignML nativo che genera formato S/MIME conforme
      // Accettiamo sia opaque che multipart/signed se generato da libreria SIAE
      // ============================================================
      
      const isOpaque = smimeData.signedMime.includes('Content-Type: application/pkcs7-mime') ||
                       smimeData.signedMime.includes('Content-Type: application/x-pkcs7-mime');
      const isMultipartSigned = smimeData.signedMime.includes('multipart/signed');
      const isSmimeNative = smimeData.generator === 'SMIMESignML-native';
      
      if (!isOpaque && !isMultipartSigned) {
        console.log(`[EMAIL-SERVICE] ❌ ERRORE: Bridge NON sta producendo S/MIME valido!`);
        throw new Error("Bridge non produce S/MIME valido. Aggiornare bridge desktop.");
      }
      
      if (isSmimeNative) {
        console.log(`[EMAIL-SERVICE] ✅ S/MIME generato da SMIMESignML nativo SIAE`);
      } else if (isOpaque) {
        console.log(`[EMAIL-SERVICE] ✅ S/MIME OPAQUE (application/pkcs7-mime)`);
      } else {
        console.log(`[EMAIL-SERVICE] ✅ S/MIME multipart/signed`);
      }
      
      // CHECK B: Verifica separatore header/body (\r\n\r\n)
      if (!smimeData.signedMime.includes('\r\n\r\n')) {
        console.log(`[EMAIL-SERVICE] ❌ ERRORE: RAW senza separatore header/body (\\r\\n\\r\\n)`);
        throw new Error("Messaggio S/MIME senza separatore header/body. Verificare bridge desktop.");
      }
      console.log(`[EMAIL-SERVICE] ✅ Separatore header/body presente`);
      
      // CHECK C: Log prime righe e dimensione per debug
      const rawLines = smimeData.signedMime.split('\r\n');
      const headerEndIndex = rawLines.findIndex(line => line === '');
      const headerLines = rawLines.slice(0, Math.min(headerEndIndex > 0 ? headerEndIndex : 10, 15));
      console.log(`[EMAIL-SERVICE] === S/MIME HEADER (prime ${headerLines.length} righe) ===`);
      headerLines.forEach((line, i) => console.log(`  ${i + 1}: ${line}`));
      console.log(`[EMAIL-SERVICE] === FINE HEADER ===`);
      console.log(`[EMAIL-SERVICE] Dimensione totale RAW: ${smimeData.signedMime.length} bytes`);
      
      smimeResult = {
        signed: true,
        signerEmail: smimeData.signerEmail,
        signerName: smimeData.signerName,
        signedAt: smimeData.signedAt
      };
      smimeStatus = `FIRMATA S/MIME (${smimeData.signerEmail})`;
      
      console.log(`[EMAIL-SERVICE] S/MIME signature obtained from ${smimeData.signerName} <${smimeData.signerEmail}>`);
      
      // ============================================================
      // INVIO RAW SECONDO ISTRUZIONI SIAE
      // ============================================================
      
      // CRITICO: L'envelope.from DEVE corrispondere all'email del certificato (Allegato C 1.6.2.a.3)
      const envelopeFrom = smimeData.signerEmail || cardEmail;
      console.log(`[EMAIL-SERVICE] Envelope from (for SIAE compliance): ${envelopeFrom}`);
      
      // IMPORTANTE: NON normalizzare il messaggio S/MIME dopo la firma!
      // La normalizzazione corrompe il contenuto firmato causando errore SIAE 40605
      // Il bridge deve già inviare il messaggio con CRLF corretti
      const rawMessage = smimeData.signedMime;
      
      // Verifica che il messaggio abbia CRLF corretti (warning only, non modificare)
      const hasMixedLineEndings = rawMessage.includes('\r\n') && rawMessage.includes('\n') && 
                                  !rawMessage.split('\r\n').every(line => !line.includes('\n'));
      if (hasMixedLineEndings) {
        console.log(`[EMAIL-SERVICE] ⚠️ WARNING: Messaggio con line endings misti. Bridge potrebbe aver inviato dati corrotti.`);
      }
      
      // Invia come Buffer binario per evitare qualsiasi trasformazione
      const rawMailOptions = {
        envelope: {
          from: envelopeFrom,
          to: [to]
        },
        raw: Buffer.from(rawMessage, 'binary')
      };
      
      console.log(`[EMAIL-SERVICE] Sending RAW S/MIME (${rawMessage.length} bytes) to ${to}`);
      await siaeEmailTransporter.sendMail(rawMailOptions);
      console.log(`[EMAIL-SERVICE] S/MIME signed email sent successfully to ${to} via SIAE SMTP`);
      
      return {
        success: true,
        smimeSigned: true,
        signerEmail: smimeData.signerEmail,
        signerName: smimeData.signerName,
        signedAt: smimeData.signedAt
      };
      
    } catch (smimeError: any) {
      console.log(`[EMAIL-SERVICE] S/MIME signature failed: ${smimeError.message}`);
      
      // Se la firma è obbligatoria, blocca l'invio
      if (mustSign) {
        console.log(`[EMAIL-SERVICE] BLOCKED: Signature required but failed. Email NOT sent.`);
        return {
          success: false,
          smimeSigned: false,
          error: `FIRMA_OBBLIGATORIA: ${smimeError.message}. Per ricevere risposta da SIAE, collega l'app desktop con Smart Card inserita.`
        };
      }
      
      console.log(`[EMAIL-SERVICE] Proceeding with unsigned email (SIAE may not send confirmation)`);
      smimeStatus = `FIRMA S/MIME FALLITA: ${smimeError.message}`;
    }
  } else if (signWithSmime) {
    // Bridge non connesso
    if (mustSign) {
      console.log(`[EMAIL-SERVICE] BLOCKED: Signature required but bridge not connected. Email NOT sent.`);
      return {
        success: false,
        smimeSigned: false,
        error: `BRIDGE_NON_CONNESSO: App desktop Event4U non connessa. Per ricevere risposta da SIAE, avvia l'app desktop con Smart Card inserita.`
      };
    }
    console.log(`[EMAIL-SERVICE] S/MIME requested but bridge not connected. Sending unsigned.`);
    smimeStatus = 'BRIDGE NON CONNESSO - NON FIRMATA';
  } else if (mustSign) {
    // Firma obbligatoria ma signWithSmime non abilitato
    console.log(`[EMAIL-SERVICE] BLOCKED: Signature required but signWithSmime not enabled.`);
    return {
      success: false,
      smimeSigned: false,
      error: `FIRMA_NON_ABILITATA: Per trasmissioni RCA è richiesta la firma S/MIME. Abilita signWithSmime e collega l'app desktop.`
    };
  }

  // Invia l'email non firmata (fallback quando S/MIME non disponibile o fallito)
  // Nota: Senza firma S/MIME, SIAE potrebbe non inviare conferma di ricezione (Allegato C 1.6.2)
  
  // Prepara l'allegato: P7M binario per CAdES-BES, testo XML per legacy
  let attachmentContent: Buffer | string;
  let attachmentContentType: string;
  
  if (isCAdES && p7mBase64) {
    // CAdES-BES: decodifica Base64 in buffer binario
    attachmentContent = Buffer.from(p7mBase64, 'base64');
    attachmentContentType = 'application/pkcs7-mime';
    console.log(`[EMAIL-SERVICE] Attaching CAdES-BES P7M file: ${fileName} (${attachmentContent.length} bytes)`);
  } else {
    // XMLDSig legacy o XML non firmato
    attachmentContent = xmlContent;
    attachmentContentType = 'application/xml';
  }
  
  const mailOptions = {
    from: fromAddress,
    to,
    subject: emailSubject,
    html: htmlBody,
    attachments: [
      {
        filename: fileName,
        content: attachmentContent,
        contentType: attachmentContentType,
      },
    ],
  };

  try {
    await siaeEmailTransporter.sendMail(mailOptions);
    const smimeNote = smimeResult.signed ? '' : ' (NON firmata S/MIME - SIAE potrebbe non confermare)';
    console.log(`[EMAIL-SERVICE] SIAE RCA email sent to ${to} via SIAE SMTP | Subject: ${emailSubject} | File: ${fileName}${smimeNote}`);
    
    return {
      success: true,
      smimeSigned: smimeResult.signed,
      signerEmail: smimeResult.signerEmail,
      signerName: smimeResult.signerName,
      signedAt: smimeResult.signedAt
    };
  } catch (error: any) {
    console.error('[EMAIL-SERVICE] Failed to send SIAE transmission email:', error);
    return {
      success: false,
      smimeSigned: false,
      error: error.message
    };
  }
}


================================================================================
FILE: client/src/pages/siae-transmissions.tsx
================================================================================
import { useState, useEffect } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { format } from "date-fns";
import { it } from "date-fns/locale";
import { motion, AnimatePresence } from "framer-motion";
import { queryClient, apiRequest } from "@/lib/queryClient";
import { useAuth } from "@/hooks/useAuth";
import { useToast } from "@/hooks/use-toast";
import { useIsMobile } from "@/hooks/use-mobile";
import { type SiaeTransmission, type Company, type SiaeTransmissionSettings } from "@shared/schema";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Skeleton } from "@/components/ui/skeleton";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import {
  MobileAppLayout,
  MobileHeader,
  HapticButton,
  BottomSheet,
  triggerHaptic,
} from "@/components/mobile-primitives";
import {
  Send,
  FileText,
  Euro,
  Ticket,
  CheckCircle2,
  Clock,
  AlertTriangle,
  Eye,
  Download,
  RefreshCw,
  Loader2,
  Upload,
  ChevronRight,
  ChevronDown,
  ArrowLeft,
  Filter,
  X,
  Mail,
  Zap,
  TestTube,
  Plus,
  Building2,
  ShieldCheck,
  ShieldAlert,
  Link2,
  Unlink,
  Search,
  Calendar,
  Settings,
  RotateCcw,
  Save,
} from "lucide-react";

const transmissionSettingsSchema = z.object({
  dailyEnabled: z.boolean(),
  dailyIntervalDays: z.number().min(1).max(30),
  endEventEnabled: z.boolean(),
  endEventDelayDays: z.number().min(1).max(30),
  monthlyEnabled: z.boolean(),
  monthlyDelayDays: z.number().min(1).max(30),
  monthlyRecurringDay: z.number().min(1).max(28),
  autoSendEnabled: z.boolean(),
});

type TransmissionSettingsFormValues = z.infer<typeof transmissionSettingsSchema>;

const springTransition = {
  type: "spring" as const,
  stiffness: 400,
  damping: 30,
};

export default function SiaeTransmissionsPage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const isMobile = useIsMobile();
  const [selectedTransmission, setSelectedTransmission] = useState<SiaeTransmission | null>(null);
  const [isDetailSheetOpen, setIsDetailSheetOpen] = useState(false);
  const [isCreateSheetOpen, setIsCreateSheetOpen] = useState(false);
  const [isFilterSheetOpen, setIsFilterSheetOpen] = useState(false);
  const [isTestEmailSheetOpen, setIsTestEmailSheetOpen] = useState(false);
  const [isSendDailySheetOpen, setIsSendDailySheetOpen] = useState(false);
  const [isConfirmReceiptSheetOpen, setIsConfirmReceiptSheetOpen] = useState(false);
  const [isDetailDialogOpen, setIsDetailDialogOpen] = useState(false);
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [isSendDailyDialogOpen, setIsSendDailyDialogOpen] = useState(false);
  const [isTestEmailDialogOpen, setIsTestEmailDialogOpen] = useState(false);
  const [isConfirmReceiptDialogOpen, setIsConfirmReceiptDialogOpen] = useState(false);
  const [statusFilter, setStatusFilter] = useState<string>("all");
  const [typeFilter, setTypeFilter] = useState<string>("all");
  const [transmissionType, setTransmissionType] = useState<string>("daily");
  const [periodDate, setPeriodDate] = useState<string>("");
  const [testEmail, setTestEmail] = useState<string>("servertest2@batest.siae.it");
  const [dailyDate, setDailyDate] = useState<string>(new Date().toISOString().split('T')[0]);
  const [dailyEmail, setDailyEmail] = useState<string>("servertest2@batest.siae.it");
  const [c1Type, setC1Type] = useState<'daily' | 'monthly' | 'rca'>('daily');
  const [selectedEventId, setSelectedEventId] = useState<string>("");
  const [receiptProtocol, setReceiptProtocol] = useState<string>("");
  const [receiptContent, setReceiptContent] = useState<string>("");
  const [selectedCompanyId, setSelectedCompanyId] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState<string>("");
  const [dateFrom, setDateFrom] = useState<string>("");
  const [dateTo, setDateTo] = useState<string>("");
  const [forceSubstitution, setForceSubstitution] = useState<boolean>(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState<boolean>(false);
  const [eventFilterId, setEventFilterId] = useState<string>("all");
  const [isResendDialogOpen, setIsResendDialogOpen] = useState(false);
  const [resendEmail, setResendEmail] = useState<string>("servertest2@batest.siae.it");

  const isSuperAdmin = user?.role === 'super_admin';
  const companyId = isSuperAdmin ? selectedCompanyId : user?.companyId;

  // Settings form with react-hook-form
  const settingsForm = useForm<TransmissionSettingsFormValues>({
    resolver: zodResolver(transmissionSettingsSchema),
    defaultValues: {
      dailyEnabled: true,
      dailyIntervalDays: 5,
      endEventEnabled: true,
      endEventDelayDays: 5,
      monthlyEnabled: true,
      monthlyDelayDays: 5,
      monthlyRecurringDay: 1,
      autoSendEnabled: false,
    },
  });

  const { data: companies } = useQuery<Company[]>({
    queryKey: ['/api/companies'],
    enabled: isSuperAdmin,
  });

  // Fetch transmission settings (global singleton)
  const { data: transmissionSettings, isLoading: isLoadingSettings } = useQuery<SiaeTransmissionSettings>({
    queryKey: ['/api/siae/transmission-settings'],
  });

  // Update form when settings are loaded
  useEffect(() => {
    if (transmissionSettings) {
      settingsForm.reset({
        dailyEnabled: transmissionSettings.dailyEnabled ?? true,
        dailyIntervalDays: transmissionSettings.dailyIntervalDays ?? 5,
        endEventEnabled: transmissionSettings.endEventEnabled ?? true,
        endEventDelayDays: transmissionSettings.endEventDelayDays ?? 5,
        monthlyEnabled: transmissionSettings.monthlyEnabled ?? true,
        monthlyDelayDays: transmissionSettings.monthlyDelayDays ?? 5,
        monthlyRecurringDay: transmissionSettings.monthlyRecurringDay ?? 1,
        autoSendEnabled: transmissionSettings.autoSendEnabled ?? false,
      });
    }
  }, [transmissionSettings, settingsForm]);

  // Build transmission list URL with optional event filter
  const transmissionsListUrl = eventFilterId !== 'all' 
    ? `/api/siae/transmissions-list?companyId=${companyId}&ticketedEventId=${eventFilterId}`
    : `/api/siae/transmissions-list?companyId=${companyId}`;

  // Fetch transmissions - use list API with event filter
  const { data: transmissions, isLoading } = useQuery<(SiaeTransmission & { eventName?: string })[]>({
    queryKey: ['/api/siae/transmissions-list', companyId, eventFilterId],
    queryFn: async () => {
      const res = await fetch(transmissionsListUrl, { credentials: 'include' });
      if (!res.ok) throw new Error('Failed to fetch transmissions');
      return res.json();
    },
    enabled: !!companyId,
  });

  // Fetch SIAE ticketed events (used for both dropdown filter and RCA selection)
  const { data: ticketedEvents } = useQuery<Array<{
    id: string;
    eventId: string;
    eventName: string;
    eventDate: string;
    status: string;
  }>>({
    queryKey: ['/api/siae/companies', companyId, 'ticketed-events'],
    enabled: !!companyId,
  });

  // Use all ticketed events for dropdown filter
  const eventsForDropdown = ticketedEvents;

  // FIX 2026-01-18: Per RCA mostra solo eventi closed, per RMG/RPM permetti anche ongoing/scheduled
  // RCA: solo eventi conclusi (obbligatorio per SIAE)
  const eventsForRCA = ticketedEvents?.filter(e => e.status === 'closed') || [];
  // RMG/RPM: permetti eventi scheduled (data odierna), ongoing, o conclusi
  // Status possibili: draft, scheduled, ongoing, closed
  const eventsForDaily = ticketedEvents?.filter(e => 
    e.status === 'closed' || 
    e.status === 'ongoing' || 
    e.status === 'scheduled' // eventi programmati per oggi
  ) || [];

  // Fetch validation prerequisites for selected event
  const { data: prerequisiteValidation, isLoading: isLoadingPrerequisites } = useQuery<{
    isReady: boolean;
    score: number;
    errors: Array<{ code: string; field: string; category: string; message: string; resolution: string; siaeErrorCode?: string }>;
    warnings: Array<{ code: string; field: string; category: string; message: string; suggestion: string }>;
    checklist: Array<{ category: string; field: string; label: string; status: string; value?: string | number | null; required: boolean }>;
  }>({
    queryKey: ['/api/siae/ticketed-events', selectedEventId, 'validate-prerequisites'],
    enabled: !!selectedEventId && c1Type === 'rca',
  });

  // Gmail OAuth status (system-wide, always enabled)
  const { data: gmailStatus } = useQuery<{ authorized: boolean; connected: boolean; email?: string }>({
    queryKey: ['/api/gmail/status'],
  });

  // Handle URL params for Gmail OAuth callback
  const urlParams = new URLSearchParams(window.location.search);
  const gmailSuccess = urlParams.get('gmail_success');
  const gmailEmail = urlParams.get('gmail_email');
  const gmailError = urlParams.get('gmail_error');
  
  // Show toast for Gmail OAuth result (only once)
  if (gmailSuccess === 'true' && gmailEmail) {
    window.history.replaceState({}, '', window.location.pathname);
    setTimeout(() => {
      toast({
        title: "Gmail Autorizzato",
        description: `Account ${decodeURIComponent(gmailEmail)} collegato per la lettura email SIAE.`,
      });
      queryClient.invalidateQueries({ queryKey: ['/api/gmail/status'] });
    }, 100);
  } else if (gmailError) {
    window.history.replaceState({}, '', window.location.pathname);
    setTimeout(() => {
      toast({
        title: "Errore Gmail",
        description: gmailError === 'access_denied' ? "Accesso negato dall'utente" : `Errore: ${decodeURIComponent(gmailError)}`,
        variant: "destructive",
      });
    }, 100);
  }

  const createTransmissionMutation = useMutation({
    mutationFn: async (data: { transmissionType: string; periodDate: string }) => {
      const response = await apiRequest("POST", `/api/siae/transmissions`, {
        ...data,
        companyId,
        periodDate: new Date(data.periodDate).toISOString(),
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ predicate: (q) => (q.queryKey[0] as string)?.includes('transmissions') || false });
      setIsCreateSheetOpen(false);
      setPeriodDate("");
      triggerHaptic('success');
      toast({
        title: "Trasmissione Creata",
        description: "Il file XML è stato generato. Procedi con l'invio.",
      });
    },
    onError: (error: Error) => {
      triggerHaptic('error');
      toast({
        title: "Errore",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const retryTransmissionMutation = useMutation({
    mutationFn: async (id: string) => {
      const response = await apiRequest("PATCH", `/api/siae/transmissions/${id}`, {
        status: "pending",
        retryCount: (selectedTransmission?.retryCount || 0) + 1,
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ predicate: (q) => (q.queryKey[0] as string)?.includes('transmissions') || false });
      triggerHaptic('success');
      toast({
        title: "Riprova Invio",
        description: "La trasmissione è stata rimessa in coda.",
      });
    },
    onError: (error: Error) => {
      triggerHaptic('error');
      toast({
        title: "Errore",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const sendEmailMutation = useMutation({
    mutationFn: async ({ id, toEmail }: { id: string; toEmail: string }) => {
      const response = await apiRequest("POST", `/api/siae/transmissions/${id}/send-email`, {
        toEmail,
        companyId,
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ predicate: (q) => (q.queryKey[0] as string)?.includes('transmissions') || false });
      setIsDetailSheetOpen(false);
      triggerHaptic('success');
      toast({
        title: "Email Inviata",
        description: "La trasmissione XML è stata inviata via email.",
      });
    },
    onError: (error: Error) => {
      triggerHaptic('error');
      toast({
        title: "Errore",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const testEmailMutation = useMutation({
    mutationFn: async (toEmail: string) => {
      const response = await apiRequest("POST", `/api/siae/transmissions/test-email`, {
        toEmail,
        companyId,
      });
      return response.json();
    },
    onSuccess: () => {
      setIsTestEmailSheetOpen(false);
      triggerHaptic('success');
      toast({
        title: "Test Inviato",
        description: "L'email di test è stata inviata con successo.",
      });
    },
    onError: (error: Error) => {
      triggerHaptic('error');
      toast({
        title: "Errore",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const sendC1Mutation = useMutation({
    mutationFn: async ({ date, toEmail, type, eventId, forceSubstitution }: { date: string; toEmail: string; type: 'daily' | 'monthly' | 'rca'; eventId?: string; forceSubstitution?: boolean }) => {
      const response = await apiRequest("POST", `/api/siae/companies/${companyId}/transmissions/send-c1`, {
        date,
        toEmail,
        type,
        eventId,
        forceSubstitution,
      });
      const data = await response.json();
      if (!response.ok) {
        const error = new Error(data.message || 'Errore invio') as Error & { validation?: any; code?: string };
        error.validation = data.validation;
        error.code = data.code;
        throw error;
      }
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ predicate: (q) => (q.queryKey[0] as string)?.includes('transmissions') || false });
      setIsSendDailySheetOpen(false);
      setIsSendDailyDialogOpen(false);
      setSelectedEventId("");
      triggerHaptic('success');
      const tipoLabel = c1Type === 'monthly' ? 'RCA mensile' : 'RCA giornaliero';
      
      // Show validation success with warnings if present
      const warnings = data.validation?.warnings || [];
      const warningText = warnings.length > 0 ? ` (${warnings.length} avvisi)` : '';
      
      toast({
        title: "Report RCA Inviato",
        description: `Validazione OK. Trasmissione ${tipoLabel} inviata con ${data.transmission?.ticketsCount || 0} biglietti.${warningText} SIAE risponderà con Log.xsi.`,
      });
    },
    onError: (error: Error & { validation?: any; code?: string }) => {
      triggerHaptic('error');
      
      // Check if it's a validation error
      if (error.code === 'VALIDATION_FAILED' && error.validation) {
        const errors = error.validation.errors || [];
        toast({
          title: "Validazione Fallita",
          description: `Il report contiene ${errors.length} errori: ${errors.slice(0, 2).join('; ')}${errors.length > 2 ? '...' : ''}`,
          variant: "destructive",
        });
      } else if (error.message.includes('FIRMA_OBBLIGATORIA') || error.message.includes('BRIDGE_NON_CONNESSO') || error.message.includes('FIRMA_NON_ABILITATA')) {
        // Errori specifici della firma S/MIME - mostra istruzioni chiare
        toast({
          title: "Firma S/MIME Richiesta",
          description: "Per ricevere risposta da SIAE: 1) Avvia l'app desktop Event4U 2) Inserisci la Smart Card SIAE 3) Riprova l'invio",
          variant: "destructive",
        });
      } else {
        toast({
          title: "Errore",
          description: error.message,
          variant: "destructive",
        });
      }
    },
  });

  const confirmReceiptMutation = useMutation({
    mutationFn: async ({ id, receiptProtocol, receiptContent }: { id: string; receiptProtocol: string; receiptContent?: string }) => {
      const response = await apiRequest("POST", `/api/siae/transmissions/${id}/confirm-receipt`, {
        receiptProtocol,
        receiptContent,
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ predicate: (q) => (q.queryKey[0] as string)?.includes('transmissions') || false });
      setIsConfirmReceiptSheetOpen(false);
      setIsDetailSheetOpen(false);
      setReceiptProtocol("");
      setReceiptContent("");
      triggerHaptic('success');
      toast({
        title: "Conferma Registrata",
        description: "La conferma di ricezione SIAE è stata registrata.",
      });
    },
    onError: (error: Error) => {
      triggerHaptic('error');
      toast({
        title: "Errore",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Gmail OAuth authorization (system-wide)
  const authorizeGmailMutation = useMutation({
    mutationFn: async () => {
      const response = await apiRequest("GET", `/api/gmail/auth`);
      return response.json();
    },
    onSuccess: (data) => {
      if (data.authUrl) {
        window.location.href = data.authUrl;
      }
    },
    onError: (error: Error) => {
      triggerHaptic('error');
      toast({
        title: "Errore",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const revokeGmailMutation = useMutation({
    mutationFn: async () => {
      const response = await apiRequest("DELETE", `/api/gmail/revoke`);
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/gmail/status'] });
      triggerHaptic('success');
      toast({
        title: "Gmail Scollegato",
        description: "Gmail è stato disconnesso dal sistema.",
      });
    },
    onError: (error: Error) => {
      triggerHaptic('error');
      toast({
        title: "Errore",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const checkResponsesMutation = useMutation({
    mutationFn: async () => {
      const response = await apiRequest("POST", `/api/siae/transmissions/check-responses?companyId=${companyId}`, {});
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ predicate: (q) => (q.queryKey[0] as string)?.includes('transmissions') || false });
      triggerHaptic('success');
      toast({
        title: "Controllo Completato",
        description: `Trovate ${data.totalEmails} email SIAE, aggiornate ${data.updatedTransmissions} trasmissioni.`,
      });
    },
    onError: (error: Error & { code?: string }) => {
      triggerHaptic('error');
      const isPermissionError = error.message?.includes('permessi') || error.message?.includes('GMAIL_PERMISSION');
      toast({
        title: isPermissionError ? "Lettura Email Non Disponibile" : "Errore",
        description: isPermissionError 
          ? "L'integrazione Gmail attuale non supporta la lettura delle email. Usa la conferma manuale del protocollo SIAE."
          : error.message,
        variant: isPermissionError ? "default" : "destructive",
      });
    },
  });

  // Mutation for saving transmission settings (global singleton)
  const saveSettingsMutation = useMutation({
    mutationFn: async (data: TransmissionSettingsFormValues) => {
      const response = await apiRequest("PUT", `/api/siae/transmission-settings`, data);
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/siae/transmission-settings'] });
      triggerHaptic('success');
      toast({
        title: "Impostazioni Salvate",
        description: "Le impostazioni delle trasmissioni sono state aggiornate.",
      });
    },
    onError: (error: Error) => {
      triggerHaptic('error');
      toast({
        title: "Errore",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Mutation for resending failed transmissions
  const resendTransmissionMutation = useMutation({
    mutationFn: async ({ id, toEmail, forceSubstitution }: { id: string; toEmail: string; forceSubstitution: boolean }) => {
      const response = await apiRequest("POST", `/api/siae/transmissions/${id}/resend`, {
        toEmail,
        forceSubstitution,
      });
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ predicate: (q) => (q.queryKey[0] as string)?.includes('transmissions') || false });
      setIsResendDialogOpen(false);
      setSelectedTransmission(null);
      triggerHaptic('success');
      toast({
        title: "Reinvio Sostitutivo Creato",
        description: `Nuova trasmissione creata con progressivo ${data.transmission?.progressivoInvio || 'N/A'}.`,
      });
    },
    onError: (error: Error) => {
      triggerHaptic('error');
      toast({
        title: "Errore Reinvio",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const getStatusConfig = (status: string) => {
    switch (status) {
      case "sent":
        return { 
          badge: <Badge className="bg-blue-500/20 text-blue-400 border-blue-500/30">Inviata</Badge>,
          icon: Send,
          color: "text-blue-400",
          bgColor: "bg-blue-500/10"
        };
      case "received":
        return { 
          badge: <Badge className="bg-emerald-500/20 text-emerald-400 border-emerald-500/30">Ricevuta</Badge>,
          icon: CheckCircle2,
          color: "text-emerald-400",
          bgColor: "bg-emerald-500/10"
        };
      case "pending":
        return { 
          badge: <Badge className="bg-amber-500/20 text-amber-400 border-amber-500/30">In Attesa</Badge>,
          icon: Clock,
          color: "text-amber-400",
          bgColor: "bg-amber-500/10"
        };
      case "error":
        return { 
          badge: <Badge className="bg-red-500/20 text-red-400 border-red-500/30">Errore</Badge>,
          icon: AlertTriangle,
          color: "text-red-400",
          bgColor: "bg-red-500/10"
        };
      default:
        return { 
          badge: <Badge variant="secondary">{status}</Badge>,
          icon: FileText,
          color: "text-muted-foreground",
          bgColor: "bg-muted/10"
        };
    }
  };

  const getTypeLabel = (type: string) => {
    switch (type) {
      case "daily": return "RMG Giornaliero";
      case "monthly": return "RPM Mensile";
      case "rca": return "RCA Evento";
      case "corrective": return "Correttiva";
      default: return type;
    }
  };

  const getScheduleTypeLabel = (scheduleType: string | null | undefined) => {
    switch (scheduleType) {
      case "manual": return "Manuale";
      case "daily": return "Giornaliero";
      case "end_event": return "Fine Evento";
      case "monthly": return "Mensile";
      default: return "Manuale";
    }
  };

  const onSettingsSubmit = (data: TransmissionSettingsFormValues) => {
    saveSettingsMutation.mutate(data);
  };

  const filteredTransmissions = transmissions?.filter((trans) => {
    const matchesStatus = statusFilter === "all" || trans.status === statusFilter;
    const matchesType = typeFilter === "all" || trans.transmissionType === typeFilter;
    
    // Filtro ricerca: cerca in fileName, transmissionType, status
    const matchesSearch = searchQuery === "" || 
      trans.fileName?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      trans.transmissionType?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      trans.status?.toLowerCase().includes(searchQuery.toLowerCase());
    
    // Filtro per periodo
    let matchesDate = true;
    if (dateFrom || dateTo) {
      const transDate = trans.periodDate ? new Date(trans.periodDate) : null;
      if (transDate) {
        if (dateFrom) {
          const fromDate = new Date(dateFrom);
          fromDate.setHours(0, 0, 0, 0);
          matchesDate = matchesDate && transDate >= fromDate;
        }
        if (dateTo) {
          const toDate = new Date(dateTo);
          toDate.setHours(23, 59, 59, 999);
          matchesDate = matchesDate && transDate <= toDate;
        }
      }
    }
    
    return matchesStatus && matchesType && matchesSearch && matchesDate;
  });

  const stats = {
    total: transmissions?.length || 0,
    pending: transmissions?.filter(t => t.status === "pending").length || 0,
    sent: transmissions?.filter(t => t.status === "sent").length || 0,
    received: transmissions?.filter(t => t.status === "received").length || 0,
    error: transmissions?.filter(t => t.status === "error").length || 0,
    totalTickets: transmissions?.reduce((sum, t) => sum + (t.ticketsCount || 0), 0) || 0,
  };

  const activeFiltersCount = (statusFilter !== "all" ? 1 : 0) + (typeFilter !== "all" ? 1 : 0) + (searchQuery !== "" ? 1 : 0) + (dateFrom !== "" ? 1 : 0) + (dateTo !== "" ? 1 : 0) + (eventFilterId !== "all" ? 1 : 0);
  
  const resetFilters = () => {
    setStatusFilter("all");
    setTypeFilter("all");
    setSearchQuery("");
    setDateFrom("");
    setDateTo("");
    setEventFilterId("all");
  };

  // Desktop version
  if (!isMobile) {
    return (
      <div className="container mx-auto p-6 space-y-6" data-testid="page-siae-transmissions">
        <div className="flex items-center justify-between gap-4">
          <div>
            <h1 className="text-3xl font-bold">Trasmissioni SIAE</h1>
            <p className="text-muted-foreground">Gestione trasmissioni XML verso SIAE</p>
          </div>
          <div className="flex items-center gap-2">
            {isSuperAdmin && (
              <div className="flex items-center gap-2 mr-4">
                <Label className="text-sm text-muted-foreground whitespace-nowrap">
                  <Building2 className="h-4 w-4 inline-block mr-1" />
                  Azienda:
                </Label>
                <Select
                  value={selectedCompanyId || ""}
                  onValueChange={(value) => setSelectedCompanyId(value)}
                >
                  <SelectTrigger className="w-[250px]" data-testid="select-company">
                    <SelectValue placeholder="Seleziona azienda" />
                  </SelectTrigger>
                  <SelectContent>
                    {companies?.map((company) => (
                      <SelectItem key={company.id} value={company.id}>
                        {company.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            )}
            {/* Gmail Authorization Status & Check Responses */}
            {gmailStatus?.authorized ? (
              <div className="flex items-center gap-2">
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button 
                      variant="outline" 
                      onClick={() => checkResponsesMutation.mutate()} 
                      data-testid="button-check-responses" 
                      disabled={checkResponsesMutation.isPending}
                    >
                      {checkResponsesMutation.isPending ? (
                        <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                      ) : (
                        <Mail className="w-4 h-4 mr-2" />
                      )}
                      Controlla Risposte
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent side="bottom" className="max-w-xs text-center">
                    <p>Gmail collegato: {gmailStatus.email}</p>
                    <p className="text-xs text-muted-foreground mt-1">
                      Verifica automaticamente le risposte SIAE.
                    </p>
                  </TooltipContent>
                </Tooltip>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button 
                      variant="ghost" 
                      size="icon"
                      onClick={() => revokeGmailMutation.mutate()} 
                      data-testid="button-revoke-gmail"
                      disabled={revokeGmailMutation.isPending}
                    >
                      <Unlink className="w-4 h-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Scollega Gmail</TooltipContent>
                </Tooltip>
              </div>
            ) : (
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button 
                    variant="outline" 
                    onClick={() => authorizeGmailMutation.mutate()} 
                    data-testid="button-authorize-gmail" 
                    disabled={authorizeGmailMutation.isPending}
                  >
                    {authorizeGmailMutation.isPending ? (
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    ) : (
                      <Link2 className="w-4 h-4 mr-2" />
                    )}
                    Collega Gmail
                  </Button>
                </TooltipTrigger>
                <TooltipContent side="bottom" className="max-w-xs text-center">
                  <p>Collega Gmail per leggere le risposte SIAE automaticamente (connessione di sistema).</p>
                  <p className="text-xs text-muted-foreground mt-1">
                    In alternativa, puoi confermare manualmente il protocollo.
                  </p>
                </TooltipContent>
              </Tooltip>
            )}
            <Button variant="outline" onClick={() => setIsTestEmailDialogOpen(true)} data-testid="button-test-email" disabled={!companyId}>
              <TestTube className="w-4 h-4 mr-2" />
              Test Email
            </Button>
            <Button variant="outline" onClick={() => setIsCreateDialogOpen(true)} data-testid="button-create" disabled={!companyId}>
              <Upload className="w-4 h-4 mr-2" />
              Genera XML
            </Button>
            <Button onClick={() => setIsSendDailyDialogOpen(true)} data-testid="button-send-c1" disabled={!companyId}>
              <Zap className="w-4 h-4 mr-2" />
              Invia Trasmissione C1
            </Button>
          </div>
        </div>

        {/* Global Transmission Settings - Always visible */}
        <Collapsible open={isSettingsOpen} onOpenChange={setIsSettingsOpen}>
          <Card>
            <CardHeader className="pb-2">
              <CollapsibleTrigger className="flex items-center justify-between w-full" data-testid="button-toggle-settings">
                <div className="flex items-center gap-2">
                  <Settings className="h-5 w-5 text-muted-foreground" />
                  <CardTitle className="text-lg">Impostazioni Trasmissioni Globali</CardTitle>
                  <Badge variant="outline" className="text-xs">Tutte le aziende</Badge>
                </div>
                <ChevronDown className={`h-5 w-5 text-muted-foreground transition-transform ${isSettingsOpen ? 'rotate-180' : ''}`} />
              </CollapsibleTrigger>
            </CardHeader>
            <CollapsibleContent>
              <CardContent>
                {isLoadingSettings ? (
                  <div className="space-y-4">
                    <Skeleton className="h-8 w-full" />
                    <Skeleton className="h-8 w-full" />
                  </div>
                ) : (
                  <Form {...settingsForm}>
                    <form onSubmit={settingsForm.handleSubmit(onSettingsSubmit)} className="space-y-6">
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        {/* RMG Giornaliero Settings */}
                        <div className="space-y-4 p-4 rounded-lg border bg-blue-500/5">
                          <div className="flex items-center gap-2">
                            <Clock className="h-4 w-4 text-blue-500" />
                            <h4 className="font-medium text-sm">RMG - Giornaliero</h4>
                          </div>
                          <p className="text-xs text-muted-foreground">
                            Trasmissione automatica per eventi conclusi (DataRiepilogo: AAAAMMGG)
                          </p>
                          <FormField
                            control={settingsForm.control}
                            name="dailyEnabled"
                            render={({ field }) => (
                              <FormItem className="flex flex-row items-center justify-between">
                                <FormLabel className="text-sm">Abilitato</FormLabel>
                                <FormControl>
                                  <Checkbox
                                    checked={field.value}
                                    onCheckedChange={field.onChange}
                                    data-testid="checkbox-daily-enabled"
                                  />
                                </FormControl>
                              </FormItem>
                            )}
                          />
                          <div className="grid grid-cols-2 gap-4">
                            <FormField
                              control={settingsForm.control}
                              name="endEventEnabled"
                              render={({ field }) => (
                                <FormItem className="flex flex-row items-center justify-between">
                                  <FormLabel className="text-sm">Fine Evento</FormLabel>
                                  <FormControl>
                                    <Checkbox
                                      checked={field.value}
                                      onCheckedChange={field.onChange}
                                      data-testid="checkbox-end-event-enabled"
                                    />
                                  </FormControl>
                                </FormItem>
                              )}
                            />
                            <FormField
                              control={settingsForm.control}
                              name="endEventDelayDays"
                              render={({ field }) => (
                                <FormItem>
                                  <FormLabel className="text-sm">Ritardo (giorni)</FormLabel>
                                  <FormControl>
                                    <Input
                                      type="number"
                                      min={1}
                                      max={30}
                                      {...field}
                                      onChange={(e) => field.onChange(parseInt(e.target.value) || 5)}
                                      data-testid="input-end-event-delay"
                                    />
                                  </FormControl>
                                </FormItem>
                              )}
                            />
                          </div>
                          <div className="grid grid-cols-2 gap-4">
                            <FormField
                              control={settingsForm.control}
                              name="dailyIntervalDays"
                              render={({ field }) => (
                                <FormItem>
                                  <FormLabel className="text-sm">Intervallo batch (giorni)</FormLabel>
                                  <FormControl>
                                    <Input
                                      type="number"
                                      min={1}
                                      max={30}
                                      {...field}
                                      onChange={(e) => field.onChange(parseInt(e.target.value) || 5)}
                                      data-testid="input-daily-interval"
                                    />
                                  </FormControl>
                                </FormItem>
                              )}
                            />
                          </div>
                        </div>

                        {/* RPM Mensile Settings */}
                        <div className="space-y-4 p-4 rounded-lg border bg-amber-500/5">
                          <div className="flex items-center gap-2">
                            <Calendar className="h-4 w-4 text-amber-500" />
                            <h4 className="font-medium text-sm">RPM - Mensile</h4>
                          </div>
                          <p className="text-xs text-muted-foreground">
                            Trasmissione mensile aggregata (DataRiepilogo: AAAAMM01)
                          </p>
                          <FormField
                            control={settingsForm.control}
                            name="monthlyEnabled"
                            render={({ field }) => (
                              <FormItem className="flex flex-row items-center justify-between">
                                <FormLabel className="text-sm">Abilitato</FormLabel>
                                <FormControl>
                                  <Checkbox
                                    checked={field.value}
                                    onCheckedChange={field.onChange}
                                    data-testid="checkbox-monthly-enabled"
                                  />
                                </FormControl>
                              </FormItem>
                            )}
                          />
                          <FormField
                            control={settingsForm.control}
                            name="monthlyDelayDays"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel className="text-sm">Ritardo (giorni)</FormLabel>
                                <FormControl>
                                  <Input
                                    type="number"
                                    min={1}
                                    max={30}
                                    {...field}
                                    onChange={(e) => field.onChange(parseInt(e.target.value) || 5)}
                                    data-testid="input-monthly-delay"
                                  />
                                </FormControl>
                              </FormItem>
                            )}
                          />
                          <FormField
                            control={settingsForm.control}
                            name="monthlyRecurringDay"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel className="text-sm">Giorno del mese</FormLabel>
                                <FormControl>
                                  <Input
                                    type="number"
                                    min={1}
                                    max={28}
                                    {...field}
                                    onChange={(e) => field.onChange(parseInt(e.target.value) || 1)}
                                    data-testid="input-monthly-day"
                                  />
                                </FormControl>
                              </FormItem>
                            )}
                          />
                        </div>
                      </div>

                      {/* Auto-send toggle */}
                      <div className="flex items-center justify-between p-4 rounded-lg border bg-muted/50">
                        <div>
                          <h4 className="font-medium">Invio Automatico</h4>
                          <p className="text-sm text-muted-foreground">Invia automaticamente le trasmissioni generate</p>
                        </div>
                        <FormField
                          control={settingsForm.control}
                          name="autoSendEnabled"
                          render={({ field }) => (
                            <FormItem>
                              <FormControl>
                                <Checkbox
                                  checked={field.value}
                                  onCheckedChange={field.onChange}
                                  data-testid="checkbox-auto-send"
                                />
                              </FormControl>
                            </FormItem>
                          )}
                        />
                      </div>

                      <div className="flex justify-end gap-2">
                        <Button
                          type="button"
                          variant="outline"
                          onClick={() => settingsForm.reset()}
                          data-testid="button-reset-settings"
                        >
                          <RotateCcw className="w-4 h-4 mr-2" />
                          Ripristina
                        </Button>
                        <Button
                          type="submit"
                          disabled={saveSettingsMutation.isPending}
                          data-testid="button-save-settings"
                        >
                          {saveSettingsMutation.isPending && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                          <Save className="w-4 h-4 mr-2" />
                          Salva Impostazioni
                        </Button>
                      </div>
                    </form>
                  </Form>
                )}
              </CardContent>
            </CollapsibleContent>
          </Card>
        </Collapsible>

        {!companyId && isSuperAdmin && (
          <Card className="border-dashed">
            <CardContent className="pt-6 text-center py-12">
              <Building2 className="h-12 w-12 mx-auto text-muted-foreground/50 mb-4" />
              <h3 className="text-lg font-medium mb-2">Seleziona un'azienda</h3>
              <p className="text-muted-foreground">
                Scegli un'azienda dal menu sopra per visualizzare le trasmissioni SIAE
              </p>
            </CardContent>
          </Card>
        )}

        {companyId && (
        <>
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-5 gap-4">
          <Card>
            <CardContent className="pt-6">
              <div className="text-2xl font-bold">{stats.total}</div>
              <p className="text-sm text-muted-foreground">Totale</p>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="pt-6">
              <div className="text-2xl font-bold text-amber-500">{stats.pending}</div>
              <p className="text-sm text-muted-foreground">In Attesa</p>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="pt-6">
              <div className="text-2xl font-bold text-blue-500">{stats.sent}</div>
              <p className="text-sm text-muted-foreground">Inviate</p>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="pt-6">
              <div className="text-2xl font-bold text-green-500">{stats.received}</div>
              <p className="text-sm text-muted-foreground">Ricevute</p>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="pt-6">
              <div className="text-2xl font-bold text-red-500">{stats.error}</div>
              <p className="text-sm text-muted-foreground">Errori</p>
            </CardContent>
          </Card>
        </div>

        <Card>
          <CardHeader>
            <div className="flex flex-col gap-4">
              <div className="flex items-center justify-between">
                <CardTitle>Elenco Trasmissioni</CardTitle>
                {activeFiltersCount > 0 && (
                  <Button variant="ghost" size="sm" onClick={resetFilters} data-testid="button-reset-filters">
                    <X className="h-4 w-4 mr-1" />
                    Resetta filtri ({activeFiltersCount})
                  </Button>
                )}
              </div>
              <div className="flex flex-wrap items-center gap-3">
                <div className="relative flex-1 min-w-[200px] max-w-[300px]">
                  <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="Cerca trasmissione..."
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    className="pl-9"
                    data-testid="input-search"
                  />
                </div>
                <div className="flex items-center gap-2">
                  <Calendar className="h-4 w-4 text-muted-foreground" />
                  <Input
                    type="date"
                    value={dateFrom}
                    onChange={(e) => setDateFrom(e.target.value)}
                    className="w-[140px]"
                    placeholder="Da"
                    data-testid="input-date-from"
                  />
                  <span className="text-muted-foreground">-</span>
                  <Input
                    type="date"
                    value={dateTo}
                    onChange={(e) => setDateTo(e.target.value)}
                    className="w-[140px]"
                    placeholder="A"
                    data-testid="input-date-to"
                  />
                </div>
                <Select value={statusFilter} onValueChange={setStatusFilter}>
                  <SelectTrigger className="w-[150px]" data-testid="select-status-filter">
                    <SelectValue placeholder="Stato" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">Tutti gli stati</SelectItem>
                    <SelectItem value="pending">In Attesa</SelectItem>
                    <SelectItem value="sent">Inviata</SelectItem>
                    <SelectItem value="received">Ricevuta</SelectItem>
                    <SelectItem value="error">Errore</SelectItem>
                  </SelectContent>
                </Select>
                <Select value={typeFilter} onValueChange={setTypeFilter}>
                  <SelectTrigger className="w-[150px]" data-testid="select-type-filter">
                    <SelectValue placeholder="Tipo" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">Tutti i tipi</SelectItem>
                    <SelectItem value="daily">Giornaliera</SelectItem>
                    <SelectItem value="monthly">Mensile</SelectItem>
                    <SelectItem value="corrective">Correttiva</SelectItem>
                  </SelectContent>
                </Select>
                <Select value={eventFilterId} onValueChange={setEventFilterId}>
                  <SelectTrigger className="w-[200px]" data-testid="select-event-filter">
                    <SelectValue placeholder="Filtra per evento" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">Tutti gli eventi</SelectItem>
                    {eventsForDropdown?.map((event) => (
                      <SelectItem key={event.id} value={event.id}>
                        {event.eventName}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            {isLoading ? (
              <div className="space-y-2">
                {[1, 2, 3].map(i => <Skeleton key={i} className="h-12 w-full" />)}
              </div>
            ) : filteredTransmissions && filteredTransmissions.length > 0 ? (
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Data</TableHead>
                    <TableHead>Evento</TableHead>
                    <TableHead>Tipo</TableHead>
                    <TableHead>Tipo Invio</TableHead>
                    <TableHead>Prog.</TableHead>
                    <TableHead>Sost.</TableHead>
                    <TableHead>Biglietti</TableHead>
                    <TableHead>Importo</TableHead>
                    <TableHead>Stato</TableHead>
                    <TableHead>Protocollo</TableHead>
                    <TableHead className="text-right">Azioni</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {filteredTransmissions.map((trans) => {
                    const statusConfig = getStatusConfig(trans.status);
                    return (
                      <TableRow key={trans.id} data-testid={`row-transmission-${trans.id}`}>
                        <TableCell>
                          {trans.periodDate && format(new Date(trans.periodDate), "dd/MM/yyyy", { locale: it })}
                        </TableCell>
                        <TableCell className="max-w-[150px] truncate" title={trans.eventName || (trans.transmissionType === 'monthly' ? 'Riepilogo mensile' : '-')} data-testid={`text-event-${trans.id}`}>
                          {trans.eventName || (trans.transmissionType === 'monthly' ? (
                            <span className="text-muted-foreground italic">Tutti gli eventi</span>
                          ) : '-')}
                        </TableCell>
                        <TableCell>{getTypeLabel(trans.transmissionType)}</TableCell>
                        <TableCell data-testid={`text-schedule-type-${trans.id}`}>
                          <Badge variant="outline" className="text-xs">
                            {getScheduleTypeLabel(trans.scheduleType)}
                          </Badge>
                        </TableCell>
                        <TableCell data-testid={`text-progressivo-${trans.id}`}>
                          {trans.progressivoInvio ? (
                            <Badge className={`text-xs ${trans.progressivoInvio > 1 ? 'bg-amber-500 text-black' : 'bg-blue-500 text-white'}`}>
                              {trans.progressivoInvio}
                            </Badge>
                          ) : '-'}
                        </TableCell>
                        <TableCell data-testid={`text-substitution-${trans.id}`}>
                          {trans.isSubstitution && (
                            <Badge variant="destructive" className="text-xs" data-testid={`badge-substitution-${trans.id}`}>
                              S
                            </Badge>
                          )}
                        </TableCell>
                        <TableCell>{trans.ticketsCount}</TableCell>
                        <TableCell>€{Number(trans.totalAmount || 0).toFixed(2)}</TableCell>
                        <TableCell>
                          <div className="flex items-center gap-2">
                            {statusConfig.badge}
                            {trans.sentAt && (
                              trans.smimeSigned ? (
                                <span title={`Email firmata S/MIME da ${trans.smimeSignerEmail || 'N/A'}`}>
                                  <ShieldCheck className="w-4 h-4 text-green-500" />
                                </span>
                              ) : (
                                <span title="Email NON firmata S/MIME - SIAE potrebbe non rispondere">
                                  <ShieldAlert className="w-4 h-4 text-amber-500" />
                                </span>
                              )
                            )}
                          </div>
                        </TableCell>
                        <TableCell className="font-mono text-sm">
                          {trans.receiptProtocol || "-"}
                        </TableCell>
                        <TableCell className="text-right">
                          <div className="flex justify-end gap-1">
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => {
                                setSelectedTransmission(trans);
                                setIsDetailDialogOpen(true);
                              }}
                            >
                              <Eye className="w-4 h-4" />
                            </Button>
                            {trans.fileContent && (
                              <Button variant="ghost" size="sm">
                                <Download className="w-4 h-4" />
                              </Button>
                            )}
                            {trans.status === "pending" && trans.fileContent && (
                              <Button
                                size="sm"
                                onClick={() => {
                                  sendEmailMutation.mutate({
                                    id: trans.id,
                                    toEmail: "servertest2@batest.siae.it",
                                  });
                                }}
                                disabled={sendEmailMutation.isPending}
                              >
                                <Mail className="w-4 h-4 mr-1" />
                                Invia
                              </Button>
                            )}
                            {trans.status === "sent" && (
                              <Button
                                size="sm"
                                variant="outline"
                                onClick={() => {
                                  setSelectedTransmission(trans);
                                  setIsConfirmReceiptDialogOpen(true);
                                }}
                              >
                                <CheckCircle2 className="w-4 h-4 mr-1" />
                                Conferma
                              </Button>
                            )}
                            {(trans.status === "error" || trans.status === "rejected") && (
                              <Button
                                size="sm"
                                variant="destructive"
                                onClick={() => {
                                  setSelectedTransmission(trans);
                                  setIsResendDialogOpen(true);
                                }}
                                data-testid={`button-resend-${trans.id}`}
                              >
                                <RotateCcw className="w-4 h-4 mr-1" />
                                Reinvia
                              </Button>
                            )}
                          </div>
                        </TableCell>
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>
            ) : (
              <div className="text-center py-8 text-muted-foreground">
                <FileText className="w-12 h-12 mx-auto mb-4 opacity-50" />
                <p>Nessuna trasmissione trovata</p>
              </div>
            )}
          </CardContent>
        </Card>

        <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Genera Trasmissione XML</DialogTitle>
              <DialogDescription>Crea un nuovo file XML per la trasmissione SIAE</DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              <div>
                <Label>Tipo Trasmissione</Label>
                <Select value={transmissionType} onValueChange={setTransmissionType}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="daily">Giornaliera</SelectItem>
                    <SelectItem value="monthly">Mensile</SelectItem>
                    <SelectItem value="corrective">Correttiva</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div>
                <Label>Data Periodo</Label>
                <Input type="date" value={periodDate} onChange={(e) => setPeriodDate(e.target.value)} />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsCreateDialogOpen(false)}>Annulla</Button>
              <Button
                onClick={() => {
                  createTransmissionMutation.mutate({ transmissionType, periodDate });
                  setIsCreateDialogOpen(false);
                }}
                disabled={!periodDate || createTransmissionMutation.isPending}
              >
                {createTransmissionMutation.isPending && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                Genera XML
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

        <Dialog open={isSendDailyDialogOpen} onOpenChange={setIsSendDailyDialogOpen}>
          <DialogContent className="max-w-lg">
            <DialogHeader>
              <DialogTitle>Trasmissione Report SIAE</DialogTitle>
              <DialogDescription>Seleziona il tipo di report da generare e inviare</DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              <div>
                <Label>Frequenza Trasmissione</Label>
                <Select value={c1Type} onValueChange={(v: 'daily' | 'monthly' | 'rca') => { setC1Type(v); }}>
                  <SelectTrigger data-testid="select-c1-type">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="daily">
                      <div className="flex flex-col items-start">
                        <span className="font-medium">RMG - Giornaliero</span>
                        <span className="text-xs text-muted-foreground">Riepilogo Mensile Giornaliero (C1)</span>
                      </div>
                    </SelectItem>
                    <SelectItem value="monthly">
                      <div className="flex flex-col items-start">
                        <span className="font-medium">RPM - Mensile</span>
                        <span className="text-xs text-muted-foreground">Riepilogo Periodico Mensile (C1)</span>
                      </div>
                    </SelectItem>
                    <SelectItem value="rca">
                      <div className="flex flex-col items-start">
                        <span className="font-medium">RCA - Controllo Accessi</span>
                        <span className="text-xs text-muted-foreground">Riepilogo Controllo Accessi evento</span>
                      </div>
                    </SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              {/* Info box con spiegazione tipo report */}
              <div className={`p-3 rounded-lg border ${
                c1Type === 'monthly' ? 'bg-amber-500/10 border-amber-500/30' : 
                c1Type === 'rca' ? 'bg-green-500/10 border-green-500/30' :
                'bg-blue-500/10 border-blue-500/30'
              }`}>
                {c1Type === 'monthly' ? (
                  <div className="space-y-2">
                    <div className="flex items-center gap-2 text-amber-600 dark:text-amber-400">
                      <Calendar className="w-4 h-4" />
                      <span className="font-medium text-sm">RPM - Mensile</span>
                    </div>
                    <p className="text-xs text-muted-foreground">
                      Riepilogo Controllo Accessi con DataRiepilogo impostata al mese selezionato.
                      Conforme ad Allegato B - Provvedimento 04/03/2008.
                    </p>
                  </div>
                ) : c1Type === 'rca' ? (
                  <div className="space-y-2">
                    <div className="flex items-center gap-2 text-green-600 dark:text-green-400">
                      <Ticket className="w-4 h-4" />
                      <span className="font-medium text-sm">RCA - Controllo Accessi</span>
                    </div>
                    <p className="text-xs text-muted-foreground">
                      Report specifico per evento con dati biglietteria e accessi.
                      Conforme ad Allegato B - Provvedimento 04/03/2008.
                    </p>
                  </div>
                ) : (
                  <div className="space-y-2">
                    <div className="flex items-center gap-2 text-blue-600 dark:text-blue-400">
                      <Clock className="w-4 h-4" />
                      <span className="font-medium text-sm">RMG - Giornaliero</span>
                    </div>
                    <p className="text-xs text-muted-foreground">
                      Riepilogo Controllo Accessi con DataRiepilogo impostata alla data evento.
                      Conforme ad Allegato B - Provvedimento 04/03/2008.
                    </p>
                  </div>
                )}
              </div>
              
              {/* Selezione evento - richiesto per RCA, opzionale per RMG/RPM */}
              <div>
                <Label>Evento {c1Type === 'rca' && <span className="text-destructive">*</span>}</Label>
                <Select value={selectedEventId} onValueChange={setSelectedEventId}>
                  <SelectTrigger data-testid="select-rca-event" className={c1Type === 'rca' && !selectedEventId ? 'border-destructive' : ''}>
                    <SelectValue placeholder={c1Type === 'rca' ? "Seleziona un evento concluso..." : "Seleziona un evento..."} />
                  </SelectTrigger>
                  <SelectContent>
                    {/* FIX 2026-01-18: Per RMG/RPM usa eventsForDaily (include ongoing), per RCA usa eventsForRCA (solo closed) */}
                    {(c1Type === 'rca' ? eventsForRCA : eventsForDaily).length === 0 ? (
                      <SelectItem value="none" disabled>
                        {c1Type === 'rca' ? 'Nessun evento concluso disponibile' : 'Nessun evento disponibile'}
                      </SelectItem>
                    ) : (
                      (c1Type === 'rca' ? eventsForRCA : eventsForDaily).map((event) => (
                        <SelectItem key={event.id} value={event.id}>
                          <div className="flex flex-col items-start">
                            <span className="font-medium">{event.eventName}</span>
                            <span className="text-xs text-muted-foreground">
                              {format(new Date(event.eventDate), "d MMMM yyyy", { locale: it })}
                              {event.status === 'ongoing' && ' (in corso)'}
                              {event.status === 'scheduled' && ' (programmato)'}
                              {event.status === 'closed' && ' (concluso)'}
                            </span>
                          </div>
                        </SelectItem>
                      ))
                    )}
                  </SelectContent>
                </Select>
                {c1Type === 'rca' && !selectedEventId && (
                  <p className="text-xs text-destructive mt-1">
                    Seleziona un evento per inviare il report RCA
                  </p>
                )}
                {c1Type === 'rca' && selectedEventId && (
                  <p className="text-xs text-muted-foreground mt-1">
                    Solo eventi già conclusi possono essere trasmessi per RCA
                  </p>
                )}
                {c1Type !== 'rca' && (
                  <p className="text-xs text-muted-foreground mt-1">
                    Per RMG/RPM puoi selezionare anche eventi in corso
                  </p>
                )}
              </div>
              
              {/* Checklist Validazione Prerequisiti SIAE */}
              {c1Type === 'rca' && selectedEventId && (
                <div className="p-3 rounded-lg border">
                  {isLoadingPrerequisites ? (
                    <div className="flex items-center gap-2 text-muted-foreground">
                      <Loader2 className="w-4 h-4 animate-spin" />
                      <span className="text-sm">Verifica prerequisiti...</span>
                    </div>
                  ) : prerequisiteValidation ? (
                    <div className="space-y-3">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          {prerequisiteValidation.isReady ? (
                            <CheckCircle2 className="w-5 h-5 text-green-500" />
                          ) : (
                            <AlertTriangle className="w-5 h-5 text-amber-500" />
                          )}
                          <span className="font-medium text-sm">
                            {prerequisiteValidation.isReady ? 'Pronto per trasmissione' : 'Verifica richiesta'}
                          </span>
                        </div>
                        <Badge variant={prerequisiteValidation.score >= 80 ? 'default' : prerequisiteValidation.score >= 50 ? 'secondary' : 'destructive'}>
                          {prerequisiteValidation.score}%
                        </Badge>
                      </div>
                      
                      {/* Errori bloccanti */}
                      {prerequisiteValidation.errors.length > 0 && (
                        <div className="space-y-2">
                          <p className="text-xs font-medium text-destructive">Errori bloccanti:</p>
                          {prerequisiteValidation.errors.map((err, idx) => (
                            <div key={idx} className="text-xs p-2 bg-destructive/10 rounded border border-destructive/20">
                              <p className="font-medium">{err.message}</p>
                              <p className="text-muted-foreground mt-1">{err.resolution}</p>
                              {err.siaeErrorCode && (
                                <Badge variant="outline" className="mt-1 text-[10px]">
                                  Errore SIAE: {err.siaeErrorCode}
                                </Badge>
                              )}
                            </div>
                          ))}
                        </div>
                      )}
                      
                      {/* Warning */}
                      {prerequisiteValidation.warnings.length > 0 && (
                        <div className="space-y-2">
                          <p className="text-xs font-medium text-amber-600">Avvisi:</p>
                          {prerequisiteValidation.warnings.slice(0, 3).map((warn, idx) => (
                            <div key={idx} className="text-xs p-2 bg-amber-50 dark:bg-amber-950/30 rounded border border-amber-200 dark:border-amber-800">
                              <p>{warn.message}</p>
                              <p className="text-muted-foreground mt-1">{warn.suggestion}</p>
                            </div>
                          ))}
                          {prerequisiteValidation.warnings.length > 3 && (
                            <p className="text-xs text-muted-foreground">
                              +{prerequisiteValidation.warnings.length - 3} altri avvisi
                            </p>
                          )}
                        </div>
                      )}
                      
                      {/* Checklist compatta */}
                      {prerequisiteValidation.isReady && prerequisiteValidation.errors.length === 0 && (
                        <Collapsible>
                          <CollapsibleTrigger asChild>
                            <Button variant="ghost" size="sm" className="w-full justify-between text-xs h-7">
                              Mostra checklist completa
                              <ChevronDown className="w-3 h-3" />
                            </Button>
                          </CollapsibleTrigger>
                          <CollapsibleContent>
                            <div className="grid grid-cols-2 gap-1 mt-2">
                              {prerequisiteValidation.checklist.map((item, idx) => (
                                <div key={idx} className="flex items-center gap-1 text-[10px]">
                                  {item.status === 'ok' ? (
                                    <CheckCircle2 className="w-3 h-3 text-green-500" />
                                  ) : item.status === 'warning' ? (
                                    <AlertTriangle className="w-3 h-3 text-amber-500" />
                                  ) : (
                                    <X className="w-3 h-3 text-destructive" />
                                  )}
                                  <span className="truncate">{item.label}</span>
                                </div>
                              ))}
                            </div>
                          </CollapsibleContent>
                        </Collapsible>
                      )}
                    </div>
                  ) : null}
                </div>
              )}
              
              {/* Data/Mese di riferimento per il riepilogo */}
              <div>
                <Label>{c1Type === 'monthly' ? 'Mese di riferimento' : c1Type === 'rca' ? 'Data Evento' : 'Data Riepilogo'}</Label>
                <Input 
                  type={c1Type === 'monthly' ? 'month' : 'date'} 
                  value={dailyDate} 
                  onChange={(e) => setDailyDate(e.target.value)} 
                  data-testid="input-c1-date"
                />
                <p className="text-xs text-muted-foreground mt-1">
                  {c1Type === 'monthly' 
                    ? 'Verrà usato come DataRiepilogo nel formato AAAAMM01' 
                    : c1Type === 'rca'
                    ? 'Data dell\'evento per il report RCA'
                    : 'Verrà usato come DataRiepilogo nel formato AAAAMMGG'}
                </p>
              </div>
              
              <div>
                <Label>Email Destinatario SIAE</Label>
                <Input type="email" value={dailyEmail} onChange={(e) => setDailyEmail(e.target.value)} data-testid="input-c1-email" />
              </div>
              
              {/* Checkbox Forza Sostituzione per errore 40604 */}
              <div className="flex items-start space-x-3 p-3 bg-amber-50 dark:bg-amber-950/30 rounded-lg border border-amber-200 dark:border-amber-800">
                <Checkbox
                  id="forceSubstitution"
                  checked={forceSubstitution}
                  onCheckedChange={(checked) => setForceSubstitution(checked === true)}
                  data-testid="checkbox-force-substitution"
                  className="mt-0.5"
                />
                <div className="flex-1">
                  <Label htmlFor="forceSubstitution" className="text-sm font-medium cursor-pointer">
                    Forza Sostituzione (Sostituzione="S")
                  </Label>
                  <p className="text-xs text-muted-foreground">
                    Usa per reinviare un report già elaborato (errore 40604)
                  </p>
                </div>
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsSendDailyDialogOpen(false)}>Annulla</Button>
              <Button
                onClick={() => {
                  sendC1Mutation.mutate({ 
                    date: dailyDate, 
                    toEmail: dailyEmail, 
                    type: c1Type,
                    eventId: selectedEventId,
                    forceSubstitution
                  });
                }}
                disabled={
                  (c1Type === 'rca' && !selectedEventId) || 
                  (c1Type === 'rca' && prerequisiteValidation && !prerequisiteValidation.isReady) ||
                  !dailyDate || 
                  !dailyEmail || 
                  sendC1Mutation.isPending
                }
                data-testid="button-send-c1-submit"
              >
                {sendC1Mutation.isPending && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                {c1Type === 'monthly' ? 'Invia RPM Mensile' : c1Type === 'rca' ? 'Invia RCA Evento' : 'Invia RMG Giornaliero'}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

        <Dialog open={isTestEmailDialogOpen} onOpenChange={setIsTestEmailDialogOpen}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Test Invio Email</DialogTitle>
              <DialogDescription>Verifica la configurazione email SIAE</DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              <div>
                <Label>Email Destinatario</Label>
                <Input type="email" value={testEmail} onChange={(e) => setTestEmail(e.target.value)} />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsTestEmailDialogOpen(false)}>Annulla</Button>
              <Button
                onClick={() => {
                  testEmailMutation.mutate(testEmail);
                  setIsTestEmailDialogOpen(false);
                }}
                disabled={!testEmail || testEmailMutation.isPending}
              >
                {testEmailMutation.isPending && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                Invia Test
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

        <Dialog open={isConfirmReceiptDialogOpen} onOpenChange={setIsConfirmReceiptDialogOpen}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Conferma Ricezione SIAE</DialogTitle>
              <DialogDescription>Carica il file di risposta SIAE o inserisci manualmente i dati</DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              {/* Upload file di risposta SIAE */}
              <div className="p-3 bg-muted/50 rounded-lg border border-dashed">
                <Label className="text-sm font-medium mb-2 block">Carica File Risposta SIAE</Label>
                <Input
                  type="file"
                  accept=".txt,.text"
                  data-testid="input-upload-siae-response"
                  onChange={async (e) => {
                    const file = e.target.files?.[0];
                    if (!file) return;
                    
                    const content = await file.text();
                    try {
                      const response = await fetch('/api/siae/parse-response', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ 
                          content,
                          transmissionId: selectedTransmission?.id 
                        }),
                      });
                      
                      if (response.ok) {
                        const data = await response.json();
                        const parsed = data.parsed;
                        
                        if (parsed.type === 'ERRORE') {
                          setReceiptContent(`Errore ${parsed.code}: ${parsed.description}${parsed.detail ? ` - ${parsed.detail}` : ''}`);
                          setReceiptProtocol(`ERR-${parsed.code}`);
                          toast({
                            title: "Risposta SIAE: ERRORE",
                            description: `Codice ${parsed.code}: ${parsed.description}`,
                            variant: "destructive",
                          });
                        } else if (parsed.type === 'OK' && parsed.protocolNumber) {
                          setReceiptProtocol(parsed.protocolNumber);
                          setReceiptContent("Trasmissione confermata da SIAE");
                          toast({
                            title: "Risposta SIAE: OK",
                            description: `Protocollo: ${parsed.protocolNumber}`,
                          });
                        } else {
                          setReceiptContent(content.substring(0, 500));
                          toast({
                            title: "File parsato",
                            description: "Contenuto estratto, verifica i dati",
                          });
                        }
                      }
                    } catch (err) {
                      toast({
                        title: "Errore parsing",
                        description: "Impossibile parsare il file di risposta",
                        variant: "destructive",
                      });
                    }
                  }}
                />
                <p className="text-xs text-muted-foreground mt-1">
                  Carica il file .txt ricevuto da SIAE per estrarre automaticamente codice/protocollo
                </p>
              </div>
              
              <div className="relative">
                <div className="absolute inset-0 flex items-center">
                  <span className="w-full border-t" />
                </div>
                <div className="relative flex justify-center text-xs uppercase">
                  <span className="bg-background px-2 text-muted-foreground">oppure inserisci manualmente</span>
                </div>
              </div>
              
              <div>
                <Label>Protocollo / Codice Errore *</Label>
                <Input
                  value={receiptProtocol}
                  onChange={(e) => setReceiptProtocol(e.target.value)}
                  placeholder="Es: SIAE-2025-001234 o ERR-40604"
                  data-testid="input-receipt-protocol"
                />
              </div>
              <div>
                <Label>Contenuto Ricevuta / Dettagli</Label>
                <Input
                  value={receiptContent}
                  onChange={(e) => setReceiptContent(e.target.value)}
                  placeholder="Note, descrizione errore o riferimenti"
                  data-testid="input-receipt-content"
                />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => {
                setIsConfirmReceiptDialogOpen(false);
                setReceiptProtocol("");
                setReceiptContent("");
              }}>Annulla</Button>
              <Button
                onClick={() => {
                  if (selectedTransmission) {
                    confirmReceiptMutation.mutate({
                      id: selectedTransmission.id,
                      receiptProtocol,
                      receiptContent: receiptContent || undefined,
                    });
                    setIsConfirmReceiptDialogOpen(false);
                  }
                }}
                disabled={!receiptProtocol || confirmReceiptMutation.isPending}
              >
                {confirmReceiptMutation.isPending && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                Conferma Ricezione
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

        <Dialog open={isDetailDialogOpen} onOpenChange={setIsDetailDialogOpen}>
          <DialogContent className="max-w-2xl">
            <DialogHeader>
              <DialogTitle>Dettaglio Trasmissione</DialogTitle>
            </DialogHeader>
            {selectedTransmission && (
              <div className="space-y-4">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <Label className="text-muted-foreground">Tipo</Label>
                    <p className="font-medium">{getTypeLabel(selectedTransmission.transmissionType)}</p>
                  </div>
                  <div>
                    <Label className="text-muted-foreground">Data Periodo</Label>
                    <p className="font-medium">
                      {selectedTransmission.periodDate && format(new Date(selectedTransmission.periodDate), "dd/MM/yyyy", { locale: it })}
                    </p>
                  </div>
                  <div>
                    <Label className="text-muted-foreground">Biglietti</Label>
                    <p className="font-medium">{selectedTransmission.ticketsCount}</p>
                  </div>
                  <div>
                    <Label className="text-muted-foreground">Importo Totale</Label>
                    <p className="font-medium">€{Number(selectedTransmission.totalAmount || 0).toFixed(2)}</p>
                  </div>
                  <div>
                    <Label className="text-muted-foreground">Stato</Label>
                    <div className="mt-1">{getStatusConfig(selectedTransmission.status).badge}</div>
                  </div>
                  {selectedTransmission.receiptProtocol && (
                    <div>
                      <Label className="text-muted-foreground">Protocollo SIAE</Label>
                      <p className="font-mono text-green-600">{selectedTransmission.receiptProtocol}</p>
                    </div>
                  )}
                  {selectedTransmission.sentAt && (
                    <div>
                      <Label className="text-muted-foreground">Data Invio</Label>
                      <p className="font-medium">{format(new Date(selectedTransmission.sentAt), "dd/MM/yyyy HH:mm", { locale: it })}</p>
                    </div>
                  )}
                  {selectedTransmission.sentAt && (
                    <div>
                      <Label className="text-muted-foreground">Firma S/MIME</Label>
                      {selectedTransmission.smimeSigned ? (
                        <div className="flex items-center gap-2 text-green-600 dark:text-green-400">
                          <ShieldCheck className="w-4 h-4" />
                          <span className="font-medium truncate">{selectedTransmission.smimeSignerEmail || 'Firmata'}</span>
                        </div>
                      ) : (
                        <div className="flex items-center gap-2 text-amber-600 dark:text-amber-400">
                          <ShieldAlert className="w-4 h-4" />
                          <span className="font-medium">Non firmata</span>
                        </div>
                      )}
                    </div>
                  )}
                  {selectedTransmission.receivedAt && (
                    <div>
                      <Label className="text-muted-foreground">Data Ricezione</Label>
                      <p className="font-medium">{format(new Date(selectedTransmission.receivedAt), "dd/MM/yyyy HH:mm", { locale: it })}</p>
                    </div>
                  )}
                </div>
                {selectedTransmission.errorMessage && (
                  <div className="bg-red-50 dark:bg-red-950 p-4 rounded-lg">
                    <Label className="text-red-600">Messaggio Errore</Label>
                    <p className="text-red-700 dark:text-red-400">{selectedTransmission.errorMessage}</p>
                  </div>
                )}
              </div>
            )}
            <DialogFooter>
              {selectedTransmission?.status === "sent" && (
                <Button
                  onClick={() => {
                    setIsDetailDialogOpen(false);
                    setIsConfirmReceiptDialogOpen(true);
                  }}
                >
                  <CheckCircle2 className="w-4 h-4 mr-2" />
                  Conferma Ricezione
                </Button>
              )}
              <Button variant="outline" onClick={() => setIsDetailDialogOpen(false)}>Chiudi</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>

        {/* Resend Dialog */}
        <Dialog open={isResendDialogOpen} onOpenChange={(open) => {
          setIsResendDialogOpen(open);
          if (!open) {
            setForceSubstitution(false);
          }
        }}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Reinvio Sostitutivo</DialogTitle>
              <DialogDescription>
                Crea una nuova trasmissione sostitutiva (Sostituzione="S") per questa trasmissione fallita.
              </DialogDescription>
            </DialogHeader>
            <div className="space-y-4 py-4">
              {selectedTransmission && (
                <div className="p-3 bg-amber-50 dark:bg-amber-950/30 rounded-lg border border-amber-200 dark:border-amber-800">
                  <p className="text-sm text-muted-foreground">
                    <strong>File:</strong> {selectedTransmission.fileName ? `${selectedTransmission.fileName}${selectedTransmission.fileExtension || ''}` : 'N/A'}
                  </p>
                  <p className="text-sm text-muted-foreground mt-1">
                    <strong>Tipo:</strong> {getTypeLabel(selectedTransmission.transmissionType)}
                  </p>
                  <p className="text-sm text-muted-foreground mt-1">
                    <strong>Stato:</strong> {selectedTransmission.status}
                  </p>
                  {selectedTransmission.errorMessage && (
                    <p className="text-sm text-red-600 dark:text-red-400 mt-1">
                      <strong>Errore:</strong> {selectedTransmission.errorMessage}
                    </p>
                  )}
                </div>
              )}
              <div className="flex items-start space-x-3 p-3 bg-amber-500/10 rounded-lg border border-amber-500/30">
                <Checkbox
                  id="forceSubstitutionResend"
                  checked={forceSubstitution}
                  onCheckedChange={(checked) => setForceSubstitution(checked === true)}
                  data-testid="checkbox-force-substitution-resend"
                  className="mt-0.5"
                />
                <div className="flex-1">
                  <Label htmlFor="forceSubstitutionResend" className="text-sm font-medium cursor-pointer">
                    Forza Sostituzione (Sostituzione=S)
                  </Label>
                  <p className="text-xs text-muted-foreground">
                    Usa questa opzione per reinviare un report già elaborato (errore 40604)
                  </p>
                </div>
              </div>
              <div>
                <Label>Email Destinatario SIAE</Label>
                <Input
                  type="email"
                  value={resendEmail}
                  onChange={(e) => setResendEmail(e.target.value)}
                  placeholder="servertest2@batest.siae.it"
                  data-testid="input-resend-email"
                />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsResendDialogOpen(false)} data-testid="button-resend-cancel">Annulla</Button>
              <Button
                onClick={() => {
                  if (selectedTransmission) {
                    resendTransmissionMutation.mutate({
                      id: selectedTransmission.id,
                      toEmail: resendEmail,
                      forceSubstitution,
                    });
                  }
                }}
                disabled={!resendEmail || resendTransmissionMutation.isPending}
                data-testid="button-resend-confirm"
              >
                {resendTransmissionMutation.isPending && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                <RotateCcw className="w-4 h-4 mr-2" />
                Reinvia Sostitutivo
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
        </>
        )}
      </div>
    );
  }

  // Mobile version
  const header = (
    <MobileHeader
      title="Trasmissioni SIAE"
      showBackButton
      showUserMenu
      rightAction={
        <div className="relative">
          <HapticButton
            variant="ghost"
            size="icon"
            className="h-11 w-11 rounded-full"
            onClick={() => setIsFilterSheetOpen(true)}
          >
            <Filter className="h-5 w-5" />
          </HapticButton>
          {activeFiltersCount > 0 && (
            <span className="absolute -top-1 -right-1 bg-[#FFD700] text-black text-[10px] font-bold min-w-[18px] h-[18px] rounded-full flex items-center justify-center">
              {activeFiltersCount}
            </span>
          )}
        </div>
      }
    />
  );

  return (
    <MobileAppLayout
      header={header}
      className="bg-background"
      contentClassName="pb-24"
    >
      <div className="space-y-4 py-4" data-testid="page-siae-transmissions">
        {isSuperAdmin && (
          <motion.div
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={springTransition}
          >
            <Card className="glass-card overflow-visible">
              <CardContent className="p-4">
                <div className="flex items-center gap-2 mb-2">
                  <Building2 className="h-4 w-4 text-amber-400" />
                  <Label className="text-sm text-muted-foreground">Seleziona Azienda</Label>
                </div>
                <Select
                  value={selectedCompanyId || ""}
                  onValueChange={(value) => setSelectedCompanyId(value)}
                >
                  <SelectTrigger className="w-full h-12 bg-background/50 rounded-xl" data-testid="select-company-mobile">
                    <SelectValue placeholder="Seleziona un'azienda..." />
                  </SelectTrigger>
                  <SelectContent>
                    {companies?.map((company) => (
                      <SelectItem key={company.id} value={company.id}>
                        {company.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </CardContent>
            </Card>
          </motion.div>
        )}

        {!companyId && isSuperAdmin && (
          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={springTransition}
          >
            <Card className="glass-card border-dashed overflow-visible">
              <CardContent className="py-12 text-center">
                <Building2 className="h-12 w-12 mx-auto text-muted-foreground/50 mb-4" />
                <h3 className="text-lg font-medium mb-2">Seleziona un'azienda</h3>
                <p className="text-sm text-muted-foreground">
                  Scegli un'azienda dal menu sopra per gestire le trasmissioni
                </p>
              </CardContent>
            </Card>
          </motion.div>
        )}

        {companyId && (
        <>
        <motion.div 
          className="grid grid-cols-3 gap-2"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={springTransition}
        >
          <Card className="glass-card overflow-visible">
            <CardContent className="p-3 text-center">
              <div className="flex items-center justify-center gap-1 text-xs text-muted-foreground mb-1">
                <Clock className="w-3 h-3 text-amber-400" />
                <span>Attesa</span>
              </div>
              <div className="text-xl font-bold text-amber-400" data-testid="stat-pending">{stats.pending}</div>
            </CardContent>
          </Card>
          <Card className="glass-card overflow-visible">
            <CardContent className="p-3 text-center">
              <div className="flex items-center justify-center gap-1 text-xs text-muted-foreground mb-1">
                <CheckCircle2 className="w-3 h-3 text-emerald-400" />
                <span>Ricevute</span>
              </div>
              <div className="text-xl font-bold text-emerald-400" data-testid="stat-received">{stats.received}</div>
            </CardContent>
          </Card>
          <Card className="glass-card overflow-visible">
            <CardContent className="p-3 text-center">
              <div className="flex items-center justify-center gap-1 text-xs text-muted-foreground mb-1">
                <AlertTriangle className="w-3 h-3 text-red-400" />
                <span>Errori</span>
              </div>
              <div className="text-xl font-bold text-red-400" data-testid="stat-error">{stats.error}</div>
            </CardContent>
          </Card>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ ...springTransition, delay: 0.05 }}
          className="space-y-3"
        >
          <HapticButton
            className="w-full h-14 text-base font-semibold bg-gradient-to-r from-[#FFD700] to-[#FFA500] text-black"
            onClick={() => setIsSendDailySheetOpen(true)}
            hapticType="medium"
            data-testid="button-send-c1-mobile"
          >
            <Zap className="w-5 h-5 mr-2" />
            Invia Trasmissione C1
          </HapticButton>
          
          <div className="grid grid-cols-2 gap-3">
            <HapticButton
              variant="outline"
              className="h-12"
              onClick={() => setIsCreateSheetOpen(true)}
              hapticType="light"
              data-testid="button-create"
            >
              <Upload className="w-4 h-4 mr-2" />
              Genera XML
            </HapticButton>
            <HapticButton
              variant="outline"
              className="h-12"
              onClick={() => setIsTestEmailSheetOpen(true)}
              hapticType="light"
              data-testid="button-test-email"
            >
              <TestTube className="w-4 h-4 mr-2" />
              Test Email
            </HapticButton>
          </div>
        </motion.div>

        {isLoading ? (
          <div className="space-y-3">
            {[1, 2, 3].map((i) => (
              <motion.div
                key={i}
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: i * 0.1 }}
              >
                <Card className="glass-card overflow-visible">
                  <CardContent className="p-4">
                    <Skeleton className="h-6 w-3/4 mb-3" />
                    <Skeleton className="h-4 w-1/2 mb-2" />
                    <Skeleton className="h-4 w-1/3" />
                  </CardContent>
                </Card>
              </motion.div>
            ))}
          </div>
        ) : filteredTransmissions?.length === 0 ? (
          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={springTransition}
          >
            <Card className="glass-card overflow-visible" data-testid="card-empty-state">
              <CardContent className="p-8 text-center">
                <motion.div 
                  className="w-20 h-20 mx-auto mb-4 rounded-full bg-muted/30 flex items-center justify-center"
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  transition={{ ...springTransition, delay: 0.1 }}
                >
                  <Send className="w-10 h-10 text-muted-foreground" />
                </motion.div>
                <h3 className="text-lg font-semibold mb-2">Nessuna Trasmissione</h3>
                <p className="text-muted-foreground mb-6 text-sm">
                  Non ci sono trasmissioni XML registrate
                </p>
                <HapticButton 
                  className="h-12 px-6"
                  onClick={() => setIsCreateSheetOpen(true)}
                  hapticType="medium"
                >
                  <Upload className="w-5 h-5 mr-2" />
                  Genera Prima Trasmissione
                </HapticButton>
              </CardContent>
            </Card>
          </motion.div>
        ) : (
          <div className="space-y-3">
            <AnimatePresence mode="popLayout">
              {filteredTransmissions?.map((transmission, index) => {
                const statusConfig = getStatusConfig(transmission.status);
                const StatusIcon = statusConfig.icon;
                
                return (
                  <motion.div
                    key={transmission.id}
                    layout
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, scale: 0.95 }}
                    transition={{ ...springTransition, delay: index * 0.03 }}
                    data-testid={`card-transmission-${transmission.id}`}
                  >
                    <Card 
                      className="glass-card overflow-visible hover-elevate active:scale-[0.98] transition-transform"
                      onClick={() => {
                        triggerHaptic('light');
                        setSelectedTransmission(transmission);
                        setIsDetailSheetOpen(true);
                      }}
                    >
                      <CardContent className="p-4">
                        <div className="flex items-start gap-4">
                          <div className={`w-12 h-12 rounded-xl flex items-center justify-center ${statusConfig.bgColor} shrink-0`}>
                            <StatusIcon className={`w-6 h-6 ${statusConfig.color}`} />
                          </div>
                          
                          <div className="flex-1 min-w-0">
                            <div className="flex items-start justify-between gap-2 mb-2">
                              <div className="flex-1 min-w-0">
                                <h3 className="font-semibold text-base truncate flex items-center gap-2">
                                  <FileText className="w-4 h-4 shrink-0" />
                                  {transmission.fileName ? `${transmission.fileName}${transmission.fileExtension || ''}` : `${transmission.id.slice(0, 8)}${transmission.fileExtension}`}
                                </h3>
                                <p className="text-sm text-muted-foreground mt-0.5">
                                  {getTypeLabel(transmission.transmissionType)} • {transmission.periodDate && format(new Date(transmission.periodDate), "dd MMM yyyy", { locale: it })}
                                </p>
                              </div>
                              {statusConfig.badge}
                            </div>
                            
                            <div className="flex items-center justify-between">
                              <div className="flex items-center gap-4 text-sm">
                                <span className="flex items-center gap-1.5 text-muted-foreground">
                                  <Ticket className="w-4 h-4" />
                                  {transmission.ticketsCount}
                                </span>
                                <span className="flex items-center gap-1.5 text-[#FFD700] font-medium">
                                  <Euro className="w-4 h-4" />
                                  {Number(transmission.totalAmount || 0).toFixed(2)}
                                </span>
                              </div>
                              <ChevronRight className="w-5 h-5 text-muted-foreground" />
                            </div>
                          </div>
                        </div>
                      </CardContent>
                    </Card>
                  </motion.div>
                );
              })}
            </AnimatePresence>
          </div>
        )}
        </>
        )}
      </div>

      <BottomSheet
        open={isCreateSheetOpen}
        onClose={() => setIsCreateSheetOpen(false)}
        title="Genera Trasmissione"
      >
        <div className="p-4 space-y-6">
          <div className="text-center py-4">
            <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-[#FFD700]/20 flex items-center justify-center">
              <Upload className="w-8 h-8 text-[#FFD700]" />
            </div>
            <p className="text-muted-foreground text-sm">
              Crea un nuovo file XML da inviare a SIAE
            </p>
          </div>

          <div className="space-y-4">
            <div>
              <Label className="text-sm font-medium mb-2 block">Tipo Trasmissione</Label>
              <Select value={transmissionType} onValueChange={setTransmissionType}>
                <SelectTrigger className="h-12" data-testid="select-transmission-type">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="daily">Giornaliera</SelectItem>
                  <SelectItem value="monthly">Mensile</SelectItem>
                  <SelectItem value="corrective">Correttiva</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div>
              <Label className="text-sm font-medium mb-2 block">Data Periodo</Label>
              <Input
                type="date"
                value={periodDate}
                onChange={(e) => setPeriodDate(e.target.value)}
                className="h-12"
                data-testid="input-period-date"
              />
            </div>
          </div>

          <div className="flex gap-3 pt-4">
            <HapticButton
              variant="outline"
              className="flex-1 h-12"
              onClick={() => setIsCreateSheetOpen(false)}
            >
              Annulla
            </HapticButton>
            <HapticButton
              className="flex-1 h-12 bg-[#FFD700] text-black hover:bg-[#FFD700]/90"
              onClick={() => {
                createTransmissionMutation.mutate({
                  transmissionType,
                  periodDate,
                });
              }}
              disabled={!periodDate || createTransmissionMutation.isPending}
              hapticType="medium"
              data-testid="button-generate"
            >
              {createTransmissionMutation.isPending && <Loader2 className="w-5 h-5 mr-2 animate-spin" />}
              Genera XML
            </HapticButton>
          </div>
        </div>
      </BottomSheet>

      <BottomSheet
        open={isFilterSheetOpen}
        onClose={() => setIsFilterSheetOpen(false)}
        title="Filtra Trasmissioni"
      >
        <div className="p-4 space-y-6">
          <div className="space-y-4">
            <div>
              <Label className="text-sm font-medium mb-2 block">Stato</Label>
              <Select value={statusFilter} onValueChange={setStatusFilter}>
                <SelectTrigger className="h-12" data-testid="select-status-filter">
                  <SelectValue placeholder="Stato" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Tutti gli stati</SelectItem>
                  <SelectItem value="pending">In Attesa</SelectItem>
                  <SelectItem value="sent">Inviate</SelectItem>
                  <SelectItem value="received">Ricevute</SelectItem>
                  <SelectItem value="error">Errori</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div>
              <Label className="text-sm font-medium mb-2 block">Tipo</Label>
              <Select value={typeFilter} onValueChange={setTypeFilter}>
                <SelectTrigger className="h-12" data-testid="select-type-filter">
                  <SelectValue placeholder="Tipo" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Tutti i tipi</SelectItem>
                  <SelectItem value="daily">Giornaliera</SelectItem>
                  <SelectItem value="monthly">Mensile</SelectItem>
                  <SelectItem value="corrective">Correttiva</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>

          <div className="flex gap-3 pt-4">
            <HapticButton
              variant="outline"
              className="flex-1 h-12"
              onClick={() => {
                setStatusFilter("all");
                setTypeFilter("all");
              }}
            >
              <X className="w-4 h-4 mr-2" />
              Reset
            </HapticButton>
            <HapticButton
              className="flex-1 h-12"
              onClick={() => setIsFilterSheetOpen(false)}
              hapticType="light"
            >
              Applica Filtri
            </HapticButton>
          </div>
        </div>
      </BottomSheet>

      <BottomSheet
        open={isDetailSheetOpen}
        onClose={() => setIsDetailSheetOpen(false)}
        title="Dettaglio Trasmissione"
      >
        {selectedTransmission && (
          <div className="p-4 space-y-6">
            <div className="flex items-center gap-4">
              {(() => {
                const statusConfig = getStatusConfig(selectedTransmission.status);
                const StatusIcon = statusConfig.icon;
                return (
                  <>
                    <div className={`w-16 h-16 rounded-2xl flex items-center justify-center ${statusConfig.bgColor}`}>
                      <StatusIcon className={`w-8 h-8 ${statusConfig.color}`} />
                    </div>
                    <div className="flex-1">
                      <h3 className="font-semibold text-lg">{getTypeLabel(selectedTransmission.transmissionType)}</h3>
                      <p className="text-muted-foreground text-sm">
                        {selectedTransmission.periodDate && format(new Date(selectedTransmission.periodDate), "dd MMMM yyyy", { locale: it })}
                      </p>
                    </div>
                    {statusConfig.badge}
                  </>
                );
              })()}
            </div>

            <div className="grid grid-cols-2 gap-3">
              <Card className="glass-card overflow-visible">
                <CardContent className="p-4 text-center">
                  <div className="flex items-center justify-center gap-1 text-xs text-muted-foreground mb-1">
                    <Ticket className="w-3 h-3" />
                    <span>Biglietti</span>
                  </div>
                  <div className="text-2xl font-bold">{selectedTransmission.ticketsCount}</div>
                </CardContent>
              </Card>
              <Card className="glass-card overflow-visible">
                <CardContent className="p-4 text-center">
                  <div className="flex items-center justify-center gap-1 text-xs text-muted-foreground mb-1">
                    <Euro className="w-3 h-3" />
                    <span>Importo</span>
                  </div>
                  <div className="text-2xl font-bold text-[#FFD700]">€{Number(selectedTransmission.totalAmount || 0).toFixed(2)}</div>
                </CardContent>
              </Card>
            </div>

            <div className="space-y-3">
              {selectedTransmission.fileName && (
                <div className="flex justify-between py-3 border-b border-border/50">
                  <span className="text-muted-foreground text-sm">File</span>
                  <span className="font-mono text-sm">{selectedTransmission.fileName}{selectedTransmission.fileExtension || ''}</span>
                </div>
              )}
              {selectedTransmission.sentAt && (
                <div className="flex justify-between py-3 border-b border-border/50">
                  <span className="text-muted-foreground text-sm">Data Invio</span>
                  <span className="text-sm">
                    {format(new Date(selectedTransmission.sentAt), "dd/MM/yyyy HH:mm", { locale: it })}
                  </span>
                </div>
              )}
              {selectedTransmission.sentToPec && (
                <div className="flex justify-between py-3 border-b border-border/50">
                  <span className="text-muted-foreground text-sm">PEC Destinatario</span>
                  <span className="text-sm truncate max-w-[180px]">{selectedTransmission.sentToPec}</span>
                </div>
              )}
              {selectedTransmission.sentAt && (
                <div className="flex justify-between py-3 border-b border-border/50">
                  <span className="text-muted-foreground text-sm">Firma S/MIME</span>
                  {selectedTransmission.smimeSigned ? (
                    <div className="flex items-center gap-2 text-sm text-green-400">
                      <ShieldCheck className="w-4 h-4" />
                      <span className="truncate max-w-[150px]">{selectedTransmission.smimeSignerEmail || 'Firmata'}</span>
                    </div>
                  ) : (
                    <div className="flex items-center gap-2 text-sm text-amber-400">
                      <ShieldAlert className="w-4 h-4" />
                      <span>Non firmata</span>
                    </div>
                  )}
                </div>
              )}
              {selectedTransmission.receivedAt && (
                <div className="flex justify-between py-3 border-b border-border/50">
                  <span className="text-muted-foreground text-sm">Data Ricezione</span>
                  <span className="text-sm">
                    {format(new Date(selectedTransmission.receivedAt), "dd/MM/yyyy HH:mm", { locale: it })}
                  </span>
                </div>
              )}
              {selectedTransmission.receiptProtocol && (
                <div className="flex justify-between py-3 border-b border-border/50">
                  <span className="text-muted-foreground text-sm">Protocollo SIAE</span>
                  <span className="text-sm font-mono text-green-400">{selectedTransmission.receiptProtocol}</span>
                </div>
              )}
              {selectedTransmission.retryCount > 0 && (
                <div className="flex justify-between py-3 border-b border-border/50">
                  <span className="text-muted-foreground text-sm">Tentativi</span>
                  <span className="text-sm">{selectedTransmission.retryCount}</span>
                </div>
              )}
              {selectedTransmission.errorMessage && (
                <div className="py-3">
                  <span className="text-muted-foreground text-sm block mb-2">Messaggio Errore</span>
                  <p className="text-sm text-red-400 bg-red-500/10 p-3 rounded-lg">{selectedTransmission.errorMessage}</p>
                </div>
              )}
            </div>

            <div className="flex flex-col gap-3 pt-4">
              {selectedTransmission.status === "sent" && (
                <HapticButton
                  className="w-full h-12 bg-green-500 text-white hover:bg-green-500/90"
                  onClick={() => setIsConfirmReceiptSheetOpen(true)}
                  hapticType="medium"
                  data-testid={`button-confirm-receipt-${selectedTransmission.id}`}
                >
                  <CheckCircle2 className="w-5 h-5 mr-2" />
                  Conferma Ricezione SIAE
                </HapticButton>
              )}
              {selectedTransmission.fileContent && selectedTransmission.status === "pending" && (
                <HapticButton
                  className="w-full h-12 bg-[#FFD700] text-black hover:bg-[#FFD700]/90"
                  onClick={() => {
                    sendEmailMutation.mutate({
                      id: selectedTransmission.id,
                      toEmail: "servertest2@batest.siae.it",
                    });
                  }}
                  disabled={sendEmailMutation.isPending}
                  hapticType="medium"
                  data-testid={`button-send-email-${selectedTransmission.id}`}
                >
                  {sendEmailMutation.isPending ? (
                    <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                  ) : (
                    <Mail className="w-5 h-5 mr-2" />
                  )}
                  Invia via Email
                </HapticButton>
              )}
              <div className="flex gap-3">
                {selectedTransmission.fileContent && (
                  <HapticButton
                    variant="outline"
                    className="flex-1 h-12"
                    hapticType="light"
                    data-testid={`button-download-${selectedTransmission.id}`}
                  >
                    <Download className="w-5 h-5 mr-2" />
                    Scarica XML
                  </HapticButton>
                )}
                {selectedTransmission.status === "error" && (
                  <HapticButton
                    className="flex-1 h-12"
                    onClick={() => {
                      retryTransmissionMutation.mutate(selectedTransmission.id);
                    }}
                    disabled={retryTransmissionMutation.isPending}
                    hapticType="medium"
                    data-testid={`button-retry-${selectedTransmission.id}`}
                  >
                    {retryTransmissionMutation.isPending ? (
                      <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                    ) : (
                      <RefreshCw className="w-5 h-5 mr-2" />
                    )}
                    Riprova Invio
                  </HapticButton>
                )}
                {!selectedTransmission.fileContent && selectedTransmission.status !== "error" && (
                  <HapticButton
                    className="flex-1 h-12"
                    onClick={() => setIsDetailSheetOpen(false)}
                    hapticType="light"
                  >
                    Chiudi
                  </HapticButton>
                )}
              </div>
            </div>
          </div>
        )}
      </BottomSheet>

      <BottomSheet
        open={isTestEmailSheetOpen}
        onClose={() => setIsTestEmailSheetOpen(false)}
        title="Test Invio Email"
      >
        <div className="p-4 space-y-6">
          <div className="text-center py-4">
            <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-cyan-500/20 flex items-center justify-center">
              <TestTube className="w-8 h-8 text-cyan-400" />
            </div>
            <p className="text-muted-foreground text-sm">
              Invia un'email di test per verificare la configurazione
            </p>
          </div>

          <div>
            <Label className="text-sm font-medium mb-2 block">Email Destinatario</Label>
            <Input
              type="email"
              value={testEmail}
              onChange={(e) => setTestEmail(e.target.value)}
              className="h-12"
              placeholder="servertest2@batest.siae.it"
              data-testid="input-test-email"
            />
          </div>

          <div className="flex gap-3 pt-4">
            <HapticButton
              variant="outline"
              className="flex-1 h-12"
              onClick={() => setIsTestEmailSheetOpen(false)}
            >
              Annulla
            </HapticButton>
            <HapticButton
              className="flex-1 h-12 bg-cyan-500 text-white hover:bg-cyan-500/90"
              onClick={() => testEmailMutation.mutate(testEmail)}
              disabled={!testEmail || testEmailMutation.isPending}
              hapticType="medium"
              data-testid="button-send-test"
            >
              {testEmailMutation.isPending && <Loader2 className="w-5 h-5 mr-2 animate-spin" />}
              Invia Test
            </HapticButton>
          </div>
        </div>
      </BottomSheet>

      <BottomSheet
        open={isSendDailySheetOpen}
        onClose={() => setIsSendDailySheetOpen(false)}
        title="Trasmissione Report SIAE"
      >
        <div className="p-4 space-y-6">
          <div className="text-center py-4">
            <div className={`w-16 h-16 mx-auto mb-4 rounded-full ${
              c1Type === 'monthly' ? 'bg-amber-500/20' : 
              c1Type === 'rca' ? 'bg-green-500/20' : 'bg-blue-500/20'
            } flex items-center justify-center`}>
              {c1Type === 'monthly' ? (
                <Calendar className="w-8 h-8 text-amber-400" />
              ) : c1Type === 'rca' ? (
                <Ticket className="w-8 h-8 text-green-400" />
              ) : (
                <Clock className="w-8 h-8 text-blue-400" />
              )}
            </div>
            <p className="text-muted-foreground text-sm">
              {c1Type === 'monthly' 
                ? "RPM - Riepilogo Periodico Mensile (C1)"
                : c1Type === 'rca'
                ? "RCA - Riepilogo Controllo Accessi"
                : "RMG - Riepilogo Mensile Giornaliero (C1)"}
            </p>
          </div>

          <div className="space-y-4">
            <div>
              <Label className="text-sm font-medium mb-2 block">Frequenza Trasmissione</Label>
              <Select value={c1Type} onValueChange={(v: 'daily' | 'monthly' | 'rca') => { setC1Type(v); }}>
                <SelectTrigger className="h-12" data-testid="select-c1-type-mobile">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="daily">RMG - Giornaliero</SelectItem>
                  <SelectItem value="monthly">RPM - Mensile</SelectItem>
                  <SelectItem value="rca">RCA - Controllo Accessi</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            {/* Info box per mobile */}
            <div className={`p-3 rounded-lg ${
              c1Type === 'monthly' ? 'bg-amber-500/10 border border-amber-500/30' : 
              c1Type === 'rca' ? 'bg-green-500/10 border border-green-500/30' :
              'bg-blue-500/10 border border-blue-500/30'
            }`}>
              <p className="text-xs text-muted-foreground">
                {c1Type === 'monthly' 
                  ? "DataRiepilogo in formato AAAAMM01. Conforme ad Allegato B."
                  : c1Type === 'rca'
                  ? "Report specifico evento con dati biglietteria. Conforme ad Allegato B."
                  : "DataRiepilogo in formato AAAAMMGG. Conforme ad Allegato B."}
              </p>
            </div>
            
            {/* Selezione evento - richiesto per RCA, opzionale per RMG/RPM */}
            <div>
              <Label className="text-sm font-medium mb-2 block">Evento {c1Type === 'rca' && <span className="text-destructive">*</span>}</Label>
              <Select value={selectedEventId} onValueChange={setSelectedEventId}>
                <SelectTrigger className={`h-12 ${c1Type === 'rca' && !selectedEventId ? 'border-destructive' : ''}`} data-testid="select-rca-event-mobile">
                  <SelectValue placeholder={c1Type === 'rca' ? "Seleziona evento concluso..." : "Seleziona evento..."} />
                </SelectTrigger>
                <SelectContent>
                  {/* FIX 2026-01-18: Per RMG/RPM usa eventsForDaily (include ongoing) */}
                  {(c1Type === 'rca' ? eventsForRCA : eventsForDaily).length === 0 ? (
                    <SelectItem value="none" disabled>
                      {c1Type === 'rca' ? 'Nessun evento concluso' : 'Nessun evento disponibile'}
                    </SelectItem>
                  ) : (
                    (c1Type === 'rca' ? eventsForRCA : eventsForDaily).map((event) => (
                      <SelectItem key={event.id} value={event.id}>
                        {event.eventName} - {format(new Date(event.eventDate), "d MMM", { locale: it })}
                        {event.status === 'ongoing' && ' (in corso)'}
                        {event.status === 'scheduled' && ' (prog.)'}
                      </SelectItem>
                    ))
                  )}
                </SelectContent>
              </Select>
              {c1Type === 'rca' && !selectedEventId && (
                <p className="text-xs text-destructive mt-1">
                  Seleziona un evento per inviare il report RCA
                </p>
              )}
              {c1Type !== 'rca' && (
                <p className="text-xs text-muted-foreground mt-1">
                  Per RMG/RPM puoi selezionare eventi in corso
                </p>
              )}
            </div>
            
            {/* Checklist Validazione Prerequisiti SIAE - Mobile */}
            {c1Type === 'rca' && selectedEventId && (
              <div className="p-3 rounded-lg border">
                {isLoadingPrerequisites ? (
                  <div className="flex items-center gap-2 text-muted-foreground">
                    <Loader2 className="w-4 h-4 animate-spin" />
                    <span className="text-sm">Verifica prerequisiti...</span>
                  </div>
                ) : prerequisiteValidation ? (
                  <div className="space-y-3">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        {prerequisiteValidation.isReady ? (
                          <CheckCircle2 className="w-5 h-5 text-green-500" />
                        ) : (
                          <AlertTriangle className="w-5 h-5 text-amber-500" />
                        )}
                        <span className="font-medium text-sm">
                          {prerequisiteValidation.isReady ? 'Pronto' : 'Verifica richiesta'}
                        </span>
                      </div>
                      <Badge variant={prerequisiteValidation.score >= 80 ? 'default' : prerequisiteValidation.score >= 50 ? 'secondary' : 'destructive'}>
                        {prerequisiteValidation.score}%
                      </Badge>
                    </div>
                    
                    {/* Errori bloccanti */}
                    {prerequisiteValidation.errors.length > 0 && (
                      <div className="space-y-2">
                        <p className="text-xs font-medium text-destructive">Errori:</p>
                        {prerequisiteValidation.errors.slice(0, 2).map((err, idx) => (
                          <div key={idx} className="text-xs p-2 bg-destructive/10 rounded">
                            <p className="font-medium">{err.message}</p>
                          </div>
                        ))}
                        {prerequisiteValidation.errors.length > 2 && (
                          <p className="text-xs text-muted-foreground">
                            +{prerequisiteValidation.errors.length - 2} altri errori
                          </p>
                        )}
                      </div>
                    )}
                  </div>
                ) : null}
              </div>
            )}
            
            {/* Data/Mese di riferimento */}
            <div>
              <Label className="text-sm font-medium mb-2 block">{c1Type === 'monthly' ? 'Mese di riferimento' : c1Type === 'rca' ? 'Data Evento' : 'Data Riepilogo'}</Label>
              <Input
                type={c1Type === 'monthly' ? 'month' : 'date'}
                value={dailyDate}
                onChange={(e) => setDailyDate(e.target.value)}
                className="h-12"
                data-testid="input-c1-date-mobile"
              />
            </div>
            
            <div>
              <Label className="text-sm font-medium mb-2 block">Email Destinatario SIAE</Label>
              <Input
                type="email"
                value={dailyEmail}
                onChange={(e) => setDailyEmail(e.target.value)}
                className="h-12"
                placeholder="servertest2@batest.siae.it"
                data-testid="input-c1-email-mobile"
              />
            </div>
            
            {/* Checkbox Forza Sostituzione per errore 40604 - Mobile */}
            <div className="flex items-start space-x-3 p-3 bg-amber-500/10 rounded-lg border border-amber-500/30">
              <Checkbox
                id="forceSubstitutionMobile"
                checked={forceSubstitution}
                onCheckedChange={(checked) => setForceSubstitution(checked === true)}
                data-testid="checkbox-force-substitution-mobile"
                className="mt-0.5"
              />
              <div className="flex-1">
                <Label htmlFor="forceSubstitutionMobile" className="text-sm font-medium cursor-pointer">
                  Forza Sostituzione
                </Label>
                <p className="text-xs text-muted-foreground">
                  Per reinviare report già elaborato (errore 40604)
                </p>
              </div>
            </div>
          </div>

          <div className="flex gap-3 pt-4">
            <HapticButton
              variant="outline"
              className="flex-1 h-12"
              onClick={() => setIsSendDailySheetOpen(false)}
            >
              Annulla
            </HapticButton>
            <HapticButton
              className={`flex-1 h-12 ${
                c1Type === 'monthly' ? 'bg-amber-500 text-black hover:bg-amber-500/90' : 
                c1Type === 'rca' ? 'bg-green-500 text-white hover:bg-green-500/90' :
                'bg-blue-500 text-white hover:bg-blue-500/90'
              }`}
              onClick={() => sendC1Mutation.mutate({ 
                date: dailyDate, 
                toEmail: dailyEmail, 
                type: c1Type,
                eventId: selectedEventId,
                forceSubstitution
              })}
              disabled={
                (c1Type === 'rca' && !selectedEventId) || 
                (c1Type === 'rca' && prerequisiteValidation && !prerequisiteValidation.isReady) ||
                !dailyDate || 
                !dailyEmail || 
                sendC1Mutation.isPending
              }
              hapticType="medium"
              data-testid="button-send-c1-confirm"
            >
              {sendC1Mutation.isPending && <Loader2 className="w-5 h-5 mr-2 animate-spin" />}
              {c1Type === 'monthly' ? 'Invia RPM Mensile' : c1Type === 'rca' ? 'Invia RCA Evento' : 'Invia RMG Giornaliero'}
            </HapticButton>
          </div>
        </div>
      </BottomSheet>

      <BottomSheet
        open={isConfirmReceiptSheetOpen}
        onClose={() => {
          setIsConfirmReceiptSheetOpen(false);
          setReceiptProtocol("");
          setReceiptContent("");
        }}
        title="Conferma Ricezione SIAE"
      >
        <div className="p-4 space-y-6">
          <div className="text-center py-4">
            <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-green-500/20 flex items-center justify-center">
              <CheckCircle2 className="w-8 h-8 text-green-400" />
            </div>
            <p className="text-muted-foreground text-sm">
              Registra la conferma di ricezione ricevuta da SIAE
            </p>
          </div>

          <div className="space-y-4">
            <div>
              <Label className="text-sm font-medium mb-2 block">Protocollo Ricezione *</Label>
              <Input
                type="text"
                value={receiptProtocol}
                onChange={(e) => setReceiptProtocol(e.target.value)}
                className="h-12"
                placeholder="Es: SIAE-2025-001234"
                data-testid="input-receipt-protocol"
              />
              <p className="text-xs text-muted-foreground mt-1">
                Inserisci il numero di protocollo presente nell'email di conferma SIAE
              </p>
            </div>
            
            <div>
              <Label className="text-sm font-medium mb-2 block">Contenuto Ricevuta (opzionale)</Label>
              <Input
                type="text"
                value={receiptContent}
                onChange={(e) => setReceiptContent(e.target.value)}
                className="h-12"
                placeholder="Note o riferimenti aggiuntivi"
                data-testid="input-receipt-content"
              />
            </div>
          </div>

          <div className="flex gap-3 pt-4">
            <HapticButton
              variant="outline"
              className="flex-1 h-12"
              onClick={() => {
                setIsConfirmReceiptSheetOpen(false);
                setReceiptProtocol("");
                setReceiptContent("");
              }}
            >
              Annulla
            </HapticButton>
            <HapticButton
              className="flex-1 h-12 bg-green-500 text-white hover:bg-green-500/90"
              onClick={() => {
                if (selectedTransmission) {
                  confirmReceiptMutation.mutate({
                    id: selectedTransmission.id,
                    receiptProtocol,
                    receiptContent: receiptContent || undefined,
                  });
                }
              }}
              disabled={!receiptProtocol || confirmReceiptMutation.isPending}
              hapticType="medium"
              data-testid="button-confirm-receipt-submit"
            >
              {confirmReceiptMutation.isPending && <Loader2 className="w-5 h-5 mr-2 animate-spin" />}
              Conferma Ricezione
            </HapticButton>
          </div>
        </div>
      </BottomSheet>
    </MobileAppLayout>
  );
}


